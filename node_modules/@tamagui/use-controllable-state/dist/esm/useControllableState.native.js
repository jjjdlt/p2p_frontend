import { useEvent } from "@tamagui/use-event";
import { startTransition, useEffect, useRef, useState } from "react";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var emptyCallbackFn = function(_) {
  return _();
};
function useControllableState(param) {
  var prop = param.prop, defaultProp = param.defaultProp, onChange = param.onChange, _param_strategy = param.strategy, strategy = _param_strategy === void 0 ? "prop-wins" : _param_strategy, preventUpdate = param.preventUpdate, transition = param.transition, _useState = _sliced_to_array(useState(prop ?? defaultProp), 2), state = _useState[0], setState = _useState[1], previous = useRef(state), propWins = strategy === "prop-wins" && prop !== void 0, value = propWins ? prop : state, onChangeCb = useEvent(onChange || idFn), transitionFn = transition ? startTransition : emptyCallbackFn;
  useEffect(function() {
    prop !== void 0 && (previous.current = prop, transitionFn(function() {
      setState(prop);
    }));
  }, [
    prop
  ]), useEffect(function() {
    propWins || state !== previous.current && (previous.current = state, onChangeCb(state));
  }, [
    onChangeCb,
    state,
    propWins
  ]);
  var setter = useEvent(function(next) {
    if (!preventUpdate)
      if (propWins) {
        var nextValue = typeof next == "function" ? next(previous.current) : next;
        onChangeCb(nextValue);
      } else
        transitionFn(function() {
          setState(next);
        });
  });
  return [
    value,
    setter
  ];
}
var idFn = function() {
};
export {
  useControllableState
};
//# sourceMappingURL=useControllableState.js.map
