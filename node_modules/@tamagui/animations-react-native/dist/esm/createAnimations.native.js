import { ResetPresence, usePresence } from "@tamagui/use-presence";
import { isWeb, useIsomorphicLayoutEffect } from "@tamagui/constants";
import { useEvent } from "@tamagui/web";
import { useEffect, useMemo, useRef } from "react";
import { Animated } from "react-native";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _object_without_properties(source, excluded) {
  if (source == null) return {};
  var target = _object_without_properties_loose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var animatedStyleKey = {
  transform: !0,
  opacity: !0
}, colorStyleKey = {
  backgroundColor: !0,
  color: !0,
  borderColor: !0,
  borderLeftColor: !0,
  borderRightColor: !0,
  borderTopColor: !0,
  borderBottomColor: !0
}, costlyToAnimateStyleKey = _object_spread({
  borderRadius: !0,
  borderTopLeftRadius: !0,
  borderTopRightRadius: !0,
  borderBottomLeftRadius: !0,
  borderBottomRightRadius: !0,
  borderWidth: !0,
  borderLeftWidth: !0,
  borderRightWidth: !0,
  borderTopWidth: !0,
  borderBottomWidth: !0
}, colorStyleKey), AnimatedView = Animated.View, AnimatedText = Animated.Text;
function useAnimatedNumber(initial) {
  var state = useRef(null);
  return state.current || (state.current = {
    composite: null,
    val: new Animated.Value(initial),
    strategy: {
      type: "spring"
    }
  }), {
    getInstance: function() {
      return state.current.val;
    },
    getValue: function() {
      return state.current.val._value;
    },
    stop: function() {
      var _state_current_composite;
      (_state_current_composite = state.current.composite) === null || _state_current_composite === void 0 || _state_current_composite.stop(), state.current.composite = null;
    },
    setValue: function(next) {
      var _param = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        type: "spring"
      }, onFinish = arguments.length > 2 ? arguments[2] : void 0, type = _param.type, config = _object_without_properties(_param, [
        "type"
      ]), val = state.current.val, handleFinish = onFinish ? function(param) {
        var finished = param.finished;
        return finished ? onFinish() : null;
      } : void 0;
      if (type === "direct")
        val.setValue(next);
      else if (type === "spring") {
        var _state_current_composite;
        (_state_current_composite = state.current.composite) === null || _state_current_composite === void 0 || _state_current_composite.stop();
        var composite = Animated.spring(val, _object_spread_props(_object_spread({}, config), {
          toValue: next,
          useNativeDriver: !isWeb
        }));
        composite.start(handleFinish), state.current.composite = composite;
      } else {
        var _state_current_composite1;
        (_state_current_composite1 = state.current.composite) === null || _state_current_composite1 === void 0 || _state_current_composite1.stop();
        var composite1 = Animated.timing(val, _object_spread_props(_object_spread({}, config), {
          toValue: next,
          useNativeDriver: !isWeb
        }));
        composite1.start(handleFinish), state.current.composite = composite1;
      }
    }
  };
}
function useAnimatedNumberReaction(param, onValue) {
  var value = param.value, onChange = useEvent(function(current) {
    onValue(current.value);
  });
  useEffect(function() {
    var id = value.getInstance().addListener(onChange);
    return function() {
      value.getInstance().removeListener(id);
    };
  }, [
    value,
    onChange
  ]);
}
function useAnimatedNumberStyle(value, getStyle) {
  return getStyle(value.getInstance());
}
function createAnimations(animations) {
  return {
    isReactNative: !0,
    animations,
    View: AnimatedView,
    Text: AnimatedText,
    useAnimatedNumber,
    useAnimatedNumberReaction,
    useAnimatedNumberStyle,
    usePresence,
    ResetPresence,
    useAnimations: function(param) {
      var props = param.props, onDidAnimate = param.onDidAnimate, style = param.style, componentState = param.componentState, presence = param.presence, isExiting = (presence == null ? void 0 : presence[0]) === !1, sendExitComplete = presence == null ? void 0 : presence[1], animateStyles = useRef({}), animatedTranforms = useRef([]), animationsState = useRef(/* @__PURE__ */ new WeakMap()), animateOnly = props.animateOnly || [], hasAnimateOnly = !!props.animateOnly, args = [
        JSON.stringify(style),
        componentState,
        isExiting,
        !!onDidAnimate
      ], isThereNoNativeStyleKeys = useMemo(function() {
        return isWeb ? !0 : Object.keys(style).some(function(key) {
          return animateOnly.length ? !animatedStyleKey[key] && animateOnly.indexOf(key) === -1 : !animatedStyleKey[key];
        });
      }, args), res = useMemo(function() {
        var update = function(key2, animated, valIn) {
          var isColorStyleKey = colorStyleKey[key2], _ref = _sliced_to_array(isColorStyleKey ? [
            0,
            void 0
          ] : getValue(valIn), 2), val2 = _ref[0], type = _ref[1], animateToValue = val2, value = animated || new Animated.Value(val2), curInterpolation = animationsState.current.get(value), interpolateArgs;
          if (type) {
            var _curInterpolation_current;
            interpolateArgs = getInterpolated((_curInterpolation_current = curInterpolation == null ? void 0 : curInterpolation.current) !== null && _curInterpolation_current !== void 0 ? _curInterpolation_current : value._value, val2, type), animationsState.current.set(value, {
              interpolation: value.interpolate(interpolateArgs),
              current: val2
            });
          }
          if (isColorStyleKey && (animateToValue = curInterpolation != null && curInterpolation.animateToValue ? 0 : 1, interpolateArgs = getColorInterpolated(
            curInterpolation == null ? void 0 : curInterpolation.current,
            // valIn is the next color
            valIn,
            animateToValue
          ), animationsState.current.set(value, {
            current: valIn,
            interpolation: value.interpolate(interpolateArgs),
            animateToValue: curInterpolation != null && curInterpolation.animateToValue ? 0 : 1
          })), value) {
            var animationConfig = getAnimationConfig(key2, animations, props.animation), resolve, promise = new Promise(function(res2) {
              resolve = res2;
            });
            completions.push(promise), runners.push(function() {
              var getAnimation = function() {
                return Animated[animationConfig.type || "spring"](value, _object_spread({
                  toValue: animateToValue,
                  useNativeDriver: !isWeb && !isThereNoNativeStyleKeys
                }, animationConfig));
              };
              value.stopAnimation();
              var animation = animationConfig.delay ? Animated.sequence([
                Animated.delay(animationConfig.delay),
                getAnimation()
              ]) : getAnimation();
              animation.start(function(param2) {
                var finished = param2.finished;
                finished && resolve();
              });
            });
          }
          return process.env.NODE_ENV === "development" && props.debug === "verbose" && console.info(" \u{1F4A0} animate", key2, "from (".concat(value._value, ") to"), valIn, "(".concat(val2, ")"), "type", type, "interpolate", interpolateArgs), value;
        }, runners = [], completions = [], nonAnimatedStyle = {};
        for (var key in style) {
          var val = style[key];
          if (animatedStyleKey[key] == null && !costlyToAnimateStyleKey[key]) {
            nonAnimatedStyle[key] = val;
            continue;
          }
          if (hasAnimateOnly && !animateOnly.includes(key)) {
            nonAnimatedStyle[key] = val;
            continue;
          }
          if (key !== "transform") {
            animateStyles.current[key] = update(key, animateStyles.current[key], val);
            continue;
          }
          if (val) {
            if (typeof val == "string") {
              console.warn("Warning: Tamagui can't animate string transforms yet!");
              continue;
            }
            var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
            try {
              for (var _iterator = val.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                var _step_value = _sliced_to_array(_step.value, 2), index = _step_value[0], transform = _step_value[1], _animatedTranforms_current_index;
                if (transform) {
                  var tkey = Object.keys(transform)[0], currentTransform = (_animatedTranforms_current_index = animatedTranforms.current[index]) === null || _animatedTranforms_current_index === void 0 ? void 0 : _animatedTranforms_current_index[tkey];
                  animatedTranforms.current[index] = _define_property({}, tkey, update(tkey, currentTransform, transform[tkey])), animatedTranforms.current = _to_consumable_array(animatedTranforms.current);
                }
              }
            } catch (err) {
              _didIteratorError = !0, _iteratorError = err;
            } finally {
              try {
                !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
              } finally {
                if (_didIteratorError)
                  throw _iteratorError;
              }
            }
          }
        }
        var animatedStyle = _object_spread_props(_object_spread({}, Object.fromEntries(Object.entries(animateStyles.current).map(function(param2) {
          var _param = _sliced_to_array(param2, 2), k = _param[0], v = _param[1], _animationsState_current_get;
          return [
            k,
            ((_animationsState_current_get = animationsState.current.get(v)) === null || _animationsState_current_get === void 0 ? void 0 : _animationsState_current_get.interpolation) || v
          ];
        }))), {
          transform: animatedTranforms.current.map(function(r) {
            var _animationsState_current_get, key2 = Object.keys(r)[0], val2 = ((_animationsState_current_get = animationsState.current.get(r[key2])) === null || _animationsState_current_get === void 0 ? void 0 : _animationsState_current_get.interpolation) || r[key2];
            return _define_property({}, key2, val2);
          })
        });
        return {
          runners,
          completions,
          style: [
            nonAnimatedStyle,
            animatedStyle
          ]
        };
      }, args);
      return useIsomorphicLayoutEffect(function() {
        res.runners.forEach(function(r) {
          return r();
        });
        var cancel = !1;
        return Promise.all(res.completions).then(function() {
          cancel || (onDidAnimate == null || onDidAnimate(), isExiting && (sendExitComplete == null || sendExitComplete()));
        }), function() {
          cancel = !0;
        };
      }, args), process.env.NODE_ENV === "development" && props.debug === "verbose" && console.info("Animated", {
        response: res,
        inputStyle: style,
        isExiting
      }), res;
    }
  };
}
function getColorInterpolated(currentColor, nextColor, animateToValue) {
  var inputRange = [
    0,
    1
  ], outputRange = [
    currentColor || nextColor,
    nextColor
  ];
  return animateToValue === 0 && outputRange.reverse(), {
    inputRange,
    outputRange
  };
}
function getInterpolated(current, next) {
  var postfix = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "deg";
  next === current && (current = next - 1e-9);
  var inputRange = [
    current,
    next
  ], outputRange = [
    "".concat(current).concat(postfix),
    "".concat(next).concat(postfix)
  ];
  return next < current && (inputRange.reverse(), outputRange.reverse()), {
    inputRange,
    outputRange
  };
}
function getAnimationConfig(key, animations, animation) {
  if (typeof animation == "string")
    return animations[animation];
  var type = "", extraConf, shortKey = transformShorthands[key];
  if (Array.isArray(animation)) {
    var _animation_, _animation_1;
    type = animation[0];
    var _animation__key, conf = (_animation__key = (_animation_ = animation[1]) === null || _animation_ === void 0 ? void 0 : _animation_[key]) !== null && _animation__key !== void 0 ? _animation__key : (_animation_1 = animation[1]) === null || _animation_1 === void 0 ? void 0 : _animation_1[shortKey];
    conf && (typeof conf == "string" ? type = conf : (type = conf.type || type, extraConf = conf));
  } else {
    var _animation_key, val = (_animation_key = animation == null ? void 0 : animation[key]) !== null && _animation_key !== void 0 ? _animation_key : animation == null ? void 0 : animation[shortKey];
    type = val == null ? void 0 : val.type, extraConf = val;
  }
  var found = animations[type];
  return _object_spread({}, found, extraConf);
}
var transformShorthands = {
  x: "translateX",
  y: "translateY",
  translateX: "x",
  translateY: "y"
};
function getValue(input) {
  var isColor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (typeof input != "string")
    return [
      input
    ];
  var _input_match, _ref = _sliced_to_array((_input_match = input.match(/([-0-9]+)(deg|%|px)/)) !== null && _input_match !== void 0 ? _input_match : [], 3), _ = _ref[0], number = _ref[1], after = _ref[2];
  return [
    +number,
    after
  ];
}
export {
  AnimatedText,
  AnimatedView,
  createAnimations,
  useAnimatedNumber,
  useAnimatedNumberReaction,
  useAnimatedNumberStyle
};
//# sourceMappingURL=createAnimations.js.map
