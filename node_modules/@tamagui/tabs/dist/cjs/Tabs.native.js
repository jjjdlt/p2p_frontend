"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var Tabs_exports = {};
__export(Tabs_exports, {
  Tabs: () => Tabs,
  useTabsContext: () => useTabsContext
});
module.exports = __toCommonJS(Tabs_exports);
var import_jsx_runtime = require("react/jsx-runtime"), import_compose_refs = require("@tamagui/compose-refs"), import_constants = require("@tamagui/constants"), import_get_button_sized = require("@tamagui/get-button-sized"), import_group = require("@tamagui/group"), import_helpers = require("@tamagui/helpers"), import_roving_focus = require("@tamagui/roving-focus"), import_stacks = require("@tamagui/stacks"), import_use_controllable_state = require("@tamagui/use-controllable-state"), import_use_direction = require("@tamagui/use-direction"), import_web = require("@tamagui/web"), React = __toESM(require("react"));
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _object_without_properties(source, excluded) {
  if (source == null) return {};
  var target = _object_without_properties_loose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var TABS_CONTEXT = "TabsContext", TAB_LIST_NAME = "TabsList", TabsList = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var __scopeTabs = props.__scopeTabs, _props_loop = props.loop, loop = _props_loop === void 0 ? !0 : _props_loop, children = props.children, listProps = _object_without_properties(props, [
    "__scopeTabs",
    "loop",
    "children"
  ]), context = useTabsContext(__scopeTabs);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_roving_focus.RovingFocusGroup, {
    __scopeRovingFocusGroup: __scopeTabs || TABS_CONTEXT,
    orientation: context.orientation,
    dir: context.dir,
    loop,
    asChild: !0,
    children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_group.Group, _object_spread_props(_object_spread({
      role: "tablist",
      componentName: TAB_LIST_NAME,
      "aria-orientation": context.orientation,
      ref: forwardedRef,
      orientation: context.orientation
    }, listProps), {
      children
    }))
  });
});
TabsList.displayName = TAB_LIST_NAME;
var TRIGGER_NAME = "TabsTrigger", TabsTriggerFrame = (0, import_web.styled)(import_stacks.ThemeableStack, {
  name: TRIGGER_NAME,
  tag: "button",
  justifyContent: "center",
  alignItems: "center",
  flexWrap: "nowrap",
  flexDirection: "row",
  cursor: "pointer",
  userSelect: "none",
  variants: {
    size: {
      "...size": import_get_button_sized.getButtonSized
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    },
    active: {
      true: {
        hoverStyle: {
          backgroundColor: "$background"
        },
        focusStyle: {
          backgroundColor: "$background"
        }
      }
    },
    unstyled: {
      false: {
        backgroundColor: "$background",
        pressStyle: {
          backgroundColor: "$backgroundPress"
        },
        hoverStyle: {
          backgroundColor: "$backgroundHover"
        },
        focusStyle: {
          backgroundColor: "$backgroundFocus"
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), TabsTrigger = TabsTriggerFrame.styleable(function(props, forwardedRef) {
  var __scopeTabs = props.__scopeTabs, value = props.value, _props_disabled = props.disabled, disabled = _props_disabled === void 0 ? !1 : _props_disabled, onInteraction = props.onInteraction, disableActiveTheme = props.disableActiveTheme, triggerProps = _object_without_properties(props, [
    "__scopeTabs",
    "value",
    "disabled",
    "onInteraction",
    "disableActiveTheme"
  ]), context = useTabsContext(__scopeTabs), triggerId = makeTriggerId(context.baseId, value), contentId = makeContentId(context.baseId, value), isSelected = value === context.value, _React_useState = _sliced_to_array(React.useState(null), 2), layout = _React_useState[0], setLayout = _React_useState[1], triggerRef = React.useRef(null), groupItemProps = (0, import_group.useGroupItem)({
    disabled: !!disabled
  });
  React.useEffect(function() {
    return context.registerTrigger(), function() {
      return context.unregisterTrigger();
    };
  }, []), React.useEffect(function() {
    var getTriggerSize = function() {
      triggerRef.current && setLayout({
        width: triggerRef.current.offsetWidth,
        height: triggerRef.current.offsetHeight,
        x: triggerRef.current.offsetLeft,
        y: triggerRef.current.offsetTop
      });
    };
    if (!(!triggerRef.current || !import_constants.isWeb)) {
      getTriggerSize();
      var observer = new ResizeObserver(getTriggerSize);
      return observer.observe(triggerRef.current), function() {
        triggerRef.current && observer.unobserve(triggerRef.current);
      };
    }
  }, [
    context.triggersCount
  ]), React.useEffect(function() {
    isSelected && layout && (onInteraction == null || onInteraction("select", layout));
  }, [
    isSelected,
    value,
    layout
  ]);
  var _props_onPress;
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_web.Theme, {
    name: isSelected && !disableActiveTheme ? "active" : null,
    children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_roving_focus.RovingFocusGroup.Item, {
      __scopeRovingFocusGroup: __scopeTabs || TABS_CONTEXT,
      asChild: !0,
      focusable: !disabled,
      active: isSelected,
      children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TabsTriggerFrame, _object_spread(_object_spread_props(_object_spread({
        onLayout: function(event) {
          import_constants.isWeb || setLayout(event.nativeEvent.layout);
        },
        onHoverIn: (0, import_helpers.composeEventHandlers)(props.onHoverIn, function() {
          layout && (onInteraction == null || onInteraction("hover", layout));
        }),
        onHoverOut: (0, import_helpers.composeEventHandlers)(props.onHoverOut, function() {
          onInteraction == null || onInteraction("hover", null);
        }),
        role: "tab",
        "aria-selected": isSelected,
        "aria-controls": contentId,
        "data-state": isSelected ? "active" : "inactive",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        id: triggerId
      }, !props.unstyled && {
        size: context.size
      }, groupItemProps, triggerProps), {
        ref: (0, import_compose_refs.composeRefs)(forwardedRef, triggerRef),
        onPress: (0, import_helpers.composeEventHandlers)((_props_onPress = props.onPress) !== null && _props_onPress !== void 0 ? _props_onPress : void 0, function(event) {
          var webChecks = !import_constants.isWeb || event.button === 0 && event.ctrlKey === !1;
          !disabled && !isSelected && webChecks ? context.onChange(value) : event.preventDefault();
        })
      }), import_constants.isWeb && {
        type: "button",
        onKeyDown: (0, import_helpers.composeEventHandlers)(props.onKeyDown, function(event) {
          [
            " ",
            "Enter"
          ].includes(event.key) && (context.onChange(value), event.preventDefault());
        }),
        onFocus: (0, import_helpers.composeEventHandlers)(props.onFocus, function(event) {
          layout && (onInteraction == null || onInteraction("focus", layout));
          var isAutomaticActivation = context.activationMode !== "manual";
          !isSelected && !disabled && isAutomaticActivation && context.onChange(value);
        }),
        onBlur: (0, import_helpers.composeEventHandlers)(props.onFocus, function() {
          onInteraction == null || onInteraction("focus", null);
        })
      }))
    })
  });
});
TabsTrigger.displayName = TRIGGER_NAME;
var CONTENT_NAME = "TabsContent", TabsContentFrame = (0, import_web.styled)(import_stacks.ThemeableStack, {
  name: CONTENT_NAME
}), TabsContent = TabsContentFrame.styleable(function(props, forwardedRef) {
  var __scopeTabs = props.__scopeTabs, value = props.value, forceMount = props.forceMount, children = props.children, contentProps = _object_without_properties(props, [
    "__scopeTabs",
    "value",
    "forceMount",
    "children"
  ]), context = useTabsContext(__scopeTabs), isSelected = value === context.value, show = forceMount || isSelected, triggerId = makeTriggerId(context.baseId, value), contentId = makeContentId(context.baseId, value);
  return show ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TabsContentFrame, _object_spread_props(_object_spread({
    "data-state": isSelected ? "active" : "inactive",
    "data-orientation": context.orientation,
    role: "tabpanel",
    "aria-labelledby": triggerId,
    // @ts-ignore
    hidden: !show,
    id: contentId,
    tabIndex: 0
  }, contentProps), {
    ref: forwardedRef,
    children
  }), value) : null;
}), TABS_NAME = "Tabs", _createStyledContext = (0, import_web.createStyledContext)(), TabsProvider = _createStyledContext.Provider, useTabsContext = _createStyledContext.useStyledContext, TabsFrame = (0, import_web.styled)(import_stacks.SizableStack, {
  name: TABS_NAME
}), TabsComponent = TabsFrame.styleable(function(props, forwardedRef) {
  var __scopeTabs = props.__scopeTabs, valueProp = props.value, onValueChange = props.onValueChange, defaultValue = props.defaultValue, _props_orientation = props.orientation, orientation = _props_orientation === void 0 ? "horizontal" : _props_orientation, dir = props.dir, _props_activationMode = props.activationMode, activationMode = _props_activationMode === void 0 ? "automatic" : _props_activationMode, _props_size = props.size, size = _props_size === void 0 ? "$true" : _props_size, tabsProps = _object_without_properties(props, [
    "__scopeTabs",
    "value",
    "onValueChange",
    "defaultValue",
    "orientation",
    "dir",
    "activationMode",
    "size"
  ]), direction = (0, import_use_direction.useDirection)(dir), _useControllableState = _sliced_to_array((0, import_use_controllable_state.useControllableState)({
    prop: valueProp,
    onChange: onValueChange,
    defaultProp: defaultValue ?? ""
  }), 2), value = _useControllableState[0], setValue = _useControllableState[1], _React_useState = _sliced_to_array(React.useState(0), 2), triggersCount = _React_useState[0], setTriggersCount = _React_useState[1], registerTrigger = (0, import_web.useEvent)(function() {
    return setTriggersCount(function(v) {
      return v + 1;
    });
  }), unregisterTrigger = (0, import_web.useEvent)(function() {
    return setTriggersCount(function(v) {
      return v - 1;
    });
  });
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TabsProvider, {
    scope: __scopeTabs,
    baseId: React.useId(),
    value,
    onChange: setValue,
    orientation,
    dir: direction,
    activationMode,
    size,
    registerTrigger,
    triggersCount,
    unregisterTrigger,
    children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(TabsFrame, _object_spread_props(_object_spread({
      direction,
      //   dir={direction}
      "data-orientation": orientation
    }, tabsProps), {
      ref: forwardedRef
    }))
  });
}), Tabs = (0, import_helpers.withStaticProperties)(TabsComponent, {
  List: TabsList,
  /**
  * @deprecated Use Tabs.Tab instead
  */
  Trigger: TabsTrigger,
  Tab: TabsTrigger,
  Content: TabsContent
});
Tabs.displayName = TABS_NAME;
function makeTriggerId(baseId, value) {
  return "".concat(baseId, "-trigger-").concat(value);
}
function makeContentId(baseId, value) {
  return "".concat(baseId, "-content-").concat(value);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Tabs,
  useTabsContext
});
//# sourceMappingURL=Tabs.js.map
