import { jsx as _jsx } from "react/jsx-runtime";
import { composeRefs } from "@tamagui/compose-refs";
import { isWeb } from "@tamagui/constants";
import { getButtonSized } from "@tamagui/get-button-sized";
import { Group, useGroupItem } from "@tamagui/group";
import { composeEventHandlers, withStaticProperties } from "@tamagui/helpers";
import { RovingFocusGroup } from "@tamagui/roving-focus";
import { SizableStack, ThemeableStack } from "@tamagui/stacks";
import { useControllableState } from "@tamagui/use-controllable-state";
import { useDirection } from "@tamagui/use-direction";
import { Theme, createStyledContext, styled, useEvent } from "@tamagui/web";
import * as React from "react";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _object_without_properties(source, excluded) {
  if (source == null) return {};
  var target = _object_without_properties_loose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var TABS_CONTEXT = "TabsContext", TAB_LIST_NAME = "TabsList", TabsList = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var __scopeTabs = props.__scopeTabs, _props_loop = props.loop, loop = _props_loop === void 0 ? !0 : _props_loop, children = props.children, listProps = _object_without_properties(props, [
    "__scopeTabs",
    "loop",
    "children"
  ]), context = useTabsContext(__scopeTabs);
  return /* @__PURE__ */ _jsx(RovingFocusGroup, {
    __scopeRovingFocusGroup: __scopeTabs || TABS_CONTEXT,
    orientation: context.orientation,
    dir: context.dir,
    loop,
    asChild: !0,
    children: /* @__PURE__ */ _jsx(Group, _object_spread_props(_object_spread({
      role: "tablist",
      componentName: TAB_LIST_NAME,
      "aria-orientation": context.orientation,
      ref: forwardedRef,
      orientation: context.orientation
    }, listProps), {
      children
    }))
  });
});
TabsList.displayName = TAB_LIST_NAME;
var TRIGGER_NAME = "TabsTrigger", TabsTriggerFrame = styled(ThemeableStack, {
  name: TRIGGER_NAME,
  tag: "button",
  justifyContent: "center",
  alignItems: "center",
  flexWrap: "nowrap",
  flexDirection: "row",
  cursor: "pointer",
  userSelect: "none",
  variants: {
    size: {
      "...size": getButtonSized
    },
    disabled: {
      true: {
        pointerEvents: "none"
      }
    },
    active: {
      true: {
        hoverStyle: {
          backgroundColor: "$background"
        },
        focusStyle: {
          backgroundColor: "$background"
        }
      }
    },
    unstyled: {
      false: {
        backgroundColor: "$background",
        pressStyle: {
          backgroundColor: "$backgroundPress"
        },
        hoverStyle: {
          backgroundColor: "$backgroundHover"
        },
        focusStyle: {
          backgroundColor: "$backgroundFocus"
        }
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), TabsTrigger = TabsTriggerFrame.styleable(function(props, forwardedRef) {
  var __scopeTabs = props.__scopeTabs, value = props.value, _props_disabled = props.disabled, disabled = _props_disabled === void 0 ? !1 : _props_disabled, onInteraction = props.onInteraction, disableActiveTheme = props.disableActiveTheme, triggerProps = _object_without_properties(props, [
    "__scopeTabs",
    "value",
    "disabled",
    "onInteraction",
    "disableActiveTheme"
  ]), context = useTabsContext(__scopeTabs), triggerId = makeTriggerId(context.baseId, value), contentId = makeContentId(context.baseId, value), isSelected = value === context.value, _React_useState = _sliced_to_array(React.useState(null), 2), layout = _React_useState[0], setLayout = _React_useState[1], triggerRef = React.useRef(null), groupItemProps = useGroupItem({
    disabled: !!disabled
  });
  React.useEffect(function() {
    return context.registerTrigger(), function() {
      return context.unregisterTrigger();
    };
  }, []), React.useEffect(function() {
    var getTriggerSize = function() {
      triggerRef.current && setLayout({
        width: triggerRef.current.offsetWidth,
        height: triggerRef.current.offsetHeight,
        x: triggerRef.current.offsetLeft,
        y: triggerRef.current.offsetTop
      });
    };
    if (!(!triggerRef.current || !isWeb)) {
      getTriggerSize();
      var observer = new ResizeObserver(getTriggerSize);
      return observer.observe(triggerRef.current), function() {
        triggerRef.current && observer.unobserve(triggerRef.current);
      };
    }
  }, [
    context.triggersCount
  ]), React.useEffect(function() {
    isSelected && layout && (onInteraction == null || onInteraction("select", layout));
  }, [
    isSelected,
    value,
    layout
  ]);
  var _props_onPress;
  return /* @__PURE__ */ _jsx(Theme, {
    name: isSelected && !disableActiveTheme ? "active" : null,
    children: /* @__PURE__ */ _jsx(RovingFocusGroup.Item, {
      __scopeRovingFocusGroup: __scopeTabs || TABS_CONTEXT,
      asChild: !0,
      focusable: !disabled,
      active: isSelected,
      children: /* @__PURE__ */ _jsx(TabsTriggerFrame, _object_spread(_object_spread_props(_object_spread({
        onLayout: function(event) {
          isWeb || setLayout(event.nativeEvent.layout);
        },
        onHoverIn: composeEventHandlers(props.onHoverIn, function() {
          layout && (onInteraction == null || onInteraction("hover", layout));
        }),
        onHoverOut: composeEventHandlers(props.onHoverOut, function() {
          onInteraction == null || onInteraction("hover", null);
        }),
        role: "tab",
        "aria-selected": isSelected,
        "aria-controls": contentId,
        "data-state": isSelected ? "active" : "inactive",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        id: triggerId
      }, !props.unstyled && {
        size: context.size
      }, groupItemProps, triggerProps), {
        ref: composeRefs(forwardedRef, triggerRef),
        onPress: composeEventHandlers((_props_onPress = props.onPress) !== null && _props_onPress !== void 0 ? _props_onPress : void 0, function(event) {
          var webChecks = !isWeb || event.button === 0 && event.ctrlKey === !1;
          !disabled && !isSelected && webChecks ? context.onChange(value) : event.preventDefault();
        })
      }), isWeb && {
        type: "button",
        onKeyDown: composeEventHandlers(props.onKeyDown, function(event) {
          [
            " ",
            "Enter"
          ].includes(event.key) && (context.onChange(value), event.preventDefault());
        }),
        onFocus: composeEventHandlers(props.onFocus, function(event) {
          layout && (onInteraction == null || onInteraction("focus", layout));
          var isAutomaticActivation = context.activationMode !== "manual";
          !isSelected && !disabled && isAutomaticActivation && context.onChange(value);
        }),
        onBlur: composeEventHandlers(props.onFocus, function() {
          onInteraction == null || onInteraction("focus", null);
        })
      }))
    })
  });
});
TabsTrigger.displayName = TRIGGER_NAME;
var CONTENT_NAME = "TabsContent", TabsContentFrame = styled(ThemeableStack, {
  name: CONTENT_NAME
}), TabsContent = TabsContentFrame.styleable(function(props, forwardedRef) {
  var __scopeTabs = props.__scopeTabs, value = props.value, forceMount = props.forceMount, children = props.children, contentProps = _object_without_properties(props, [
    "__scopeTabs",
    "value",
    "forceMount",
    "children"
  ]), context = useTabsContext(__scopeTabs), isSelected = value === context.value, show = forceMount || isSelected, triggerId = makeTriggerId(context.baseId, value), contentId = makeContentId(context.baseId, value);
  return show ? /* @__PURE__ */ _jsx(TabsContentFrame, _object_spread_props(_object_spread({
    "data-state": isSelected ? "active" : "inactive",
    "data-orientation": context.orientation,
    role: "tabpanel",
    "aria-labelledby": triggerId,
    // @ts-ignore
    hidden: !show,
    id: contentId,
    tabIndex: 0
  }, contentProps), {
    ref: forwardedRef,
    children
  }), value) : null;
}), TABS_NAME = "Tabs", _createStyledContext = createStyledContext(), TabsProvider = _createStyledContext.Provider, useTabsContext = _createStyledContext.useStyledContext, TabsFrame = styled(SizableStack, {
  name: TABS_NAME
}), TabsComponent = TabsFrame.styleable(function(props, forwardedRef) {
  var __scopeTabs = props.__scopeTabs, valueProp = props.value, onValueChange = props.onValueChange, defaultValue = props.defaultValue, _props_orientation = props.orientation, orientation = _props_orientation === void 0 ? "horizontal" : _props_orientation, dir = props.dir, _props_activationMode = props.activationMode, activationMode = _props_activationMode === void 0 ? "automatic" : _props_activationMode, _props_size = props.size, size = _props_size === void 0 ? "$true" : _props_size, tabsProps = _object_without_properties(props, [
    "__scopeTabs",
    "value",
    "onValueChange",
    "defaultValue",
    "orientation",
    "dir",
    "activationMode",
    "size"
  ]), direction = useDirection(dir), _useControllableState = _sliced_to_array(useControllableState({
    prop: valueProp,
    onChange: onValueChange,
    defaultProp: defaultValue ?? ""
  }), 2), value = _useControllableState[0], setValue = _useControllableState[1], _React_useState = _sliced_to_array(React.useState(0), 2), triggersCount = _React_useState[0], setTriggersCount = _React_useState[1], registerTrigger = useEvent(function() {
    return setTriggersCount(function(v) {
      return v + 1;
    });
  }), unregisterTrigger = useEvent(function() {
    return setTriggersCount(function(v) {
      return v - 1;
    });
  });
  return /* @__PURE__ */ _jsx(TabsProvider, {
    scope: __scopeTabs,
    baseId: React.useId(),
    value,
    onChange: setValue,
    orientation,
    dir: direction,
    activationMode,
    size,
    registerTrigger,
    triggersCount,
    unregisterTrigger,
    children: /* @__PURE__ */ _jsx(TabsFrame, _object_spread_props(_object_spread({
      direction,
      //   dir={direction}
      "data-orientation": orientation
    }, tabsProps), {
      ref: forwardedRef
    }))
  });
}), Tabs = withStaticProperties(TabsComponent, {
  List: TabsList,
  /**
  * @deprecated Use Tabs.Tab instead
  */
  Trigger: TabsTrigger,
  Tab: TabsTrigger,
  Content: TabsContent
});
Tabs.displayName = TABS_NAME;
function makeTriggerId(baseId, value) {
  return "".concat(baseId, "-trigger-").concat(value);
}
function makeContentId(baseId, value) {
  return "".concat(baseId, "-content-").concat(value);
}
export {
  Tabs,
  useTabsContext
};
//# sourceMappingURL=Tabs.js.map
