var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var src_exports = {};
__export(src_exports, {
  default: () => FullySpecified
});
module.exports = __toCommonJS(src_exports);
var import_node_fs = require("node:fs"), import_node_path = require("node:path"), import_types = require("@babel/types");
const makeDeclaration = ({
  declaration,
  makeNodes,
  ensureFileExists = !1,
  esExtensionDefault = ".js",
  // List of all extensions which we try to find
  tryExtensions = [".js", ".mjs", ".cjs"],
  // List of extensions that can run in Node.js or in the Browser
  esExtensions = [".js", ".mjs", ".cjs"],
  // List of packages that also should be transformed with this plugin
  includePackages = []
}) => (path, {
  file: {
    opts: { filename }
  }
}) => {
  const { source } = path.node;
  if (!source || !filename)
    return;
  const { exportKind, importKind } = path.node;
  if (exportKind === "type" || importKind === "type")
    return;
  const { value } = source, module2 = value;
  let packageData = null;
  if (!isLocalFile(module2) && (includePackages.some((name) => module2.startsWith(name)) && (packageData = getPackageData(module2)), !(packageData && packageData.hasPath)))
    return;
  const filenameExtension = (0, import_node_path.extname)(filename), filenameDirectory = (0, import_node_path.dirname)(filename), isDirectory = isLocalDirectory((0, import_node_path.resolve)(filenameDirectory, module2)), currentModuleExtension = (0, import_node_path.extname)(module2), targetModule = evaluateTargetModule({
    module: module2,
    filenameDirectory,
    filenameExtension,
    packageData,
    currentModuleExtension,
    isDirectory,
    tryExtensions,
    esExtensions,
    esExtensionDefault,
    ensureFileExists
  });
  if (targetModule === !1 || currentModuleExtension === targetModule.extension)
    return;
  const nodes = makeNodes(path);
  path.replaceWith(
    // @ts-ignore
    declaration.apply(null, [...nodes, (0, import_types.stringLiteral)(targetModule.module)])
  );
};
function FullySpecified(api, options) {
  return api.assertVersion(7), {
    name: "babel-plugin-fully-specified",
    visitor: {
      ImportDeclaration: makeDeclaration({
        ...options,
        declaration: import_types.importDeclaration,
        makeNodes: ({ node: { specifiers } }) => [specifiers]
      }),
      ExportNamedDeclaration: makeDeclaration({
        ...options,
        declaration: import_types.exportNamedDeclaration,
        makeNodes: ({ node: { declaration, specifiers } }) => [declaration, specifiers]
      }),
      ExportAllDeclaration: makeDeclaration({
        ...options,
        declaration: import_types.exportAllDeclaration,
        makeNodes: () => []
      })
    }
  };
}
function getPackageData(module2) {
  try {
    const packagePath = require.resolve(module2), parts = packagePath.split("/");
    let packageDir = "";
    for (let i = parts.length; i >= 0; i--) {
      const dir = (0, import_node_path.dirname)(parts.slice(0, i).join("/"));
      if ((0, import_node_fs.existsSync)(`${dir}/package.json`)) {
        packageDir = dir;
        break;
      }
    }
    if (!packageDir)
      throw new Error("no package dir");
    const packageJson = JSON.parse((0, import_node_fs.readFileSync)(`${packageDir}/package.json`).toString());
    return { hasPath: !module2.endsWith(packageJson.name), packagePath };
  } catch {
  }
  return null;
}
function isLocalFile(module2) {
  return module2.startsWith(".") || module2.startsWith("/");
}
function isLocalDirectory(absoluteDirectory) {
  return (0, import_node_fs.existsSync)(absoluteDirectory) && (0, import_node_fs.lstatSync)(absoluteDirectory).isDirectory();
}
function evaluateTargetModule({
  module: module2,
  currentModuleExtension,
  packageData,
  isDirectory,
  filenameDirectory,
  filenameExtension,
  tryExtensions,
  esExtensions,
  esExtensionDefault,
  ensureFileExists
}) {
  if (packageData)
    return packageData.packagePath.endsWith("index.js") && !module2.endsWith("index.js") && (module2 = `${module2}/index`), {
      module: module2 + esExtensionDefault,
      extension: esExtensionDefault
    };
  if (currentModuleExtension && !esExtensions.includes(currentModuleExtension))
    return !1;
  isDirectory && !(0, import_node_fs.existsSync)(
    (0, import_node_path.resolve)(
      filenameDirectory,
      currentModuleExtension ? module2 : module2 + esExtensionDefault
    )
  ) && (module2 = `${module2}/index`);
  const targetFile = (0, import_node_path.resolve)(filenameDirectory, module2);
  if (ensureFileExists) {
    if (esExtensions.includes(filenameExtension) && (0, import_node_fs.existsSync)(targetFile + filenameExtension))
      return {
        module: module2 + filenameExtension,
        extension: filenameExtension
      };
    for (const extension of tryExtensions)
      if ((0, import_node_fs.existsSync)(targetFile + extension))
        return { module: module2 + ".mjs", extension };
  } else return esExtensions.includes(filenameExtension) ? {
    module: module2 + filenameExtension,
    extension: filenameExtension
  } : {
    module: module2 + esExtensionDefault,
    extension: esExtensionDefault
  };
  return !1;
}
//# sourceMappingURL=index.js.map
