import { existsSync, readFileSync, lstatSync } from "node:fs";
import { resolve, extname, dirname } from "node:path";
import {
  importDeclaration,
  exportNamedDeclaration,
  exportAllDeclaration,
  stringLiteral
} from "@babel/types";
const makeDeclaration = ({
  declaration,
  makeNodes,
  ensureFileExists = !1,
  esExtensionDefault = ".js",
  // List of all extensions which we try to find
  tryExtensions = [".js", ".mjs", ".cjs"],
  // List of extensions that can run in Node.js or in the Browser
  esExtensions = [".js", ".mjs", ".cjs"],
  // List of packages that also should be transformed with this plugin
  includePackages = []
}) => (path, {
  file: {
    opts: { filename }
  }
}) => {
  const { source } = path.node;
  if (!source || !filename)
    return;
  const { exportKind, importKind } = path.node;
  if (exportKind === "type" || importKind === "type")
    return;
  const { value } = source, module = value;
  let packageData = null;
  if (!isLocalFile(module) && (includePackages.some((name) => module.startsWith(name)) && (packageData = getPackageData(module)), !(packageData && packageData.hasPath)))
    return;
  const filenameExtension = extname(filename), filenameDirectory = dirname(filename), isDirectory = isLocalDirectory(resolve(filenameDirectory, module)), currentModuleExtension = extname(module), targetModule = evaluateTargetModule({
    module,
    filenameDirectory,
    filenameExtension,
    packageData,
    currentModuleExtension,
    isDirectory,
    tryExtensions,
    esExtensions,
    esExtensionDefault,
    ensureFileExists
  });
  if (targetModule === !1 || currentModuleExtension === targetModule.extension)
    return;
  const nodes = makeNodes(path);
  path.replaceWith(
    // @ts-ignore
    declaration.apply(null, [...nodes, stringLiteral(targetModule.module)])
  );
};
function FullySpecified(api, options) {
  return api.assertVersion(7), {
    name: "babel-plugin-fully-specified",
    visitor: {
      ImportDeclaration: makeDeclaration({
        ...options,
        declaration: importDeclaration,
        makeNodes: ({ node: { specifiers } }) => [specifiers]
      }),
      ExportNamedDeclaration: makeDeclaration({
        ...options,
        declaration: exportNamedDeclaration,
        makeNodes: ({ node: { declaration, specifiers } }) => [declaration, specifiers]
      }),
      ExportAllDeclaration: makeDeclaration({
        ...options,
        declaration: exportAllDeclaration,
        makeNodes: () => []
      })
    }
  };
}
function getPackageData(module) {
  try {
    const packagePath = require.resolve(module), parts = packagePath.split("/");
    let packageDir = "";
    for (let i = parts.length; i >= 0; i--) {
      const dir = dirname(parts.slice(0, i).join("/"));
      if (existsSync(`${dir}/package.json`)) {
        packageDir = dir;
        break;
      }
    }
    if (!packageDir)
      throw new Error("no package dir");
    const packageJson = JSON.parse(readFileSync(`${packageDir}/package.json`).toString());
    return { hasPath: !module.endsWith(packageJson.name), packagePath };
  } catch {
  }
  return null;
}
function isLocalFile(module) {
  return module.startsWith(".") || module.startsWith("/");
}
function isLocalDirectory(absoluteDirectory) {
  return existsSync(absoluteDirectory) && lstatSync(absoluteDirectory).isDirectory();
}
function evaluateTargetModule({
  module,
  currentModuleExtension,
  packageData,
  isDirectory,
  filenameDirectory,
  filenameExtension,
  tryExtensions,
  esExtensions,
  esExtensionDefault,
  ensureFileExists
}) {
  if (packageData)
    return packageData.packagePath.endsWith("index.js") && !module.endsWith("index.js") && (module = `${module}/index`), {
      module: module + esExtensionDefault,
      extension: esExtensionDefault
    };
  if (currentModuleExtension && !esExtensions.includes(currentModuleExtension))
    return !1;
  isDirectory && !existsSync(
    resolve(
      filenameDirectory,
      currentModuleExtension ? module : module + esExtensionDefault
    )
  ) && (module = `${module}/index`);
  const targetFile = resolve(filenameDirectory, module);
  if (ensureFileExists) {
    if (esExtensions.includes(filenameExtension) && existsSync(targetFile + filenameExtension))
      return {
        module: module + filenameExtension,
        extension: filenameExtension
      };
    for (const extension of tryExtensions)
      if (existsSync(targetFile + extension))
        return { module: module + ".mjs", extension };
  } else return esExtensions.includes(filenameExtension) ? {
    module: module + filenameExtension,
    extension: filenameExtension
  } : {
    module: module + esExtensionDefault,
    extension: esExtensionDefault
  };
  return !1;
}
export {
  FullySpecified as default
};
//# sourceMappingURL=index.js.map
