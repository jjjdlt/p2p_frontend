import { existsSync, readFileSync, lstatSync } from "node:fs";
import { resolve, extname, dirname } from "node:path";
import { importDeclaration, exportNamedDeclaration, exportAllDeclaration, stringLiteral } from "@babel/types";
const makeDeclaration = ({
  declaration,
  makeNodes,
  ensureFileExists = !1,
  esExtensionDefault = ".js",
  // List of all extensions which we try to find
  tryExtensions = [".js", ".mjs", ".cjs"],
  // List of extensions that can run in Node.js or in the Browser
  esExtensions = [".js", ".mjs", ".cjs"],
  // List of packages that also should be transformed with this plugin
  includePackages = []
}) => (path, {
  file: {
    opts: {
      filename
    }
  }
}) => {
  const {
    source
  } = path.node;
  if (!source || !filename) return;
  const {
    exportKind,
    importKind
  } = path.node;
  if (exportKind === "type" || importKind === "type") return;
  const {
      value
    } = source,
    module = value;
  let packageData = null;
  if (!isLocalFile(module) && (includePackages.some(name => module.startsWith(name)) && (packageData = getPackageData(module)), !(packageData && packageData.hasPath))) return;
  const filenameExtension = extname(filename),
    filenameDirectory = dirname(filename),
    isDirectory = isLocalDirectory(resolve(filenameDirectory, module)),
    currentModuleExtension = extname(module),
    targetModule = evaluateTargetModule({
      module,
      filenameDirectory,
      filenameExtension,
      packageData,
      currentModuleExtension,
      isDirectory,
      tryExtensions,
      esExtensions,
      esExtensionDefault,
      ensureFileExists
    });
  if (targetModule === !1 || currentModuleExtension === targetModule.extension) return;
  const nodes = makeNodes(path);
  path.replaceWith(
  // @ts-ignore
  declaration.apply(null, [...nodes, stringLiteral(targetModule.module)]));
};
function FullySpecified(api, options) {
  return api.assertVersion(7), {
    name: "babel-plugin-fully-specified",
    visitor: {
      ImportDeclaration: makeDeclaration({
        ...options,
        declaration: importDeclaration,
        makeNodes: ({
          node: {
            specifiers
          }
        }) => [specifiers]
      }),
      ExportNamedDeclaration: makeDeclaration({
        ...options,
        declaration: exportNamedDeclaration,
        makeNodes: ({
          node: {
            declaration,
            specifiers
          }
        }) => [declaration, specifiers]
      }),
      ExportAllDeclaration: makeDeclaration({
        ...options,
        declaration: exportAllDeclaration,
        makeNodes: () => []
      })
    }
  };
}
function getPackageData(module) {
  try {
    const packagePath = require.resolve(module),
      parts = packagePath.split("/");
    let packageDir = "";
    for (let i = parts.length; i >= 0; i--) {
      const dir = dirname(parts.slice(0, i).join("/"));
      if (existsSync(`${dir}/package.json`)) {
        packageDir = dir;
        break;
      }
    }
    if (!packageDir) throw new Error("no package dir");
    const packageJson = JSON.parse(readFileSync(`${packageDir}/package.json`).toString());
    return {
      hasPath: !module.endsWith(packageJson.name),
      packagePath
    };
  } catch {}
  return null;
}
function isLocalFile(module) {
  return module.startsWith(".") || module.startsWith("/");
}
function isLocalDirectory(absoluteDirectory) {
  return existsSync(absoluteDirectory) && lstatSync(absoluteDirectory).isDirectory();
}
function evaluateTargetModule({
  module,
  currentModuleExtension,
  packageData,
  isDirectory,
  filenameDirectory,
  filenameExtension,
  tryExtensions,
  esExtensions,
  esExtensionDefault,
  ensureFileExists
}) {
  if (packageData) return packageData.packagePath.endsWith("index.js") && !module.endsWith("index.js") && (module = `${module}/index`), {
    module: module + esExtensionDefault,
    extension: esExtensionDefault
  };
  if (currentModuleExtension && !esExtensions.includes(currentModuleExtension)) return !1;
  isDirectory && !existsSync(resolve(filenameDirectory, currentModuleExtension ? module : module + esExtensionDefault)) && (module = `${module}/index`);
  const targetFile = resolve(filenameDirectory, module);
  if (ensureFileExists) {
    if (esExtensions.includes(filenameExtension) && existsSync(targetFile + filenameExtension)) return {
      module: module + filenameExtension,
      extension: filenameExtension
    };
    for (const extension of tryExtensions) if (existsSync(targetFile + extension)) return {
      module: module + ".mjs",
      extension
    };
  } else return esExtensions.includes(filenameExtension) ? {
    module: module + filenameExtension,
    extension: filenameExtension
  } : {
    module: module + esExtensionDefault,
    extension: esExtensionDefault
  };
  return !1;
}
export { FullySpecified as default };