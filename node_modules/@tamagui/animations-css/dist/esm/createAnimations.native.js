import { useIsomorphicLayoutEffect } from "@tamagui/constants";
import { transformsToString } from "@tamagui/web";
import { ResetPresence, usePresence } from "@tamagui/use-presence";
import { useEffect, useState } from "react";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
function createAnimations(animations) {
  var reactionListeners = /* @__PURE__ */ new WeakMap();
  return {
    animations,
    usePresence,
    ResetPresence,
    supportsCSSVars: !0,
    useAnimatedNumber: function(initial) {
      var _useState = _sliced_to_array(useState(initial), 2), val = _useState[0], setVal = _useState[1];
      return {
        getInstance: function() {
          return setVal;
        },
        getValue: function() {
          return val;
        },
        setValue: function(next, config, onFinish) {
          setVal(next);
          var listeners = reactionListeners.get(setVal);
          listeners && listeners.forEach(function(cb) {
            return cb(next);
          }), onFinish == null || onFinish();
        },
        stop: function() {
        }
      };
    },
    useAnimatedNumberReaction: function(param, onValue) {
      var value = param.value;
      useEffect(function() {
        var instance = value.getInstance(), queue = reactionListeners.get(instance);
        if (!queue) {
          var next = /* @__PURE__ */ new Set();
          reactionListeners.set(instance, next), queue = next;
        }
        return queue.add(onValue), function() {
          queue == null || queue.delete(onValue);
        };
      }, []);
    },
    useAnimatedNumberStyle: function(val, getStyle) {
      return getStyle(val.getValue());
    },
    useAnimations: function(param) {
      var props = param.props, presence = param.presence, style = param.style, componentState = param.componentState, stateRef = param.stateRef, isEntering = !!componentState.unmounted, isExiting = (presence == null ? void 0 : presence[0]) === !1, sendExitComplete = presence == null ? void 0 : presence[1], _concat = _sliced_to_array([].concat(props.animation), 2), animationKey = _concat[0], animationConfig = _concat[1], animation = animations[animationKey], _props_animateOnly, keys = (_props_animateOnly = props.animateOnly) !== null && _props_animateOnly !== void 0 ? _props_animateOnly : [
        "all"
      ];
      return useIsomorphicLayoutEffect(function() {
        var host = stateRef.current.host;
        if (!(!sendExitComplete || !isExiting || !host)) {
          var node = host, onFinishAnimation = function() {
            sendExitComplete == null || sendExitComplete();
          };
          return node.addEventListener("transitionend", onFinishAnimation), node.addEventListener("transitioncancel", onFinishAnimation), function() {
            node.removeEventListener("transitionend", onFinishAnimation), node.removeEventListener("transitioncancel", onFinishAnimation);
          };
        }
      }, [
        sendExitComplete,
        isExiting
      ]), animation ? (Array.isArray(style.transform) && (style.transform = transformsToString(style.transform)), style.transition = keys.map(function(key) {
        var _animations_animationConfig_key, override = (_animations_animationConfig_key = animations[animationConfig == null ? void 0 : animationConfig[key]]) !== null && _animations_animationConfig_key !== void 0 ? _animations_animationConfig_key : animation;
        return "".concat(key, " ").concat(override);
      }).join(", "), process.env.NODE_ENV === "development" && props.debug && console.info("CSS animation", style, style.transition, {
        isEntering,
        isExiting
      }), {
        style
      }) : null;
    }
  };
}
export {
  createAnimations
};
//# sourceMappingURL=createAnimations.js.map
