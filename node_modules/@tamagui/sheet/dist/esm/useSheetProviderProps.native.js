import { useConfiguration } from "@tamagui/core";
import { useConstant } from "@tamagui/use-constant";
import { useControllableState } from "@tamagui/use-controllable-state";
import React, { useCallback, useEffect, useMemo, useState } from "react";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
function useSheetProviderProps(props, state) {
  var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, handleRef = React.useRef(null), contentRef = React.useRef(null), _useState = _sliced_to_array(useState(0), 2), frameSize = _useState[0], setFrameSize = _useState[1], _useState1 = _sliced_to_array(useState(0), 2), maxContentSize = _useState1[0], setMaxContentSize = _useState1[1], _props_snapPointsMode, snapPointsMode = (_props_snapPointsMode = props.snapPointsMode) !== null && _props_snapPointsMode !== void 0 ? _props_snapPointsMode : "percent", _props_snapPoints, snapPointsProp = (_props_snapPoints = props.snapPoints) !== null && _props_snapPoints !== void 0 ? _props_snapPoints : snapPointsMode === "percent" ? [
    80
  ] : snapPointsMode === "constant" ? [
    256
  ] : [
    "fit"
  ], hasFit = snapPointsProp[0] === "fit", snapPoints = useMemo(function() {
    return props.dismissOnSnapToBottom ? _to_consumable_array(snapPointsProp).concat([
      0
    ]) : snapPointsProp;
  }, [
    JSON.stringify(snapPointsProp),
    props.dismissOnSnapToBottom
  ]), _useControllableState = _sliced_to_array(useControllableState({
    prop: props.position,
    defaultProp: props.defaultPosition || (state.open ? 0 : -1),
    onChange: props.onPositionChange,
    strategy: "most-recent-wins",
    transition: !0
  }), 2), position_ = _useControllableState[0], setPositionImmediate = _useControllableState[1], position = state.open === !1 ? -1 : position_, open = state.open, setPosition = useCallback(function(next) {
    props.dismissOnSnapToBottom && next === snapPoints.length - 1 ? state.setOpen(!1) : setPositionImmediate(next);
  }, [
    props.dismissOnSnapToBottom,
    snapPoints.length,
    setPositionImmediate,
    state.setOpen
  ]);
  process.env.NODE_ENV === "development" && (snapPointsMode === "mixed" && snapPoints.some(function(p) {
    if (typeof p == "string") {
      if (p === "fit")
        return !1;
      if (p.endsWith("%")) {
        var n = Number(p.slice(0, -1));
        return n < 0 || n > 100;
      }
      return !0;
    }
    return typeof p != "number" || p < 0;
  }) && console.warn('\u26A0\uFE0F Invalid snapPoint given, snapPoints must be positive numeric values, string percentages between 0-100%, or "fit" when snapPointsMode is mixed'), snapPointsMode === "mixed" && snapPoints.indexOf("fit") > 0 && console.warn('\u26A0\uFE0F Invalid snapPoint given, "fit" must be the first/largest snap point when snapPointsMode is mixed'), snapPointsMode === "fit" && (snapPoints.length !== (props.dismissOnSnapToBottom ? 2 : 1) || snapPoints[0] !== "fit") && console.warn("\u26A0\uFE0F Invalid snapPoint given, there are no snap points when snapPointsMode is fit"), snapPointsMode === "constant" && snapPoints.some(function(p) {
    return typeof p != "number" || p < 0;
  }) && console.warn("\u26A0\uFE0F Invalid snapPoint given, snapPoints must be positive numeric values when snapPointsMode is constant"), snapPointsMode === "percent" && snapPoints.some(function(p) {
    return typeof p != "number" || p < 0 || p > 100;
  }) && console.warn("\u26A0\uFE0F Invalid snapPoint given, snapPoints must be numeric values between 0 and 100 when snapPointsMode is percent")), open && props.dismissOnSnapToBottom && position === snapPoints.length - 1 && setPositionImmediate(0);
  var shouldSetPositionOpen = open && position < 0;
  useEffect(function() {
    shouldSetPositionOpen && setPosition(0);
  }, [
    setPosition,
    shouldSetPositionOpen
  ]);
  var animationDriver = useConfiguration().animationDriver;
  if (!animationDriver)
    throw new Error("Must set animations in tamagui.config.ts");
  var scrollBridge = useConstant(function() {
    return {
      enabled: !1,
      y: 0,
      paneY: 0,
      paneMinY: 0,
      scrollStartY: -1,
      drag: function() {
      },
      release: function() {
      },
      scrollLock: !1
    };
  }), _props_forceRemoveScrollEnabled, removeScrollEnabled = (_props_forceRemoveScrollEnabled = props.forceRemoveScrollEnabled) !== null && _props_forceRemoveScrollEnabled !== void 0 ? _props_forceRemoveScrollEnabled : open && props.modal, maxSnapPoint = snapPoints[0], screenSize = snapPointsMode === "percent" ? frameSize / ((typeof maxSnapPoint == "number" ? maxSnapPoint : 100) / 100) : maxContentSize, _props_dismissOnOverlayPress, _props_dismissOnSnapToBottom, providerProps = {
    screenSize,
    maxSnapPoint,
    removeScrollEnabled,
    scrollBridge,
    modal: !!props.modal,
    open: state.open,
    setOpen: state.setOpen,
    hidden: !!state.isHidden,
    contentRef,
    handleRef,
    frameSize,
    setFrameSize,
    dismissOnOverlayPress: (_props_dismissOnOverlayPress = props.dismissOnOverlayPress) !== null && _props_dismissOnOverlayPress !== void 0 ? _props_dismissOnOverlayPress : !0,
    dismissOnSnapToBottom: (_props_dismissOnSnapToBottom = props.dismissOnSnapToBottom) !== null && _props_dismissOnSnapToBottom !== void 0 ? _props_dismissOnSnapToBottom : !1,
    onOverlayComponent: options.onOverlayComponent,
    scope: props.__scopeSheet,
    hasFit,
    position,
    snapPoints,
    snapPointsMode,
    setMaxContentSize,
    setPosition,
    setPositionImmediate,
    onlyShowFrame: !1
  };
  return providerProps;
}
export {
  useSheetProviderProps
};
//# sourceMappingURL=useSheetProviderProps.js.map
