import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { AdaptParentContext } from "@tamagui/adapt";
import { AnimatePresence } from "@tamagui/animate-presence";
import { useComposedRefs } from "@tamagui/compose-refs";
import { isWeb, useIsomorphicLayoutEffect } from "@tamagui/constants";
import { getConfig, Stack, Theme, themeable, useConfiguration, useEvent, useThemeName } from "@tamagui/core";
import { Portal } from "@tamagui/portal";
import { useKeyboardVisible } from "@tamagui/use-keyboard-visible";
import { forwardRef, Fragment, useCallback, useContext, useEffect, useMemo, useRef, useState } from "react";
import { Dimensions, Keyboard, PanResponder, View } from "react-native";
import { SHEET_HIDDEN_STYLESHEET } from "./constants";
import { ParentSheetContext, SheetInsideSheetContext } from "./contexts";
import { resisted } from "./helpers";
import { SheetProvider } from "./SheetContext";
import { useSheetOpenState } from "./useSheetOpenState";
import { useSheetProviderProps } from "./useSheetProviderProps";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var hiddenSize = 10000.1, SheetImplementationCustom = themeable(/* @__PURE__ */ forwardRef(function(props, forwardedRef) {
  var parentSheet = useContext(ParentSheetContext), animation = props.animation, animationConfigProp = props.animationConfig, _props_modal = props.modal, modal = _props_modal === void 0 ? !1 : _props_modal, _props_zIndex = props.zIndex, zIndex = _props_zIndex === void 0 ? parentSheet.zIndex + 1 : _props_zIndex, _props_moveOnKeyboardChange = props.moveOnKeyboardChange, moveOnKeyboardChange = _props_moveOnKeyboardChange === void 0 ? !1 : _props_moveOnKeyboardChange, _props_unmountChildrenWhenHidden = props.unmountChildrenWhenHidden, unmountChildrenWhenHidden = _props_unmountChildrenWhenHidden === void 0 ? !1 : _props_unmountChildrenWhenHidden, portalProps = props.portalProps, tmp = props.containerComponent, ContainerComponent = tmp === void 0 ? Fragment : tmp, keyboardIsVisible = useKeyboardVisible(), state = useSheetOpenState(props), _useState = _sliced_to_array(useState(null), 2), overlayComponent = _useState[0], setOverlayComponent = _useState[1], providerProps = useSheetProviderProps(props, state, {
    onOverlayComponent: setOverlayComponent
  }), frameSize = providerProps.frameSize, setFrameSize = providerProps.setFrameSize, snapPoints = providerProps.snapPoints, snapPointsMode = providerProps.snapPointsMode, hasFit = providerProps.hasFit, position = providerProps.position, setPosition = providerProps.setPosition, scrollBridge = providerProps.scrollBridge, screenSize = providerProps.screenSize, setMaxContentSize = providerProps.setMaxContentSize, maxSnapPoint = providerProps.maxSnapPoint, open = state.open, controller = state.controller, isHidden = state.isHidden, sheetRef = useRef(null), ref = useComposedRefs(forwardedRef, sheetRef), animationConfig = function() {
    var _ref = _sliced_to_array(animation ? Array.isArray(animation) ? animation : [
      animation
    ] : [], 2), animationProp = _ref[0], animationPropConfig = _ref[1];
    return animationConfigProp ?? (animationProp ? _object_spread({}, getConfig().animations.animations[animationProp], animationPropConfig) : null);
  }(), _useState1 = _sliced_to_array(useState(!1), 2), isShowingInnerSheet = _useState1[0], setIsShowingInnerSheet = _useState1[1], shouldHideParentSheet = !isWeb && modal && isShowingInnerSheet, parentSheetContext = useContext(SheetInsideSheetContext), onInnerSheet = useCallback(function(hasChild) {
    setIsShowingInnerSheet(hasChild);
  }, []), positions = useMemo(function() {
    return snapPoints.map(function(point) {
      return getYPositions(snapPointsMode, point, screenSize, frameSize);
    });
  }, [
    screenSize,
    frameSize,
    snapPoints,
    snapPointsMode
  ]), animationDriver = useConfiguration().animationDriver, useAnimatedNumber = animationDriver.useAnimatedNumber, useAnimatedNumberStyle = animationDriver.useAnimatedNumberStyle, useAnimatedNumberReaction = animationDriver.useAnimatedNumberReaction, _animationDriver_View, AnimatedView = (_animationDriver_View = animationDriver.View) !== null && _animationDriver_View !== void 0 ? _animationDriver_View : Stack;
  useIsomorphicLayoutEffect(function() {
    if (parentSheetContext && open)
      return parentSheetContext(!0), function() {
        parentSheetContext(!1);
      };
  }, [
    parentSheetContext,
    open
  ]);
  var nextParentContext = useMemo(function() {
    return {
      zIndex
    };
  }, [
    zIndex
  ]), animatedNumber = useAnimatedNumber(hiddenSize), at = useRef(hiddenSize);
  useAnimatedNumberReaction({
    value: animatedNumber,
    hostRef: sheetRef
  }, useCallback(function(value) {
    at.current = value, scrollBridge.paneY = value;
  }, [
    animationDriver
  ]));
  function stopSpring() {
    animatedNumber.stop(), scrollBridge.onFinishAnimate && (scrollBridge.onFinishAnimate(), scrollBridge.onFinishAnimate = void 0);
  }
  var hasntMeasured = at.current === hiddenSize, animateTo = useEvent(function(position2) {
    if (frameSize !== 0) {
      var toValue = isHidden || position2 === -1 ? screenSize : positions[position2];
      if (at.current !== toValue) {
        if (at.current = toValue, stopSpring(), hasntMeasured || isHidden) {
          animatedNumber.setValue(screenSize, {
            type: "timing",
            duration: 0
          }, function() {
            isHidden || (toValue = positions[position2], at.current = toValue, animatedNumber.setValue(toValue, _object_spread({
              type: "spring"
            }, animationConfig)));
          });
          return;
        }
        animatedNumber.setValue(toValue, _object_spread({
          type: "spring"
        }, animationConfig));
      }
    }
  });
  useIsomorphicLayoutEffect(function() {
    screenSize && hasntMeasured && animatedNumber.setValue(screenSize, {
      type: "timing",
      duration: 0
    });
  }, [
    hasntMeasured,
    screenSize
  ]), useIsomorphicLayoutEffect(function() {
    !frameSize || !screenSize || isHidden || hasntMeasured && !open || animateTo(position);
  }, [
    isHidden,
    frameSize,
    screenSize,
    open,
    position
  ]);
  var _props_disableDrag, disableDrag = (_props_disableDrag = props.disableDrag) !== null && _props_disableDrag !== void 0 ? _props_disableDrag : controller == null ? void 0 : controller.disableDrag, themeName = useThemeName(), _useState2 = _sliced_to_array(useState(!1), 2), isDragging = _useState2[0], setIsDragging = _useState2[1], panResponder = useMemo(function() {
    var setPanning = function(val) {
      setIsDragging(val), SHEET_HIDDEN_STYLESHEET && (val ? SHEET_HIDDEN_STYLESHEET.innerText = ":root * { user-select: none !important; -webkit-user-select: none !important; }" : SHEET_HIDDEN_STYLESHEET.innerText = "");
    };
    if (!disableDrag && frameSize && !isShowingInnerSheet) {
      var minY = positions[0];
      scrollBridge.paneMinY = minY;
      var startY = at.current, release = function(param) {
        var vy = param.vy, dragAt = param.dragAt;
        isExternalDrag = !1, previouslyScrolling = !1, setPanning(!1);
        for (var at2 = dragAt + startY, end = at2 + frameSize * vy * 0.2, closestPoint = 0, dist = Number.POSITIVE_INFINITY, i = 0; i < positions.length; i++) {
          var position2 = positions[i], curDist = end > position2 ? end - position2 : position2 - end;
          curDist < dist && (dist = curDist, closestPoint = i);
        }
        setPosition(closestPoint), animateTo(closestPoint);
      }, finish = function(_e, state2) {
        release({
          vy: state2.vy,
          dragAt: state2.dy
        });
      }, previouslyScrolling = !1, onMoveShouldSet = function(e, param) {
        var dy = param.dy;
        if (e.target === providerProps.handleRef.current)
          return !0;
        var isScrolled = scrollBridge.y !== 0, isDraggingUp = dy < 0, isNearTop = scrollBridge.paneY - 5 <= scrollBridge.paneMinY;
        return isScrolled ? (previouslyScrolling = !0, !1) : isNearTop && !isScrolled && isDraggingUp && !isWeb ? !1 : Math.abs(dy) > 5;
      }, grant = function() {
        setPanning(!0), stopSpring(), startY = at.current;
      }, isExternalDrag = !1;
      return scrollBridge.drag = function(dy) {
        isExternalDrag || (isExternalDrag = !0, grant());
        var to = dy + startY;
        animatedNumber.setValue(resisted(to, minY), {
          type: "direct"
        });
      }, scrollBridge.release = release, PanResponder.create({
        onMoveShouldSetPanResponder: onMoveShouldSet,
        onPanResponderGrant: grant,
        onPanResponderMove: function(_e, param) {
          var dy = param.dy, toFull = dy + startY, to = resisted(toFull, minY);
          animatedNumber.setValue(to, {
            type: "direct"
          });
        },
        onPanResponderEnd: finish,
        onPanResponderTerminate: finish,
        onPanResponderRelease: finish
      });
    }
  }, [
    disableDrag,
    isShowingInnerSheet,
    animateTo,
    frameSize,
    positions,
    setPosition
  ]), handleAnimationViewLayout = useCallback(function(e) {
    var _e_nativeEvent, next = Math.min((_e_nativeEvent = e.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, Dimensions.get("window").height);
    next && setFrameSize(next);
  }, [
    keyboardIsVisible
  ]), handleMaxContentViewLayout = useCallback(function(e) {
    var _e_nativeEvent, next = Math.min((_e_nativeEvent = e.nativeEvent) === null || _e_nativeEvent === void 0 ? void 0 : _e_nativeEvent.layout.height, Dimensions.get("window").height);
    next && setMaxContentSize(next);
  }, [
    keyboardIsVisible
  ]), animatedStyle = useAnimatedNumberStyle(animatedNumber, function(val) {
    "worklet";
    var translateY = frameSize === 0 ? hiddenSize : val;
    return {
      transform: [
        {
          translateY
        }
      ]
    };
  }), sizeBeforeKeyboard = useRef(null);
  useEffect(function() {
    if (!(isWeb || !moveOnKeyboardChange)) {
      var keyboardDidShowListener = Keyboard.addListener("keyboardDidShow", function(e) {
        sizeBeforeKeyboard.current === null && (sizeBeforeKeyboard.current = animatedNumber.getValue(), animatedNumber.setValue(Math.max(animatedNumber.getValue() - e.endCoordinates.height, 0)));
      }), keyboardDidHideListener = Keyboard.addListener("keyboardDidHide", function() {
        sizeBeforeKeyboard.current !== null && (animatedNumber.setValue(sizeBeforeKeyboard.current), sizeBeforeKeyboard.current = null);
      });
      return function() {
        keyboardDidHideListener.remove(), keyboardDidShowListener.remove();
      };
    }
  }, [
    moveOnKeyboardChange
  ]);
  var _useState3 = _sliced_to_array(useState(open ? 1 : 0), 2), opacity = _useState3[0], setOpacity = _useState3[1];
  open && opacity === 0 && setOpacity(1), useEffect(function() {
    if (!open) {
      var tm = setTimeout(function() {
        setOpacity(0);
      }, 400);
      return function() {
        clearTimeout(tm);
      };
    }
  }, [
    open
  ]);
  var forcedContentHeight = hasFit ? void 0 : snapPointsMode === "percent" ? "".concat(maxSnapPoint).concat(isWeb ? "dvh" : "%") : maxSnapPoint, contents = /* @__PURE__ */ _jsx(ParentSheetContext.Provider, {
    value: nextParentContext,
    children: /* @__PURE__ */ _jsxs(SheetProvider, _object_spread_props(_object_spread({}, providerProps), {
      children: [
        /* @__PURE__ */ _jsx(AnimatePresence, {
          custom: {
            open
          },
          children: shouldHideParentSheet || !open ? null : overlayComponent
        }),
        snapPointsMode !== "percent" && /* @__PURE__ */ _jsx(View, {
          style: {
            opacity: 0,
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            pointerEvents: "none"
          },
          onLayout: handleMaxContentViewLayout
        }),
        /* @__PURE__ */ _jsx(AnimatedView, _object_spread_props(_object_spread(_object_spread_props(_object_spread({
          ref
        }, panResponder == null ? void 0 : panResponder.panHandlers), {
          onLayout: handleAnimationViewLayout
        }), !isDragging && {
          // @ts-ignore for CSS driver this is necessary to attach the transition
          animation
        }), {
          // @ts-ignore
          disableClassName: !0,
          style: [
            _object_spread({
              position: "absolute",
              zIndex,
              width: "100%",
              height: forcedContentHeight,
              minHeight: forcedContentHeight,
              opacity
            }, (shouldHideParentSheet || !open) && {
              pointerEvents: "none"
            }),
            animatedStyle
          ],
          children: props.children
        }))
      ]
    }))
  }), adaptContext = useContext(AdaptParentContext), shouldMountChildren = !!(opacity || !unmountChildrenWhenHidden);
  if (modal) {
    var modalContents = /* @__PURE__ */ _jsx(Portal, _object_spread_props(_object_spread({
      zIndex
    }, portalProps), {
      children: shouldMountChildren && /* @__PURE__ */ _jsx(ContainerComponent, {
        children: /* @__PURE__ */ _jsx(Theme, {
          forceClassName: !0,
          name: themeName,
          children: /* @__PURE__ */ _jsx(AdaptParentContext.Provider, {
            value: adaptContext,
            children: contents
          })
        })
      })
    }));
    return isWeb ? modalContents : /* @__PURE__ */ _jsx(SheetInsideSheetContext.Provider, {
      value: onInnerSheet,
      children: modalContents
    });
  }
  return contents;
}));
function getYPositions(mode, point, screenSize, frameSize) {
  if (!screenSize || !frameSize) return 0;
  if (mode === "mixed") {
    if (typeof point == "number")
      return screenSize - Math.min(screenSize, Math.max(0, point));
    if (point === "fit")
      return screenSize - Math.min(screenSize, frameSize);
    if (point.endsWith("%")) {
      var pct = Math.min(100, Math.max(0, Number(point.slice(0, -1)))) / 100;
      if (Number.isNaN(pct))
        return console.warn("Invalid snapPoint percentage string"), 0;
      var next = Math.round(screenSize - pct * screenSize);
      return next;
    }
    return console.warn("Invalid snapPoint unknown value"), 0;
  }
  if (mode === "fit")
    return point === 0 ? screenSize : screenSize - Math.min(screenSize, frameSize);
  if (mode === "constant" && typeof point == "number")
    return screenSize - Math.min(screenSize, Math.max(0, point));
  var pct1 = Math.min(100, Math.max(0, Number(point))) / 100;
  return Number.isNaN(pct1) ? (console.warn("Invalid snapPoint percentage"), 0) : Math.round(screenSize - pct1 * screenSize);
}
export {
  SheetImplementationCustom
};
//# sourceMappingURL=SheetImplementationCustom.js.map
