import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import "@tamagui/polyfill-dev";
import { Adapt, useAdaptParent } from "@tamagui/adapt";
import { Animate } from "@tamagui/animate";
import { ResetPresence } from "@tamagui/animate-presence";
import { hideOthers } from "@tamagui/aria-hidden";
import { useComposedRefs } from "@tamagui/compose-refs";
import { isWeb } from "@tamagui/constants";
import { Stack, Theme, View, createShallowSetState, createStyledContext, useEvent, useGet, useMedia, useThemeName } from "@tamagui/core";
import { FloatingOverrideContext } from "@tamagui/floating";
import { FocusScope } from "@tamagui/focus-scope";
import { composeEventHandlers, withStaticProperties } from "@tamagui/helpers";
import { Popper, PopperAnchor, PopperArrow, PopperContent, PopperContentFrame, PopperContext, usePopperContext } from "@tamagui/popper";
import { Portal, PortalHost, PortalItem } from "@tamagui/portal";
import { RemoveScroll } from "@tamagui/remove-scroll";
import { Sheet, SheetController } from "@tamagui/sheet";
import { YStack } from "@tamagui/stacks";
import { useControllableState } from "@tamagui/use-controllable-state";
import * as React from "react";
import { Platform, ScrollView } from "react-native";
import { useFloatingContext } from "./useFloatingContext";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _object_without_properties(source, excluded) {
  if (source == null) return {};
  var target = _object_without_properties_loose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var POPOVER_SCOPE = "PopoverScope", PopoverContext = createStyledContext({}), usePopoverContext = PopoverContext.useStyledContext, PopoverAnchor = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var __scopePopover = props.__scopePopover, rest = _object_without_properties(props, [
    "__scopePopover"
  ]), context = usePopoverContext(__scopePopover), _ref = context || {}, onCustomAnchorAdd = _ref.onCustomAnchorAdd, onCustomAnchorRemove = _ref.onCustomAnchorRemove;
  return React.useEffect(function() {
    return onCustomAnchorAdd(), function() {
      return onCustomAnchorRemove();
    };
  }, [
    onCustomAnchorAdd,
    onCustomAnchorRemove
  ]), /* @__PURE__ */ _jsx(PopperAnchor, _object_spread_props(_object_spread({
    __scopePopper: __scopePopover || POPOVER_SCOPE
  }, rest), {
    ref: forwardedRef
  }));
}), PopoverTrigger = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var __scopePopover = props.__scopePopover, rest = _object_without_properties(props, [
    "__scopePopover"
  ]), context = usePopoverContext(__scopePopover), anchorTo = context.anchorTo, composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
  if (anchorTo) {
    var virtualRef = {
      current: _object_spread({
        getBoundingClientRect: function() {
          return isWeb ? DOMRect.fromRect(anchorTo) : anchorTo;
        }
      }, !isWeb && {
        measure: function(c) {
          return c(anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.width, anchorTo == null ? void 0 : anchorTo.height);
        },
        measureInWindow: function(c) {
          return c(anchorTo == null ? void 0 : anchorTo.x, anchorTo == null ? void 0 : anchorTo.y, anchorTo == null ? void 0 : anchorTo.width, anchorTo == null ? void 0 : anchorTo.height);
        }
      })
    };
    return /* @__PURE__ */ _jsx(PopperAnchor, {
      virtualRef,
      __scopePopper: __scopePopover || POPOVER_SCOPE
    });
  }
  if (!props.children) return null;
  var trigger = /* @__PURE__ */ _jsx(View, _object_spread_props(_object_spread({
    "aria-haspopup": "dialog",
    "aria-expanded": context.open,
    // TODO not matching
    // aria-controls={context.contentId}
    "data-state": getState(context.open)
  }, rest), {
    // @ts-ignore
    ref: composedTriggerRef,
    onPress: composeEventHandlers(props.onPress, context.onOpenToggle)
  }));
  return context.hasCustomAnchor ? trigger : /* @__PURE__ */ _jsx(PopperAnchor, {
    __scopePopper: __scopePopover || POPOVER_SCOPE,
    asChild: !0,
    children: trigger
  });
}), PopoverContent = PopperContentFrame.extractable(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var allowPinchZoom = props.allowPinchZoom, trapFocus = props.trapFocus, _props_disableRemoveScroll = props.disableRemoveScroll, disableRemoveScroll = _props_disableRemoveScroll === void 0 ? !0 : _props_disableRemoveScroll, zIndex = props.zIndex, __scopePopover = props.__scopePopover, contentImplProps = _object_without_properties(props, [
    "allowPinchZoom",
    "trapFocus",
    "disableRemoveScroll",
    "zIndex",
    "__scopePopover"
  ]), context = usePopoverContext(__scopePopover), contentRef = React.useRef(null), composedRefs = useComposedRefs(forwardedRef, contentRef), isRightClickOutsideRef = React.useRef(!1), _React_useState = _sliced_to_array(React.useState(!context.open), 2), isFullyHidden = _React_useState[0], setIsFullyHidden = _React_useState[1];
  return context.open && isFullyHidden && setIsFullyHidden(!1), React.useEffect(function() {
    if (context.open) {
      var content = contentRef.current;
      if (content) return hideOthers(content);
    }
  }, [
    context.open
  ]), !context.keepChildrenMounted && isFullyHidden ? null : /* @__PURE__ */ _jsx(PopoverContentPortal, {
    __scopePopover,
    zIndex: props.zIndex,
    children: /* @__PURE__ */ _jsx(Stack, {
      pointerEvents: context.open ? "auto" : "none",
      children: /* @__PURE__ */ _jsx(PopoverContentImpl, _object_spread_props(_object_spread({}, contentImplProps), {
        disableRemoveScroll,
        ref: composedRefs,
        setIsFullyHidden,
        __scopePopover,
        // we make sure we're not trapping once it's been closed
        // (closed !== unmounted when animating out)
        trapFocus: trapFocus ?? context.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, function(event) {
          var _context_triggerRef_current;
          event.preventDefault(), isRightClickOutsideRef.current || (_context_triggerRef_current = context.triggerRef.current) === null || _context_triggerRef_current === void 0 || _context_triggerRef_current.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, function(event) {
          var originalEvent = event.detail.originalEvent, ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === !0, isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          isRightClickOutsideRef.current = isRightClick;
        }, {
          checkDefaultPrevented: !1
        }),
        // When focus is trapped, a `focusout` event may still happen.
        // We make sure we don't trigger our `onDismiss` in such case.
        onFocusOutside: composeEventHandlers(props.onFocusOutside, function(event) {
          return event.preventDefault();
        }, {
          checkDefaultPrevented: !1
        })
      }))
    })
  });
}));
function PopoverRepropagateContext(props) {
  return /* @__PURE__ */ _jsx(PopperContext.Provider, _object_spread_props(_object_spread({
    scope: props.scope
  }, props.popperContext), {
    children: /* @__PURE__ */ _jsx(PopoverContext.Provider, _object_spread_props(_object_spread({}, props.context), {
      children: props.children
    }))
  }));
}
function PopoverContentPortal(props) {
  var __scopePopover = props.__scopePopover, _props_zIndex, zIndex = (_props_zIndex = props.zIndex) !== null && _props_zIndex !== void 0 ? _props_zIndex : 15e4, context = usePopoverContext(__scopePopover), popperContext = usePopperContext(__scopePopover || POPOVER_SCOPE), themeName = useThemeName(), contents = props.children;
  return (Platform.OS === "android" || Platform.OS === "ios") && (contents = /* @__PURE__ */ _jsx(PopoverRepropagateContext, {
    scope: __scopePopover || POPOVER_SCOPE,
    popperContext,
    context,
    children: props.children
  })), /* @__PURE__ */ _jsx(Portal, {
    zIndex,
    children: (
      /* forceClassName avoids forced re-mount renders for some reason... see the HeadMenu as you change tints a few times */
      /* without this you'll see the site menu re-rendering. It must be something in wrapping children in Theme */
      /* @__PURE__ */ _jsxs(Theme, {
        forceClassName: !0,
        name: themeName,
        children: [
          !!context.open && !context.breakpointActive && /* @__PURE__ */ _jsx(YStack, {
            fullscreen: !0,
            onPress: composeEventHandlers(props.onPress, context.onOpenToggle)
          }),
          contents
        ]
      })
    )
  });
}
var PopoverContentImpl = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var trapFocus = props.trapFocus, __scopePopover = props.__scopePopover, onOpenAutoFocus = props.onOpenAutoFocus, onCloseAutoFocus = props.onCloseAutoFocus, disableOutsidePointerEvents = props.disableOutsidePointerEvents, disableFocusScope = props.disableFocusScope, onEscapeKeyDown = props.onEscapeKeyDown, onPointerDownOutside = props.onPointerDownOutside, onFocusOutside = props.onFocusOutside, onInteractOutside = props.onInteractOutside, children = props.children, disableRemoveScroll = props.disableRemoveScroll, freezeContentsWhenHidden = props.freezeContentsWhenHidden, setIsFullyHidden = props.setIsFullyHidden, contentProps = _object_without_properties(props, [
    "trapFocus",
    "__scopePopover",
    "onOpenAutoFocus",
    "onCloseAutoFocus",
    "disableOutsidePointerEvents",
    "disableFocusScope",
    "onEscapeKeyDown",
    "onPointerDownOutside",
    "onFocusOutside",
    "onInteractOutside",
    "children",
    "disableRemoveScroll",
    "freezeContentsWhenHidden",
    "setIsFullyHidden"
  ]), context = usePopoverContext(__scopePopover), open = context.open, keepChildrenMounted = context.keepChildrenMounted, popperContext = usePopperContext(__scopePopover || POPOVER_SCOPE), handleExitComplete = React.useCallback(function() {
    setIsFullyHidden == null || setIsFullyHidden(!0);
  }, [
    setIsFullyHidden
  ]);
  if (context.breakpointActive) {
    var childrenWithoutScrollView = React.Children.toArray(children).map(function(child) {
      return /* @__PURE__ */ React.isValidElement(child) && child.type === ScrollView ? child.props.children : child;
    }), content = /* @__PURE__ */ _jsx(ResetPresence, {
      children: childrenWithoutScrollView
    });
    return (Platform.OS === "android" || Platform.OS === "ios") && (content = /* @__PURE__ */ _jsx(PopperContext.Provider, _object_spread_props(_object_spread({
      scope: __scopePopover || POPOVER_SCOPE
    }, popperContext), {
      children: childrenWithoutScrollView
    }))), /* @__PURE__ */ _jsx(PortalItem, {
      hostName: "".concat(context.id, "PopoverContents"),
      children: content
    });
  }
  return /* @__PURE__ */ _jsx(Animate, {
    type: "presence",
    present: !!open,
    keepChildrenMounted,
    onExitComplete: handleExitComplete,
    children: /* @__PURE__ */ _jsx(PopperContent, _object_spread_props(_object_spread({
      __scopePopper: __scopePopover || POPOVER_SCOPE,
      "data-state": getState(open),
      id: context.contentId,
      ref: forwardedRef
    }, contentProps), {
      children: /* @__PURE__ */ _jsx(RemoveScroll, {
        enabled: disableRemoveScroll ? !1 : open,
        allowPinchZoom: !0,
        // causes lots of bugs on touch web on site
        removeScrollBar: !1,
        style: dspContentsStyle,
        children: /* @__PURE__ */ _jsx(ResetPresence, {
          children: /* @__PURE__ */ _jsx(FocusScope, {
            loop: !0,
            enabled: disableFocusScope ? !1 : open,
            trapped: trapFocus,
            onMountAutoFocus: onOpenAutoFocus,
            onUnmountAutoFocus: onCloseAutoFocus,
            children: isWeb ? /* @__PURE__ */ _jsx("div", {
              style: dspContentsStyle,
              children
            }) : children
          })
        })
      })
    }), context.contentId)
  });
}), dspContentsStyle = {
  display: "contents"
}, PopoverClose = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var __scopePopover = props.__scopePopover, rest = _object_without_properties(props, [
    "__scopePopover"
  ]), context = usePopoverContext(__scopePopover);
  return /* @__PURE__ */ _jsx(YStack, _object_spread_props(_object_spread({}, rest), {
    ref: forwardedRef,
    componentName: "PopoverClose",
    onPress: composeEventHandlers(props.onPress, function() {
      return context.onOpenChange(!1, "press");
    })
  }));
}), PopoverArrow = PopperArrow.styleable(function(props, forwardedRef) {
  var __scopePopover = props.__scopePopover, rest = _object_without_properties(props, [
    "__scopePopover"
  ]), context = usePopoverContext(__scopePopover), sheetActive = useSheetBreakpointActive(context.sheetBreakpoint);
  return sheetActive ? null : /* @__PURE__ */ _jsx(PopperArrow, _object_spread_props(_object_spread({
    __scopePopper: __scopePopover || POPOVER_SCOPE,
    componentName: "PopoverArrow"
  }, rest), {
    ref: forwardedRef
  }));
}), Popover = withStaticProperties(/* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var children = props.children, openProp = props.open, defaultOpen = props.defaultOpen, onOpenChange = props.onOpenChange, __scopePopover = props.__scopePopover, keepChildrenMounted = props.keepChildrenMounted, hoverable = props.hoverable, disableFocus = props.disableFocus, restProps = _object_without_properties(props, [
    "children",
    "open",
    "defaultOpen",
    "onOpenChange",
    "__scopePopover",
    "keepChildrenMounted",
    "hoverable",
    "disableFocus"
  ]), id = React.useId(), _useAdaptParent = useAdaptParent({
    Contents: React.useCallback(function() {
      return /* @__PURE__ */ _jsx(PortalHost, {
        name: "".concat(id, "PopoverContents")
      });
    }, [])
  }), when = _useAdaptParent.when, AdaptProvider = _useAdaptParent.AdaptProvider, sheetBreakpoint = when, triggerRef = React.useRef(null), _React_useState = _sliced_to_array(React.useState(!1), 2), hasCustomAnchor = _React_useState[0], setHasCustomAnchor = _React_useState[1], viaRef = React.useRef(), _useControllableState = _sliced_to_array(useControllableState({
    prop: openProp,
    defaultProp: defaultOpen || !1,
    onChange: function(val) {
      onOpenChange == null || onOpenChange(val, viaRef.current);
    }
  }), 2), open = _useControllableState[0], setOpen = _useControllableState[1], handleOpenChange = useEvent(function(val, via) {
    viaRef.current = via, setOpen(val);
  }), sheetActive = useSheetBreakpointActive(sheetBreakpoint), floatingContext = useFloatingContext({
    open,
    setOpen: handleOpenChange,
    disable: sheetActive,
    hoverable,
    disableFocus
  }), _React_useState1 = _sliced_to_array(React.useState(), 2), anchorTo = _React_useState1[0], setAnchorToRaw = _React_useState1[1], setAnchorTo = createShallowSetState(setAnchorToRaw);
  React.useImperativeHandle(forwardedRef, function() {
    return {
      anchorTo: setAnchorTo,
      toggle: function() {
        return setOpen(function(prev) {
          return !prev;
        });
      },
      open: function() {
        return setOpen(!0);
      },
      close: function() {
        return setOpen(!1);
      },
      setOpen
    };
  });
  var popoverContext = {
    id,
    sheetBreakpoint,
    contentId: React.useId(),
    triggerRef,
    open,
    breakpointActive: sheetActive,
    onOpenChange: handleOpenChange,
    onOpenToggle: useEvent(function() {
      open && sheetActive || setOpen(!open);
    }),
    hasCustomAnchor,
    anchorTo,
    onCustomAnchorAdd: React.useCallback(function() {
      return setHasCustomAnchor(!0);
    }, []),
    onCustomAnchorRemove: React.useCallback(function() {
      return setHasCustomAnchor(!1);
    }, []),
    keepChildrenMounted
  }, contents = /* @__PURE__ */ _jsx(Popper, _object_spread_props(_object_spread({
    __scopePopper: __scopePopover || POPOVER_SCOPE,
    stayInFrame: !0
  }, restProps), {
    children: /* @__PURE__ */ _jsx(PopoverContext.Provider, _object_spread_props(_object_spread({
      scope: __scopePopover
    }, popoverContext), {
      children: /* @__PURE__ */ _jsx(PopoverSheetController, {
        onOpenChange: setOpen,
        children
      })
    }))
  }));
  return /* @__PURE__ */ _jsx(AdaptProvider, {
    children: isWeb ? /* @__PURE__ */ _jsx(FloatingOverrideContext.Provider, {
      value: floatingContext,
      children: contents
    }) : contents
  });
}), {
  Anchor: PopoverAnchor,
  Arrow: PopoverArrow,
  Trigger: PopoverTrigger,
  Content: PopoverContent,
  Close: PopoverClose,
  Adapt,
  ScrollView,
  Sheet: Sheet.Controlled
});
function getState(open) {
  return open ? "open" : "closed";
}
var PopoverSheetController = function(_param) {
  var __scopePopover = _param.__scopePopover, props = _object_without_properties(_param, [
    "__scopePopover"
  ]), context = usePopoverContext(__scopePopover), showSheet = useShowPopoverSheet(context), breakpointActive = context.breakpointActive, getShowSheet = useGet(showSheet);
  return /* @__PURE__ */ _jsx(SheetController, {
    onOpenChange: function(val) {
      getShowSheet() && props.onOpenChange(val);
    },
    open: context.open,
    hidden: breakpointActive === !1,
    children: props.children
  });
}, useSheetBreakpointActive = function(breakpoint) {
  var media = useMedia();
  return typeof breakpoint == "boolean" || !breakpoint ? !!breakpoint : media[breakpoint];
}, useShowPopoverSheet = function(context) {
  var breakpointActive = useSheetBreakpointActive(context.sheetBreakpoint);
  return context.open === !1 ? !1 : breakpointActive;
};
export {
  Popover,
  PopoverAnchor,
  PopoverArrow,
  PopoverClose,
  PopoverContent,
  PopoverContext,
  PopoverTrigger,
  usePopoverContext
};
//# sourceMappingURL=Popover.js.map
