"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var extractToNative_exports = {};
__export(extractToNative_exports, {
  extractToNative: () => extractToNative,
  getBabelParseDefinition: () => getBabelParseDefinition,
  getBabelPlugin: () => getBabelPlugin
});
module.exports = __toCommonJS(extractToNative_exports);
var import_node_path = require("node:path"), import_core = require("@babel/core"), import_generator = __toESM(require("@babel/generator")), import_helper_plugin_utils = require("@babel/helper-plugin-utils"), import_parser = require("@babel/parser"), import_template = __toESM(require("@babel/template")), t = __toESM(require("@babel/types")), import_static = require("@tamagui/static");
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _instanceof(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var importNativeView = (0, import_template.default)(`
const __ReactNativeView = require('react-native').View;
const __ReactNativeText = require('react-native').Text;
`), importStyleSheet = (0, import_template.default)(`
const __ReactNativeStyleSheet = require('react-native').StyleSheet;
`), importWithStyle = (0, import_template.default)(`
const __withStableStyle = require('@tamagui/core')._withStableStyle;
`), extractor = (0, import_static.createExtractor)({
  platform: "native"
}), tamaguiBuildOptionsLoaded;
function extractToNative(sourceFileName, sourceCode, options) {
  var ast = (0, import_parser.parse)(sourceCode, {
    sourceType: "module",
    plugins: [
      "jsx",
      "typescript"
    ]
  }), babelPlugin = getBabelPlugin(), out = (0, import_core.transformFromAstSync)(ast, sourceCode, {
    plugins: [
      [
        babelPlugin,
        options
      ]
    ],
    configFile: !1,
    sourceFileName,
    filename: sourceFileName
  });
  if (!out)
    throw new Error("No output returned");
  return out;
}
function getBabelPlugin() {
  return (0, import_helper_plugin_utils.declare)(function(api, options) {
    return api.assertVersion(7), getBabelParseDefinition(options);
  });
}
function getBabelParseDefinition(options) {
  return {
    name: "tamagui",
    visitor: {
      Program: {
        enter: function(root) {
          var _process_env_SOURCE_ROOT, _root_node_body__leadingComments, _root_node_body_, sourcePath = this.file.opts.filename;
          if (sourcePath != null && sourcePath.includes("node_modules") || !(sourcePath != null && sourcePath.endsWith(".jsx")) && !(sourcePath != null && sourcePath.endsWith(".tsx")))
            return;
          !((_process_env_SOURCE_ROOT = process.env.SOURCE_ROOT) === null || _process_env_SOURCE_ROOT === void 0) && _process_env_SOURCE_ROOT.endsWith("ios") && (sourcePath = sourcePath.replace("/ios", ""));
          var hasImportedView = !1, hasImportedViewWrapper = !1, sheetStyles = {}, sheetIdentifier = root.scope.generateUidIdentifier("sheet"), _root_node_body__leadingComments_map_join, firstCommentContents = (_root_node_body__leadingComments_map_join = (_root_node_body_ = root.node.body[0]) === null || _root_node_body_ === void 0 || (_root_node_body__leadingComments = _root_node_body_.leadingComments) === null || _root_node_body__leadingComments === void 0 ? void 0 : _root_node_body__leadingComments.map(function(comment) {
            return (comment == null ? void 0 : comment.value) || " ";
          }).join(" ")) !== null && _root_node_body__leadingComments_map_join !== void 0 ? _root_node_body__leadingComments_map_join : "", firstComment = firstCommentContents ? "//".concat(firstCommentContents) : "", _getPragmaOptions = (0, import_static.getPragmaOptions)({
            source: firstComment,
            path: sourcePath
          }), shouldPrintDebug = _getPragmaOptions.shouldPrintDebug, shouldDisable = _getPragmaOptions.shouldDisable;
          if (shouldDisable)
            return;
          !options.config && !options.components && (tamaguiBuildOptionsLoaded || (tamaguiBuildOptionsLoaded = (0, import_static.loadTamaguiBuildConfigSync)({})));
          var finalOptions = _object_spread({
            // @ts-ignore just in case they leave it out
            platform: "native"
          }, tamaguiBuildOptionsLoaded, options), printLog = (0, import_static.createLogger)(sourcePath, finalOptions);
          function addSheetStyle(style, node) {
            var styleIndex = "".concat(Object.keys(sheetStyles).length), key = "".concat(styleIndex);
            if (process.env.NODE_ENV === "development") {
              var lineNumbers = node.loc ? node.loc.start.line + (node.loc.start.line !== node.loc.end.line ? "-".concat(node.loc.end.line) : "") : "";
              key += ":".concat((0, import_node_path.basename)(sourcePath), ":").concat(lineNumbers);
            }
            return sheetStyles[key] = style, readStyleExpr(key);
          }
          function readStyleExpr(key) {
            return (0, import_template.default)("SHEET['KEY']")({
              SHEET: sheetIdentifier.name,
              KEY: key
            }).expression;
          }
          var res;
          try {
            res = extractor.parseSync(root, _object_spread_props(_object_spread({
              importsWhitelist: [
                "constants.js",
                "colors.js"
              ],
              extractStyledDefinitions: options.forceExtractStyleDefinitions,
              excludeProps: /* @__PURE__ */ new Set([
                "className",
                "userSelect",
                "whiteSpace",
                "textOverflow",
                "cursor",
                "contain"
              ]),
              shouldPrintDebug
            }, finalOptions), {
              // disable this extraction for now at least, need to figure out merging theme vs non-theme
              // because theme need to stay in render(), whereas non-theme can be extracted
              // for now just turn it off entirely at a small perf loss
              disableExtractInlineMedia: !0,
              // disable extracting variables as no native concept of them (only theme values)
              disableExtractVariables: options.experimentalFlattenThemesOnNative ? !1 : "theme",
              sourcePath,
              // disabling flattening for now
              // it's flattening a plain <Paragraph>hello</Paragraph> which breaks things because themes
              // thinking it's not really worth the effort to do much compilation on native
              // for now just disable flatten as it can only run in narrow places on native
              // disableFlattening: 'styled',
              getFlattenedNode: function(param) {
                var isTextView = param.isTextView;
                return hasImportedView || (hasImportedView = !0, root.unshiftContainer("body", importNativeView())), isTextView ? "__ReactNativeText" : "__ReactNativeView";
              },
              onExtractTag: function(props) {
                var isFlattened = props.isFlattened;
                if (!isFlattened)
                  return;
                assertValidTag(props.node);
                var stylesExpr = t.arrayExpression([]), hocStylesExpr = t.arrayExpression([]), expressions = [], finalAttrs = [], themeKeysUsed = /* @__PURE__ */ new Set();
                function getStyleExpression(style) {
                  if (style) {
                    var _splitThemeStyles = splitThemeStyles(style), plain = _splitThemeStyles.plain, themed = _splitThemeStyles.themed, themeExpr = null;
                    if (themed && options.experimentalFlattenThemesOnNative) {
                      for (var key in themed)
                        themeKeysUsed.add(themed[key].split("$")[1]);
                      themeExpr = getThemedStyleExpression(themed);
                    }
                    var ident = addSheetStyle(plain, props.node);
                    return themeExpr ? (addStyleExpression(ident), addStyleExpression(ident, !0), themeExpr) : ident;
                  }
                }
                function addStyleExpression(expr) {
                  var HOC = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
                  if (Array.isArray(expr)) {
                    var _elements;
                    (_elements = (HOC ? hocStylesExpr : stylesExpr).elements).push.apply(_elements, _to_consumable_array(expr));
                  } else
                    (HOC ? hocStylesExpr : stylesExpr).elements.push(expr);
                }
                function getThemedStyleExpression(styles) {
                  var themedStylesAst = (0, import_static.literalToAst)(styles);
                  return themedStylesAst.properties.forEach(function(_) {
                    var prop = _;
                    prop.value.type === "StringLiteral" && (prop.value = t.memberExpression(t.identifier("theme"), t.identifier(prop.value.value.slice(1) + ".get()")));
                  }), themedStylesAst;
                }
                var hasDynamicStyle = !1, _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
                try {
                  for (var _iterator = props.attrs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                    var attr = _step.value;
                    switch (attr.type) {
                      case "style": {
                        var styleExpr = getStyleExpression(attr.value);
                        addStyleExpression(styleExpr), options.experimentalFlattenThemesOnNative && addStyleExpression(styleExpr, !0);
                        break;
                      }
                      case "ternary": {
                        var _attr_value = attr.value, consequent = _attr_value.consequent, alternate = _attr_value.alternate, consExpr = getStyleExpression(consequent), altExpr = getStyleExpression(alternate);
                        options.experimentalFlattenThemesOnNative && (expressions.push(attr.value.test), addStyleExpression(t.conditionalExpression(t.identifier("_expressions[".concat(expressions.length - 1, "]")), consExpr || t.nullLiteral(), altExpr || t.nullLiteral()), !0));
                        var styleExpr1 = t.conditionalExpression(attr.value.test, consExpr || t.nullLiteral(), altExpr || t.nullLiteral());
                        addStyleExpression(styleExpr1);
                        break;
                      }
                      case "dynamic-style": {
                        hasDynamicStyle = !0, expressions.push(attr.value), options.experimentalFlattenDynamicValues ? addStyleExpression(t.objectExpression([
                          t.objectProperty(t.identifier(attr.name), t.identifier("_expressions[".concat(expressions.length - 1, "]")))
                        ]), !0) : addStyleExpression(t.objectExpression([
                          t.objectProperty(t.identifier(attr.name), attr.value)
                        ]));
                        break;
                      }
                      case "attr": {
                        t.isJSXSpreadAttribute(attr.value) && (0, import_static.isSimpleSpread)(attr.value) && (stylesExpr.elements.push(t.memberExpression(attr.value.argument, t.identifier("style"))), options.experimentalFlattenThemesOnNative && hocStylesExpr.elements.push(t.memberExpression(attr.value.argument, t.identifier("style")))), finalAttrs.push(attr.value);
                        break;
                      }
                    }
                  }
                } catch (err) {
                  _didIteratorError = !0, _iteratorError = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
                  } finally {
                    if (_didIteratorError)
                      throw _iteratorError;
                  }
                }
                if (props.node.attributes = finalAttrs, props.isFlattened)
                  if (options.experimentalFlattenThemesOnNative && (themeKeysUsed.size || hocStylesExpr.elements.length > 1 || hasDynamicStyle)) {
                    hasImportedViewWrapper || (root.unshiftContainer("body", importWithStyle()), hasImportedViewWrapper = !0);
                    var name = props.node.name.name, WrapperIdentifier = root.scope.generateUidIdentifier(name + "Wrapper");
                    root.pushContainer("body", t.variableDeclaration("const", [
                      t.variableDeclarator(WrapperIdentifier, t.callExpression(t.identifier("__withStableStyle"), [
                        t.identifier(name),
                        t.arrowFunctionExpression([
                          t.identifier("theme"),
                          t.identifier("_expressions")
                        ], t.blockStatement([
                          t.returnStatement(t.callExpression(t.memberExpression(t.identifier("React"), t.identifier("useMemo")), [
                            t.arrowFunctionExpression([], t.blockStatement([
                              t.returnStatement(t.arrayExpression(_to_consumable_array(hocStylesExpr.elements)))
                            ])),
                            t.arrayExpression([
                              t.spreadElement(t.identifier("_expressions"))
                            ])
                          ]))
                        ]))
                      ]))
                    ])), props.node.name = WrapperIdentifier, props.jsxPath.node.closingElement && (props.jsxPath.node.closingElement.name = WrapperIdentifier), expressions.length && props.node.attributes.push(t.jsxAttribute(t.jsxIdentifier("expressions"), t.jsxExpressionContainer(t.arrayExpression(expressions))));
                  } else
                    props.node.attributes.push(t.jsxAttribute(t.jsxIdentifier("style"), t.jsxExpressionContainer(stylesExpr.elements.length === 1 ? stylesExpr.elements[0] : stylesExpr)));
              }
            }));
          } catch (err) {
            if (_instanceof(err, Error)) {
              var message = "".concat(shouldPrintDebug === "verbose" ? err : err.message);
              message.includes("Unexpected return value from visitor method") && (message = "Unexpected return value from visitor method"), console.warn("Error in Tamagui parse, skipping", message, err.stack);
              return;
            }
          }
          if (!Object.keys(sheetStyles).length) {
            shouldPrintDebug && console.info("END no styles"), res && printLog(res);
            return;
          }
          var sheetObject = (0, import_static.literalToAst)(sheetStyles), sheetOuter = (0, import_template.default)("const SHEET = __ReactNativeStyleSheet.create(null)")({
            SHEET: sheetIdentifier.name
          });
          sheetOuter.declarations[0].init.arguments[0] = sheetObject, root.unshiftContainer("body", sheetOuter), root.unshiftContainer("body", importStyleSheet()), shouldPrintDebug && (console.info(`
 -------- output code ------- 
`), console.info((0, import_generator.default)(root.parent).code.split(`
`).filter(function(x) {
            return !x.startsWith("//");
          }).join(`
`))), res && printLog(res);
        }
      }
    }
  };
}
function assertValidTag(node) {
  if (node.attributes.find(function(x) {
    return x.type === "JSXAttribute" && x.name.name === "style";
  })) {
    var _process_env_DEBUG;
    !((_process_env_DEBUG = process.env.DEBUG) === null || _process_env_DEBUG === void 0) && _process_env_DEBUG.startsWith("tamagui") && console.warn("\u26A0\uFE0F Cannot pass style attribute to extracted style");
  }
}
function splitThemeStyles(style) {
  var themed = {}, plain = {}, noTheme = !0;
  for (var key in style) {
    var val = style[key];
    val && val[0] === "$" ? (themed[key] = val, noTheme = !1) : plain[key] = val;
  }
  return {
    themed: noTheme ? null : themed,
    plain
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  extractToNative,
  getBabelParseDefinition,
  getBabelPlugin
});
//# sourceMappingURL=extractToNative.js.map
