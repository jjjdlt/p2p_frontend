"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var extractToClassNames_exports = {};
__export(extractToClassNames_exports, {
  extractToClassNames: () => extractToClassNames
});
module.exports = __toCommonJS(extractToClassNames_exports);
var path = __toESM(require("node:path")), util = __toESM(require("node:util")), import_generator = __toESM(require("@babel/generator")), t = __toESM(require("@babel/types")), helpers = __toESM(require("@tamagui/helpers")), import_requireTamaguiCore = require("../helpers/requireTamaguiCore"), import_babelParse = require("./babelParse"), import_buildClassName = require("./buildClassName"), import_ensureImportingConcat = require("./ensureImportingConcat"), import_extractHelpers = require("./extractHelpers"), import_extractMediaStyle = require("./extractMediaStyle"), import_hoistClassNames = require("./hoistClassNames"), import_propsToFontFamilyCache = require("./propsToFontFamilyCache"), import_timer = require("./timer"), import_createLogger = require("./createLogger");
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg), value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  info.done ? resolve(value) : Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
function _ts_generator(thisArg, body) {
  var f, y, t2, g, _ = {
    label: 0,
    sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    for (; _; ) try {
      if (f = 1, y && (t2 = op[0] & 2 ? y.return : op[0] ? y.throw || ((t2 = y.return) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
      switch (y = 0, t2 && (op = [
        op[0] & 2,
        t2.value
      ]), op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          return _.label++, {
            value: op[1],
            done: !1
          };
        case 5:
          _.label++, y = op[1], op = [
            0
          ];
          continue;
        case 7:
          op = _.ops.pop(), _.trys.pop();
          continue;
        default:
          if (t2 = _.trys, !(t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1], t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2], _.ops.push(op);
            break;
          }
          t2[2] && _.ops.pop(), _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [
        6,
        e
      ], y = 0;
    } finally {
      f = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var mergeStyleGroups = {
  shadowOpacity: !0,
  shadowRadius: !0,
  shadowColor: !0,
  shadowOffset: !0
};
function extractToClassNames(_) {
  return _extractToClassNames.apply(this, arguments);
}
function _extractToClassNames() {
  return _extractToClassNames = _async_to_generator(function(param) {
    var extractor, source, _param_sourcePath, sourcePath, options, shouldPrintDebug, tm, getStylesAtomic, printLog, ast, cssMap, existingHoists, hasFlattened, res, styles, result;
    return _ts_generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (extractor = param.extractor, source = param.source, _param_sourcePath = param.sourcePath, sourcePath = _param_sourcePath === void 0 ? "" : _param_sourcePath, options = param.options, shouldPrintDebug = param.shouldPrintDebug, tm = (0, import_timer.timer)(), getStylesAtomic = (0, import_requireTamaguiCore.requireTamaguiCore)("web").getStylesAtomic, sourcePath.includes("node_modules"))
            return [
              2,
              null
            ];
          if (shouldPrintDebug && console.warn("--- ".concat(sourcePath, ` --- 

`)), typeof source != "string")
            throw new Error("`source` must be a string of javascript");
          if (!path.isAbsolute(sourcePath))
            throw new Error("`sourcePath` must be an absolute path to a .js file, got: " + sourcePath);
          return /.[tj]sx?$/i.test(sourcePath || "") || console.warn("".concat(sourcePath.slice(0, 100), " - bad filename.")), !options.disableExtraction && !options._disableLoadTamagui ? [
            4,
            extractor.loadTamagui(options)
          ] : [
            3,
            2
          ];
        case 1:
          _state.sent(), _state.label = 2;
        case 2:
          printLog = (0, import_createLogger.createLogger)(sourcePath, options);
          try {
            ast = (0, import_babelParse.babelParse)(source, sourcePath);
          } catch (err) {
            throw console.error("babel parse error:", sourcePath.slice(0, 100)), err;
          }
          return tm.mark("babel-parse", shouldPrintDebug === "verbose"), cssMap = /* @__PURE__ */ new Map(), existingHoists = {}, hasFlattened = !1, [
            4,
            extractor.parse(ast, _object_spread_props(_object_spread({
              shouldPrintDebug
            }, options), {
              platform: "web",
              sourcePath,
              extractStyledDefinitions: !0,
              onStyleRule: function(identifier, rules) {
                var css = rules.join(";");
                shouldPrintDebug && console.info("adding styled() rule: .".concat(identifier, " ").concat(css)), cssMap.set(".".concat(identifier), {
                  css,
                  commentTexts: []
                });
              },
              getFlattenedNode: function(param2) {
                var tag = param2.tag;
                return hasFlattened = !0, tag;
              },
              onExtractTag: function(param2) {
                var parserProps = param2.parserProps, attrs = param2.attrs, node = param2.node, attemptEval = param2.attemptEval, jsxPath = param2.jsxPath, originalNodeName = param2.originalNodeName, filePath = param2.filePath, lineNumbers = param2.lineNumbers, programPath = param2.programPath, isFlattened = param2.isFlattened, staticConfig = param2.staticConfig, addTernaryStyle = function(ternary, a, b) {
                  var cCN = a.map(function(x) {
                    return x[helpers.StyleObjectIdentifier];
                  }).join(" "), aCN = b.map(function(x) {
                    return x[helpers.StyleObjectIdentifier];
                  }).join(" ");
                  a.length && b.length ? finalClassNames.push(t.conditionalExpression(ternary.test, t.stringLiteral(cCN), t.stringLiteral(aCN))) : finalClassNames.push(t.conditionalExpression(ternary.test, t.stringLiteral(" " + cCN), t.stringLiteral(" " + aCN)));
                };
                if (staticConfig.acceptsClassName === !1) {
                  shouldPrintDebug && console.info("bail, acceptsClassName is false");
                  return;
                }
                var didFlattenThisTag = hasFlattened;
                hasFlattened = !1;
                var finalClassNames = [], finalAttrs = [], finalStyles = [], viewStyles = {}, _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
                try {
                  for (var _iterator = attrs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
                    var attr = _step.value;
                    attr.type === "style" && (viewStyles = _object_spread({}, viewStyles, attr.value));
                  }
                } catch (err) {
                  _didIteratorError = !0, _iteratorError = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
                  } finally {
                    if (_didIteratorError)
                      throw _iteratorError;
                  }
                }
                var ensureNeededPrevStyle = function(style2) {
                  var keys = Object.keys(style2);
                  if (!keys.some(function(key) {
                    return mergeStyleGroups[key];
                  }))
                    return style2;
                  for (var k in mergeStyleGroups)
                    if (k in viewStyles) {
                      var _style_k;
                      style2[k] = (_style_k = style2[k]) !== null && _style_k !== void 0 ? _style_k : viewStyles[k];
                    }
                  return style2;
                }, addStyles = function(style2) {
                  if (!style2) return [];
                  var styleWithPrev = ensureNeededPrevStyle(style2), res2 = getStylesAtomic(styleWithPrev);
                  return res2.length && (finalStyles = _to_consumable_array(finalStyles).concat(_to_consumable_array(res2))), res2;
                }, lastMediaImportance = 1, _iteratorNormalCompletion1 = !0, _didIteratorError1 = !1, _iteratorError1 = void 0;
                try {
                  for (var _iterator1 = attrs[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0) {
                    var attr1 = _step1.value;
                    switch (attr1.type) {
                      case "style": {
                        if (isFlattened) {
                          var styles1 = addStyles(attr1.value), newFontFamily = (0, import_propsToFontFamilyCache.getFontFamilyClassNameFromProps)(attr1.value) || "", newClassNames = helpers.concatClassName(styles1.map(function(x) {
                            return x[helpers.StyleObjectIdentifier];
                          }).join(" ") + newFontFamily), existing = finalClassNames.find(function(x) {
                            return x.type == "StringLiteral";
                          });
                          if (existing) {
                            var previous = existing.value;
                            newFontFamily && (shouldPrintDebug && console.info(" newFontFamily: ".concat(newFontFamily)), previous = previous.replace(/font_[a-z]+/i, "")), existing.value = "".concat(previous, " ").concat(newClassNames);
                          } else
                            finalClassNames = _to_consumable_array(finalClassNames).concat([
                              t.stringLiteral(newClassNames)
                            ]);
                        } else {
                          var styles2 = getStylesAtomic(attr1.value);
                          finalStyles = _to_consumable_array(finalStyles).concat(_to_consumable_array(styles2));
                          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
                          try {
                            for (var _iterator2 = styles2[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
                              var style = _step2.value, prop = style[helpers.StyleObjectPseudo] ? "".concat(style[helpers.StyleObjectProperty], "-").concat(style[helpers.StyleObjectPseudo]) : style[helpers.StyleObjectProperty];
                              finalAttrs.push(t.jsxAttribute(t.jsxIdentifier(prop), t.stringLiteral(style[helpers.StyleObjectIdentifier])));
                            }
                          } catch (err) {
                            _didIteratorError2 = !0, _iteratorError2 = err;
                          } finally {
                            try {
                              !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
                            } finally {
                              if (_didIteratorError2)
                                throw _iteratorError2;
                            }
                          }
                        }
                        break;
                      }
                      case "attr": {
                        var val = attr1.value;
                        if (t.isJSXSpreadAttribute(val))
                          (0, import_extractHelpers.isSimpleSpread)(val) && finalClassNames.push(t.logicalExpression("&&", val.argument, t.memberExpression(val.argument, t.identifier("className"))));
                        else if (val.name.name === "className") {
                          var value = val.value;
                          if (value)
                            try {
                              var evaluatedValue = attemptEval(value);
                              finalClassNames.push(t.stringLiteral(evaluatedValue));
                            } catch {
                              finalClassNames.push(value.expression);
                            }
                          continue;
                        }
                        finalAttrs.push(val);
                        break;
                      }
                      case "ternary": {
                        var mediaExtraction = (0, import_extractMediaStyle.extractMediaStyle)(parserProps, attr1.value, jsxPath, extractor.getTamagui(), sourcePath || "", lastMediaImportance, shouldPrintDebug);
                        if (shouldPrintDebug && mediaExtraction) {
                          var _mediaExtraction_ternaryWithoutMedia, _mediaExtraction_ternaryWithoutMedia_inlineMediaQuery;
                          console.info("ternary (mediaStyles)", (_mediaExtraction_ternaryWithoutMedia_inlineMediaQuery = (_mediaExtraction_ternaryWithoutMedia = mediaExtraction.ternaryWithoutMedia) === null || _mediaExtraction_ternaryWithoutMedia === void 0 ? void 0 : _mediaExtraction_ternaryWithoutMedia.inlineMediaQuery) !== null && _mediaExtraction_ternaryWithoutMedia_inlineMediaQuery !== void 0 ? _mediaExtraction_ternaryWithoutMedia_inlineMediaQuery : "", mediaExtraction.mediaStyles.map(function(x) {
                            return x[helpers.StyleObjectIdentifier];
                          }).join("."));
                        }
                        if (!mediaExtraction) {
                          shouldPrintDebug && mediaExtraction && console.info("add ternary"), addTernaryStyle(attr1.value, addStyles(attr1.value.consequent), addStyles(attr1.value.alternate));
                          continue;
                        }
                        lastMediaImportance++, mediaExtraction.mediaStyles && (finalStyles = _to_consumable_array(finalStyles).concat(_to_consumable_array(mediaExtraction.mediaStyles))), mediaExtraction.ternaryWithoutMedia ? addTernaryStyle(mediaExtraction.ternaryWithoutMedia, mediaExtraction.mediaStyles, []) : finalClassNames = _to_consumable_array(finalClassNames).concat(_to_consumable_array(mediaExtraction.mediaStyles.map(function(x) {
                          return t.stringLiteral(x[helpers.StyleObjectIdentifier]);
                        })));
                        break;
                      }
                    }
                  }
                } catch (err) {
                  _didIteratorError1 = !0, _iteratorError1 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
                  } finally {
                    if (_didIteratorError1)
                      throw _iteratorError1;
                  }
                }
                if (shouldPrintDebug === "verbose" && console.info(`  finalClassNames AST
`, JSON.stringify(finalClassNames, null, 2)), node.attributes = finalAttrs, finalClassNames.length) {
                  var extraClassNames = function() {
                    var value2 = "";
                    return isFlattened && (process.env.TAMAGUI_DEBUG_OPTIMIZATIONS && (value2 += "is_tamagui_flattened"), staticConfig.componentName && (value2 += " is_".concat(staticConfig.componentName))), value2;
                  }(), names = (0, import_buildClassName.buildClassName)(finalClassNames, extraClassNames), nameExpr = names ? (0, import_hoistClassNames.hoistClassNames)(jsxPath, existingHoists, names) : null, expr = nameExpr;
                  if (nameExpr && !t.isIdentifier(nameExpr) && didFlattenThisTag) {
                    (0, import_ensureImportingConcat.ensureImportingConcat)(programPath);
                    var simpleSpreads = attrs.filter(function(x) {
                      return x.type === "attr" && t.isJSXSpreadAttribute(x.value) && (0, import_extractHelpers.isSimpleSpread)(x.value);
                    });
                    expr = t.callExpression(t.identifier("concatClassName"), [
                      expr
                    ].concat(_to_consumable_array(simpleSpreads.map(function(val2) {
                      return val2.value.argument;
                    }))));
                  }
                  node.attributes.push(t.jsxAttribute(t.jsxIdentifier("className"), t.jsxExpressionContainer(expr)));
                }
                var comment = util.format("/* %s:%s (%s) */", filePath, lineNumbers, originalNodeName), _iteratorNormalCompletion3 = !0, _didIteratorError3 = !1, _iteratorError3 = void 0;
                try {
                  for (var _iterator3 = finalStyles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = !0) {
                    var styleObject = _step3.value, identifier = styleObject[helpers.StyleObjectIdentifier], rules = styleObject[helpers.StyleObjectRules], className = ".".concat(identifier);
                    if (cssMap.has(className)) {
                      if (comment) {
                        var val1 = cssMap.get(className);
                        val1.commentTexts.push(comment), cssMap.set(className, val1);
                      }
                    } else rules.length && cssMap.set(className, {
                      css: rules.join(`
`),
                      commentTexts: [
                        comment
                      ]
                    });
                  }
                } catch (err) {
                  _didIteratorError3 = !0, _iteratorError3 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion3 && _iterator3.return != null && _iterator3.return();
                  } finally {
                    if (_didIteratorError3)
                      throw _iteratorError3;
                  }
                }
              }
            }))
          ];
        case 3:
          return res = _state.sent(), !res || !res.modified && !res.optimized && !res.flattened && !res.styled ? (shouldPrintDebug && console.info("no res or none modified", res), [
            2,
            null
          ]) : (styles = Array.from(cssMap.values()).map(function(x) {
            return x.css;
          }).join(`
`).trim(), result = (0, import_generator.default)(ast, {
            concise: !1,
            filename: sourcePath,
            // this makes the debug output terrible, and i think sourcemap works already
            retainLines: !1,
            sourceFileName: sourcePath,
            sourceMaps: !0
          }, source), shouldPrintDebug && (console.info(`
 -------- output code ------- 

`, result.code.split(`
`).filter(function(x) {
            return !x.startsWith("//");
          }).join(`
`)), console.info(`
 -------- output style -------- 

`, styles)), printLog(res), [
            2,
            {
              ast,
              styles,
              js: result.code,
              map: result.map
            }
          ]);
      }
    });
  }), _extractToClassNames.apply(this, arguments);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  extractToClassNames
});
//# sourceMappingURL=extractToClassNames.js.map
