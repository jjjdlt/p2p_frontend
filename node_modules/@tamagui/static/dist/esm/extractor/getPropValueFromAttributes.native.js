import generate from "@babel/generator";
import * as t from "@babel/types";
import { accessSafe } from "./accessSafe";
function getPropValueFromAttributes(propName, attrs) {
  for (var propIndex = -1, jsxAttr = null, idx = -1, len = attrs.length; ++idx < len; ) {
    var attr = attrs[idx];
    if (t.isJSXAttribute(attr) && attr.name && attr.name.name === propName) {
      propIndex = idx, jsxAttr = attr;
      break;
    }
  }
  if (!jsxAttr || jsxAttr.value == null)
    return null;
  var propValue = jsxAttr.value;
  if (t.isJSXExpressionContainer(propValue) && (propValue = propValue.expression), t.isJSXEmptyExpression(propValue))
    return console.error("encountered JSXEmptyExpression"), null;
  var applicableSpreads = attrs.filter(
    // 1. idx is greater than propValue prop index
    // 2. attr is a spread operator
    function(attr2, idx2) {
      if (t.isJSXSpreadAttribute(attr2)) {
        if (t.isIdentifier(attr2.argument) || t.isMemberExpression(attr2.argument))
          return idx2 > propIndex;
        if (t.isLogicalExpression(attr2.argument))
          return !1;
        throw new Error('unsupported spread of type "'.concat(attr2.argument.type, '": ').concat(generate(attr2).code));
      }
      return !1;
    }
  ).map(function(attr2) {
    return attr2.argument;
  });
  return applicableSpreads.length > 0 && (propValue = applicableSpreads.reduce(function(acc, val) {
    return t.logicalExpression("||", accessSafe(val, propName), acc);
  }, propValue)), propValue;
}
export {
  getPropValueFromAttributes
};
//# sourceMappingURL=getPropValueFromAttributes.js.map
