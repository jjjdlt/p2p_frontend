import { dirname, join } from "node:path";
import { generateThemes, writeGeneratedThemes } from "@tamagui/generate-themes";
import * as FS from "fs-extra";
import { requireTamaguiCore } from "../helpers/requireTamaguiCore.mjs";
import { getBundledConfig } from "./bundleConfig.mjs";
const tamaguiDir = join(process.cwd(), ".tamagui"),
  confFile = join(tamaguiDir, "tamagui.config.json");
async function generateTamaguiStudioConfig(tamaguiOptions, configIn, rebuild = !1) {
  try {
    const config = configIn ?? (await getBundledConfig(tamaguiOptions, rebuild));
    if (!config) return;
    const out = transformConfig(config, tamaguiOptions.platform || "web");
    await FS.ensureDir(dirname(confFile)), await FS.writeJSON(confFile, out, {
      spaces: 2
    });
  } catch (err) {
    (process.env.DEBUG?.includes("tamagui") || process.env.IS_TAMAGUI_DEV) && console.warn("generateTamaguiStudioConfig error", err);
  }
}
function generateTamaguiStudioConfigSync(_tamaguiOptions, config) {
  try {
    FS.ensureDirSync(dirname(confFile)), FS.writeJSONSync(confFile, transformConfig(config, _tamaguiOptions.platform || "web"), {
      spaces: 2
    });
  } catch (err) {
    (process.env.DEBUG?.includes("tamagui") || process.env.IS_TAMAGUI_DEV) && console.warn("generateTamaguiStudioConfig error", err);
  }
}
async function generateTamaguiThemes(tamaguiOptions, force = !1) {
  if (!tamaguiOptions.themeBuilder) return;
  const {
      input,
      output
    } = tamaguiOptions.themeBuilder,
    inPath = resolveRelativePath(input),
    outPath = resolveRelativePath(output),
    generatedOutput = await generateThemes(inPath),
    hasChanged = force || (await (async () => {
      try {
        if (!(await FS.pathExists(join(tamaguiDir, "theme-builder.json")))) return !0;
        if (!generatedOutput) return !1;
        const next = generatedOutput.generated,
          current = await FS.readFile(outPath, "utf-8");
        return next !== current;
      } catch {}
      return !0;
    })());
  return hasChanged && (await writeGeneratedThemes(tamaguiDir, outPath, generatedOutput)), hasChanged;
}
const resolveRelativePath = inputPath => inputPath.startsWith(".") ? join(process.cwd(), inputPath) : require.resolve(inputPath);
function cloneDeepSafe(x, excludeKeys = {}) {
  return x && (Array.isArray(x) ? x.map(_ => cloneDeepSafe(_)) : typeof x == "function" ? "Function" : typeof x != "object" ? x : "$$typeof" in x ? "Component" : Object.fromEntries(Object.entries(x).flatMap(([k, v]) => excludeKeys[k] ? [] : [[k, cloneDeepSafe(v)]])));
}
function transformConfig(config, platform) {
  if (!config) return null;
  const {
      getVariableValue
    } = requireTamaguiCore(platform),
    next = cloneDeepSafe(config, {
      validStyles: !0
    }),
    {
      components,
      nameToPaths,
      tamaguiConfig
    } = next,
    {
      themes,
      tokens
    } = tamaguiConfig;
  for (const key in themes) {
    const theme = themes[key];
    theme.id = key;
    for (const tkey in theme) theme[tkey] = getVariableValue(theme[tkey]);
  }
  for (const key in tokens) {
    const token = {
      ...tokens[key]
    };
    for (const tkey in token) token[tkey] = getVariableValue(token[tkey]);
  }
  for (const component of components) for (const _ in component.nameToInfo) {
    const compDefinition = {
      ...component.nameToInfo[_]
    };
    component.nameToInfo[_] = compDefinition;
    const {
      parentStaticConfig,
      ...rest
    } = compDefinition.staticConfig;
    compDefinition.staticConfig = rest;
  }
  next.nameToPaths = {};
  for (const key in nameToPaths) next.nameToPaths[key] = [...nameToPaths[key]];
  const {
    fontsParsed,
    getCSS,
    tokensParsed,
    themeConfig,
    ...cleanedConfig
  } = next.tamaguiConfig;
  return {
    components,
    nameToPaths,
    tamaguiConfig: cleanedConfig
  };
}
export { generateTamaguiStudioConfig, generateTamaguiStudioConfigSync, generateTamaguiThemes };