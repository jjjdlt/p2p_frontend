import { basename, relative } from "node:path";
import traverse from "@babel/traverse";
import * as t from "@babel/types";
import { Color, colorLog } from "@tamagui/cli-color";
import { StyleObjectIdentifier, StyleObjectRules } from "@tamagui/web";
import * as reactNativeWebInternals from "react-native-web-internals";
import { FAILED_EVAL } from "../constants";
import { requireTamaguiCore } from "../helpers/requireTamaguiCore";
import { createEvaluator, createSafeEvaluator } from "./createEvaluator";
import { evaluateAstNode } from "./evaluateAstNode";
import { attrStr, findComponentName, getValidComponent, getValidComponentsPaths, getValidImport, isPresent, isValidImport, objToStr } from "./extractHelpers";
import { findTopmostFunction } from "./findTopmostFunction";
import { cleanupBeforeExit, getStaticBindingsForScope } from "./getStaticBindingsForScope";
import { literalToAst } from "./literalToAst";
import { loadTamagui, loadTamaguiSync } from "./loadTamagui";
import { logLines } from "./logLines";
import { normalizeTernaries } from "./normalizeTernaries";
import { setPropsToFontFamily } from "./propsToFontFamilyCache";
import { removeUnusedHooks } from "./removeUnusedHooks";
import { timer } from "./timer";
import { validHTMLAttributes } from "./validHTMLAttributes";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg), value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  info.done ? resolve(value) : Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
  return function() {
    var self = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _object_without_properties(source, excluded) {
  if (source == null) return {};
  var target = _object_without_properties_loose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
function _ts_generator(thisArg, body) {
  var f, y, t2, g, _ = {
    label: 0,
    sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    },
    trys: [],
    ops: []
  };
  return g = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([
        n,
        v
      ]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    for (; _; ) try {
      if (f = 1, y && (t2 = op[0] & 2 ? y.return : op[0] ? y.throw || ((t2 = y.return) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
      switch (y = 0, t2 && (op = [
        op[0] & 2,
        t2.value
      ]), op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          return _.label++, {
            value: op[1],
            done: !1
          };
        case 5:
          _.label++, y = op[1], op = [
            0
          ];
          continue;
        case 7:
          op = _.ops.pop(), _.trys.pop();
          continue;
        default:
          if (t2 = _.trys, !(t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1], t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2], _.ops.push(op);
            break;
          }
          t2[2] && _.ops.pop(), _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [
        6,
        e
      ], y = 0;
    } finally {
      f = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: !0
    };
  }
}
var UNTOUCHED_PROPS = {
  key: !0,
  style: !0,
  className: !0
}, validHooks = {
  useMedia: !0,
  useTheme: !0
}, createTernary = function(x) {
  return x;
}, hasLoggedBaseInfo = !1;
function isFullyDisabled(props) {
  return props.disableExtraction && props.disableDebugAttr;
}
function createExtractor() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    logger: console
  }, _ref_logger = _ref.logger, logger = _ref_logger === void 0 ? console : _ref_logger, _ref_platform = _ref.platform, platform = _ref_platform === void 0 ? "web" : _ref_platform, INLINE_EXTRACTABLE = _object_spread({
    ref: "ref",
    key: "key"
  }, platform === "web" && {
    onPress: "onClick",
    onHoverIn: "onMouseEnter",
    onHoverOut: "onMouseLeave",
    onPressIn: "onMouseDown",
    onPressOut: "onMouseUp"
  }), componentState = {
    focus: !1,
    focusVisible: !1,
    hover: !1,
    unmounted: !0,
    press: !1,
    pressIn: !1,
    disabled: !1
  }, styleProps = {
    resolveValues: "value",
    noClassNames: !1,
    isAnimated: !1
  }, shouldAddDebugProp = (
    // really basic disable this for next.js because it messes with ssr
    !process.env.npm_package_dependencies_next && !1
  ), projectInfo = null;
  function loadSync(props) {
    return isFullyDisabled(props) ? null : projectInfo || (projectInfo = loadTamaguiSync(props));
  }
  function load(props) {
    return _load.apply(this, arguments);
  }
  function _load() {
    return _load = _async_to_generator(function(props) {
      var _tmp;
      return _ts_generator(this, function(_state) {
        switch (_state.label) {
          case 0:
            return isFullyDisabled(props) ? [
              2,
              null
            ] : (_tmp = projectInfo, _tmp ? [
              3,
              2
            ] : [
              4,
              loadTamagui(props)
            ]);
          case 1:
            _tmp = projectInfo = _state.sent(), _state.label = 2;
          case 2:
            return [
              2,
              _tmp
            ];
        }
      });
    }), _load.apply(this, arguments);
  }
  return {
    options: {
      logger
    },
    cleanupBeforeExit,
    loadTamagui: load,
    loadTamaguiSync: loadSync,
    getTamagui: function() {
      return projectInfo == null ? void 0 : projectInfo.tamaguiConfig;
    },
    parseSync: function(f, props) {
      var projectInfo2 = loadSync(props);
      return parseWithConfig(projectInfo2 || {}, f, props);
    },
    parse: function() {
      var _ref2 = _async_to_generator(function(f, props) {
        var projectInfo2;
        return _ts_generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              return [
                4,
                load(props)
              ];
            case 1:
              return projectInfo2 = _state.sent(), [
                2,
                parseWithConfig(projectInfo2 || {}, f, props)
              ];
          }
        });
      });
      return function(f, props) {
        return _ref2.apply(this, arguments);
      };
    }()
  };
  function parseWithConfig(param, fileOrPath, options) {
    var components = param.components, tamaguiConfig = param.tamaguiConfig, _options_config = options.config, config = _options_config === void 0 ? "tamagui.config.ts" : _options_config, _options_importsWhitelist = options.importsWhitelist, importsWhitelist = _options_importsWhitelist === void 0 ? [
      "constants.js"
    ] : _options_importsWhitelist, _options_evaluateVars = options.evaluateVars, evaluateVars = _options_evaluateVars === void 0 ? !0 : _options_evaluateVars, _options_sourcePath = options.sourcePath, sourcePath = _options_sourcePath === void 0 ? "" : _options_sourcePath, onExtractTag = options.onExtractTag, onStyleRule = options.onStyleRule, getFlattenedNode = options.getFlattenedNode, disable = options.disable, disableExtraction = options.disableExtraction, disableExtractInlineMedia = options.disableExtractInlineMedia, disableExtractVariables = options.disableExtractVariables, disableDebugAttr = options.disableDebugAttr, _options_enableDynamicEvaluation = options.enableDynamicEvaluation, enableDynamicEvaluation = _options_enableDynamicEvaluation === void 0 ? !1 : _options_enableDynamicEvaluation, _options_includeExtensions = options.includeExtensions, includeExtensions = _options_includeExtensions === void 0 ? [
      ".ts",
      ".tsx",
      ".jsx"
    ] : _options_includeExtensions, _options_extractStyledDefinitions = options.extractStyledDefinitions, extractStyledDefinitions = _options_extractStyledDefinitions === void 0 ? !1 : _options_extractStyledDefinitions, prefixLogs = options.prefixLogs, excludeProps = options.excludeProps, platform2 = options.platform, restProps = _object_without_properties(options, [
      "config",
      "importsWhitelist",
      "evaluateVars",
      "sourcePath",
      "onExtractTag",
      "onStyleRule",
      "getFlattenedNode",
      "disable",
      "disableExtraction",
      "disableExtractInlineMedia",
      "disableExtractVariables",
      "disableDebugAttr",
      "enableDynamicEvaluation",
      "includeExtensions",
      "extractStyledDefinitions",
      "prefixLogs",
      "excludeProps",
      "platform"
    ]);
    if (sourcePath.includes(".tamagui-dynamic-eval"))
      return null;
    var _requireTamaguiCore = requireTamaguiCore(platform2), normalizeStyle = _requireTamaguiCore.normalizeStyle, getSplitStyles = _requireTamaguiCore.getSplitStyles, mediaQueryConfig = _requireTamaguiCore.mediaQueryConfig, propMapper = _requireTamaguiCore.propMapper, proxyThemeVariables = _requireTamaguiCore.proxyThemeVariables, pseudoDescriptors = _requireTamaguiCore.pseudoDescriptors, shouldPrintDebug = options.shouldPrintDebug || !1;
    if (disable === !0 || Array.isArray(disable) && disable.includes(sourcePath))
      return null;
    if (!isFullyDisabled(options) && !components)
      throw new Error("Must provide components");
    if (sourcePath && includeExtensions && !includeExtensions.some(function(ext) {
      return sourcePath.endsWith(ext);
    }))
      return shouldPrintDebug && logger.info("Ignoring file due to includeExtensions: ".concat(sourcePath, ", includeExtensions: ").concat(includeExtensions.join(", "))), null;
    function isValidStyleKey(name, staticConfig) {
      var _staticConfig_validStyles, _staticConfig_variants, _projectInfo_tamaguiConfig;
      if (!projectInfo)
        throw new Error("Tamagui extractor not loaded yet");
      return platform2 === "native" && name[0] === "$" && mediaQueryConfig[name.slice(1)] ? !1 : !!(!((_staticConfig_validStyles = staticConfig.validStyles) === null || _staticConfig_validStyles === void 0) && _staticConfig_validStyles[name] || pseudoDescriptors[name] || !((_staticConfig_variants = staticConfig.variants) === null || _staticConfig_variants === void 0) && _staticConfig_variants[name] || !(projectInfo == null || (_projectInfo_tamaguiConfig = projectInfo.tamaguiConfig) === null || _projectInfo_tamaguiConfig === void 0) && _projectInfo_tamaguiConfig.shorthands[name] || name[0] === "$" && mediaQueryConfig[name.slice(1)]);
    }
    var isTargetingHTML = platform2 === "web", ogDebug = shouldPrintDebug, tm = timer(), propsWithFileInfo = _object_spread_props(_object_spread({}, options), {
      sourcePath,
      allLoadedComponents: components ? _to_consumable_array(components) : []
    });
    if (!hasLoggedBaseInfo) {
      var _process_env_DEBUG;
      hasLoggedBaseInfo = !0, shouldPrintDebug && logger.info([
        "loaded components:",
        propsWithFileInfo.allLoadedComponents.map(function(comp2) {
          return Object.keys(comp2.nameToInfo).join(", ");
        }).join(", ")
      ].join(" ")), !((_process_env_DEBUG = process.env.DEBUG) === null || _process_env_DEBUG === void 0) && _process_env_DEBUG.startsWith("tamagui") && logger.info([
        "loaded:",
        propsWithFileInfo.allLoadedComponents.map(function(x) {
          return x.moduleName;
        })
      ].join(`
`));
    }
    tm.mark("load-tamagui", !!shouldPrintDebug), isFullyDisabled(options) || tamaguiConfig != null && tamaguiConfig.themes || (console.error(`\u26D4\uFE0F Error: Missing "themes" in your tamagui.config file:

            You may not need the compiler! Remember you can run Tamagui with no configuration at all.

            You may have not "export default" your config (you can also "export const config").
            
            Or this may be due to duplicated dependency versions:
              - try out https://github.com/bmish/check-dependency-version-consistency to see if there are mis-matches.
              - or search your lockfile for mis-matches.
          `), console.info("  Got config:", tamaguiConfig), process.exit(0));
    var firstThemeName = Object.keys((tamaguiConfig == null ? void 0 : tamaguiConfig.themes) || {})[0], firstTheme = (tamaguiConfig == null ? void 0 : tamaguiConfig.themes[firstThemeName]) || {};
    if (!firstTheme || typeof firstTheme != "object") {
      var _$err = "Missing theme ".concat(firstThemeName, ", an error occurred when importing your config");
      throw console.info(_$err, "Got config:", tamaguiConfig), console.info("Looking for theme:", firstThemeName), new Error(_$err);
    }
    var proxiedTheme = proxyThemeVariables(firstTheme), themeAccessListeners = /* @__PURE__ */ new Set(), defaultTheme = new Proxy(proxiedTheme, {
      get: function(target, key) {
        return Reflect.has(target, key) && themeAccessListeners.forEach(function(cb) {
          return cb(String(key));
        }), Reflect.get(target, key);
      }
    }), body = fileOrPath.type === "Program" ? fileOrPath.get("body") : fileOrPath.program.body;
    isFullyDisabled(options) || Object.keys(components || []).length === 0 && (console.warn("Warning: Tamagui didn't find any valid components (DEBUG=tamagui for more)"), process.env.DEBUG === "tamagui" && console.info("components", Object.keys(components || []), components)), shouldPrintDebug === "verbose" && (logger.info("allLoadedComponent modules ".concat(propsWithFileInfo.allLoadedComponents.map(function(k) {
      return k.moduleName;
    }).join(", "))), logger.info("valid import paths: ".concat(JSON.stringify(getValidComponentsPaths(propsWithFileInfo)))));
    var doesUseValidImport = !1, hasImportedTheme = !1, importDeclarations = [], _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
    try {
      for (var _loop = function() {
        var bodyPath = _step.value;
        if (bodyPath.type !== "ImportDeclaration") return "continue";
        var node = "node" in bodyPath ? bodyPath.node : bodyPath, moduleName = node.source.value, valid = isValidImport(propsWithFileInfo, moduleName);
        if (valid && importDeclarations.push(node), shouldPrintDebug === "verbose" && logger.info(" - import ".concat(moduleName, " ").concat(valid)), extractStyledDefinitions && valid && node.specifiers.some(function(specifier) {
          return specifier.local.name === "styled";
        }))
          return doesUseValidImport = !0, "break";
        if (valid) {
          var names = node.specifiers.map(function(specifier) {
            return specifier.local.name;
          }), isValidComponent = names.some(function(name) {
            return !!(isValidImport(propsWithFileInfo, moduleName, name) || validHooks[name]);
          });
          if (shouldPrintDebug === "verbose" && logger.info(" - import ".concat(isValidComponent ? "\u2705" : "\u21E3", " - ").concat(names.join(", "), " from '").concat(moduleName, "' - (valid: ").concat(JSON.stringify(getValidComponentsPaths(propsWithFileInfo)), ")")), isValidComponent)
            return doesUseValidImport = !0, "break";
        }
      }, _iterator = body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
        var _ret = _loop();
        if (_ret === "break") break;
      }
    } catch (err) {
      _didIteratorError = !0, _iteratorError = err;
    } finally {
      try {
        !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
      } finally {
        if (_didIteratorError)
          throw _iteratorError;
      }
    }
    if (shouldPrintDebug && logger.info("".concat(JSON.stringify({
      doesUseValidImport,
      hasImportedTheme
    }, null, 2), `
`)), !doesUseValidImport)
      return null;
    function getValidImportedComponent(componentName) {
      var importDeclaration = importDeclarations.find(function(dec) {
        return dec.specifiers.some(function(spec) {
          return spec.local.name === componentName;
        });
      });
      return importDeclaration ? getValidImport(propsWithFileInfo, importDeclaration.source.value, componentName) : null;
    }
    tm.mark("import-check", !!shouldPrintDebug);
    var couldntParse = !1, modifiedComponents = /* @__PURE__ */ new Set(), bindingCache = {}, callTraverse = function(a) {
      return fileOrPath.type === "File" ? traverse(fileOrPath, a) : fileOrPath.traverse(a);
    }, shouldDisableExtraction = disableExtraction === !0 || Array.isArray(disableExtraction) && disableExtraction.includes(sourcePath), programPath = null, res = {
      styled: 0,
      flattened: 0,
      optimized: 0,
      modified: 0,
      found: 0
    }, version = "".concat(Math.random());
    if (callTraverse({
      // @ts-ignore
      Program: {
        enter: function(path) {
          programPath = path;
        }
      },
      // styled() calls
      CallExpression: function(path) {
        if (!(disable || shouldDisableExtraction || extractStyledDefinitions === !1) && !(!t.isIdentifier(path.node.callee) || path.node.callee.name !== "styled")) {
          var variableName = t.isVariableDeclarator(path.parent) && t.isIdentifier(path.parent.id) ? path.parent.id.name : "unknown", parentNode = path.node.arguments[0];
          if (t.isIdentifier(parentNode)) {
            var parentName = parentNode.name, definition = path.node.arguments[1];
            if (!(!parentName || !definition || !t.isObjectExpression(definition))) {
              var Component = getValidImportedComponent(variableName);
              if (!Component) {
                if (enableDynamicEvaluation !== !0)
                  return;
                try {
                  shouldPrintDebug && logger.info("Unknown component: ".concat(variableName, " = styled(").concat(parentName, ") attempting dynamic load: ").concat(sourcePath));
                  var out = loadTamaguiSync({
                    forceExports: !0,
                    components: [
                      sourcePath
                    ],
                    cacheKey: version
                  });
                  if (!(out != null && out.components)) {
                    shouldPrintDebug && logger.info("Couldn't load, got ".concat(out));
                    return;
                  }
                  if (propsWithFileInfo.allLoadedComponents = _to_consumable_array(propsWithFileInfo.allLoadedComponents).concat(_to_consumable_array(out.components)), Component = out.components.flatMap(function(x) {
                    var _x_nameToInfo_variableName;
                    return (_x_nameToInfo_variableName = x.nameToInfo[variableName]) !== null && _x_nameToInfo_variableName !== void 0 ? _x_nameToInfo_variableName : [];
                  })[0], !out.cached) {
                    var _out_components, foundNames = (_out_components = out.components) === null || _out_components === void 0 ? void 0 : _out_components.map(function(x) {
                      return Object.keys(x.nameToInfo).join(", ");
                    }).join(", ").trim();
                    foundNames && colorLog(Color.FgYellow, "      | Tamagui found dynamic components: ".concat(foundNames));
                  }
                } catch {
                  shouldPrintDebug && logger.info("skip optimize styled(".concat(variableName, "), unable to pre-process (DEBUG=tamagui for more)"));
                }
              }
              if (!Component) {
                shouldPrintDebug && logger.info(" No component found");
                return;
              }
              var componentSkipProps = new Set(_to_consumable_array(Component.staticConfig.inlineWhenUnflattened || []).concat(_to_consumable_array(Component.staticConfig.inlineProps || []), [
                // for now skip variants, will return to them
                "variants",
                "defaultVariants",
                // skip fontFamily its basically a "variant", important for theme use to be value always
                "fontFamily",
                "name",
                "focusStyle",
                "focusVisibleStyle",
                "disabledStyle",
                "hoverStyle",
                "pressStyle"
              ])), skipped = /* @__PURE__ */ new Set(), styles = {}, staticNamespace = getStaticBindingsForScope(path.scope, importsWhitelist, sourcePath, bindingCache, shouldPrintDebug), attemptEval = evaluateVars ? createEvaluator({
                props: propsWithFileInfo,
                staticNamespace,
                sourcePath,
                shouldPrintDebug
              }) : evaluateAstNode, attemptEvalSafe = createSafeEvaluator(attemptEval), _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
              try {
                for (var _iterator2 = definition.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
                  var property = _step2.value, _Component_staticConfig_variants;
                  if (!t.isObjectProperty(property) || !t.isIdentifier(property.key) || !isValidStyleKey(property.key.name, Component.staticConfig) || // TODO make pseudos and variants work
                  // skip pseudos
                  pseudoDescriptors[property.key.name] || !((_Component_staticConfig_variants = Component.staticConfig.variants) === null || _Component_staticConfig_variants === void 0) && _Component_staticConfig_variants[property.key.name] || componentSkipProps.has(property.key.name)) {
                    skipped.add(property);
                    continue;
                  }
                  var out1 = attemptEvalSafe(property.value);
                  out1 === FAILED_EVAL ? skipped.add(property) : styles[property.key.name] = out1;
                }
              } catch (err) {
                _didIteratorError2 = !0, _iteratorError2 = err;
              } finally {
                try {
                  !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
                } finally {
                  if (_didIteratorError2)
                    throw _iteratorError2;
                }
              }
              var out2 = getSplitStyles(styles, Component.staticConfig, defaultTheme, "", componentState, styleProps, void 0, void 0, void 0, shouldPrintDebug), classNames = _object_spread({}, out2.classNames);
              if (shouldPrintDebug && logger.info([
                "Extracted styled(".concat(variableName, `)
`),
                JSON.stringify(styles, null, 2),
                `
 classNames:`,
                JSON.stringify(classNames, null, 2),
                `
  rulesToInsert:`,
                out2.rulesToInsert.flatMap(function(styleObject2) {
                  return styleObject2[StyleObjectRules];
                }).join(`
`)
              ].join(" ")), definition.properties = definition.properties.map(function(prop) {
                if (skipped.has(prop) || !t.isObjectProperty(prop) || !t.isIdentifier(prop.key))
                  return prop;
                var key = prop.key.name, value = classNames[key];
                return value ? t.objectProperty(t.stringLiteral(key), t.stringLiteral(value)) : prop;
              }), out2.rulesToInsert) {
                var _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
                try {
                  for (var _iterator12 = out2.rulesToInsert[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = !0) {
                    var styleObject = _step12.value;
                    onStyleRule == null || onStyleRule(styleObject[StyleObjectIdentifier], styleObject[StyleObjectRules]);
                  }
                } catch (err) {
                  _didIteratorError12 = !0, _iteratorError12 = err;
                } finally {
                  try {
                    !_iteratorNormalCompletion12 && _iterator12.return != null && _iterator12.return();
                  } finally {
                    if (_didIteratorError12)
                      throw _iteratorError12;
                  }
                }
              }
              res.styled++, shouldPrintDebug && logger.info("Extracted styled(".concat(variableName, ")"));
            }
          }
        }
      },
      JSXElement: function(traversePath) {
        tm.mark("jsx-element", !!shouldPrintDebug);
        var node = traversePath.node.openingElement, ogAttributes = node.attributes.map(function(attr3) {
          return _object_spread({}, attr3);
        }), componentName = findComponentName(traversePath.scope), closingElement = traversePath.node.closingElement;
        if (closingElement && t.isJSXMemberExpression(closingElement == null ? void 0 : closingElement.name) || !t.isJSXIdentifier(node.name)) {
          shouldPrintDebug && logger.info(" skip non-identifier element");
          return;
        }
        var binding = traversePath.scope.getBinding(node.name.name), moduleName = "";
        if (binding && t.isImportDeclaration(binding.path.parent) && (moduleName = binding.path.parent.source.value, !isValidImport(propsWithFileInfo, moduleName, binding.identifier.name))) {
          shouldPrintDebug && logger.info(" - Binding in component ".concat(componentName, ' not valid import: "').concat(binding.identifier.name, `" isn't in `).concat(moduleName, `
`));
          return;
        }
        var component = getValidComponent(propsWithFileInfo, moduleName, node.name.name);
        if (!component || !component.staticConfig) {
          shouldPrintDebug && logger.info(`
 - No Tamagui conf for: `.concat(node.name.name, `
`));
          return;
        }
        var originalNodeName = node.name.name;
        res.found++;
        var filePath = "./".concat(relative(process.cwd(), sourcePath)), lineNumbers = node.loc ? node.loc.start.line + (node.loc.start.line !== node.loc.end.line ? "-".concat(node.loc.end.line) : "") : "", codePosition = "".concat(filePath, ":").concat(lineNumbers), debugPropValue = node.attributes.filter(function(n) {
          return t.isJSXAttribute(n) && t.isJSXIdentifier(n.name) && n.name.name === "debug";
        }).map(function(n) {
          return n.value === null ? !0 : t.isStringLiteral(n.value) ? n.value.value : !1;
        })[0];
        if (debugPropValue && (shouldPrintDebug = debugPropValue), shouldPrintDebug && (logger.info("\x1B[33m\x1B[0m " + "".concat(componentName, " | ").concat(codePosition, " -------------------")), logger.info([
          "\x1B[1m",
          "\x1B[32m",
          "<".concat(originalNodeName, " />"),
          disableDebugAttr ? "" : "\u{1F41B}"
        ].join(" "))), shouldAddDebugProp && !disableDebugAttr && (res.modified++, node.attributes.unshift(t.jsxAttribute(t.jsxIdentifier("data-is"), t.stringLiteral(node.name.name))), componentName && node.attributes.unshift(t.jsxAttribute(t.jsxIdentifier("data-in"), t.stringLiteral(componentName))), node.attributes.unshift(t.jsxAttribute(t.jsxIdentifier("data-at"), t.stringLiteral("".concat(basename(filePath), ":").concat(lineNumbers))))), shouldDisableExtraction) {
          shouldPrintDebug === "verbose" && logger.info(" \u274C Extraction disabled: ".concat(JSON.stringify(disableExtraction), `
`));
          return;
        }
        try {
          let createTernariesFromObjectProperties2 = function(test, side) {
            var ternaryPartial = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (!side)
              return null;
            if (!isStaticObject(side))
              throw new Error("not extractable");
            return side.properties.flatMap(function(property) {
              if (!t.isObjectProperty(property))
                throw new Error("expected object property");
              if (t.isIdentifier(property.key)) {
                var key9 = property.key.name, mediaQueryKey = key9.slice(1), isMediaQuery = key9[0] === "$" && mediaQueryConfig[mediaQueryKey];
                if (isMediaQuery)
                  if (t.isExpression(property.value)) {
                    var ternaries2 = createTernariesFromObjectProperties2(t.stringLiteral(mediaQueryKey), property.value, {
                      inlineMediaQuery: mediaQueryKey
                    });
                    if (ternaries2)
                      return ternaries2.map(function(value2) {
                        return _object_spread_props(_object_spread({}, ternaryPartial, value2), {
                          // ensure media query test stays on left side (see getMediaQueryTernary)
                          test: t.logicalExpression("&&", value2.test, test)
                        });
                      });
                    logger.info([
                      "\u26A0\uFE0F no ternaries?",
                      property
                    ].join(" "));
                  } else
                    logger.info([
                      "\u26A0\uFE0F not expression",
                      property
                    ].join(" "));
              }
              if (t.isConditionalExpression(property.value)) {
                var _map = _sliced_to_array([
                  t.objectExpression([
                    t.objectProperty(property.key, property.value.consequent)
                  ]),
                  t.objectExpression([
                    t.objectProperty(property.key, property.value.alternate)
                  ])
                ].map(function(x) {
                  return attemptEval(x);
                }), 2), truthy = _map[0], falsy = _map[1];
                return [
                  createTernary(_object_spread_props(_object_spread({
                    remove: function() {
                    }
                  }, ternaryPartial), {
                    test: t.logicalExpression("&&", test, property.value.test),
                    consequent: truthy,
                    alternate: null
                  })),
                  createTernary(_object_spread_props(_object_spread({}, ternaryPartial), {
                    test: t.logicalExpression("&&", test, t.unaryExpression("!", property.value.test)),
                    consequent: falsy,
                    alternate: null,
                    remove: function() {
                    }
                  }))
                ];
              }
              var obj = t.objectExpression([
                t.objectProperty(property.key, property.value)
              ]), consequent = attemptEval(obj);
              return createTernary(_object_spread_props(_object_spread({
                remove: function() {
                }
              }, ternaryPartial), {
                test,
                consequent,
                alternate: null
              }));
            });
          };
          var createTernariesFromObjectProperties = createTernariesFromObjectProperties2, evaluateAttribute = (
            // START function evaluateAttribute
            function(path) {
              var attribute = path.node, attr3 = {
                type: "attr",
                value: attribute
              };
              if (t.isJSXSpreadAttribute(attribute)) {
                var arg = attribute.argument, conditional = t.isConditionalExpression(arg) ? (
                  // <YStack {...isSmall ? { color: 'red } : { color: 'blue }}
                  [
                    arg.test,
                    arg.consequent,
                    arg.alternate
                  ]
                ) : t.isLogicalExpression(arg) && arg.operator === "&&" ? (
                  // <YStack {...isSmall && { color: 'red }}
                  [
                    arg.left,
                    arg.right,
                    null
                  ]
                ) : null;
                if (conditional) {
                  var _conditional = _sliced_to_array(conditional, 3), test = _conditional[0], alt = _conditional[1], cons = _conditional[2];
                  if (!test) throw new Error("no test");
                  return [
                    alt,
                    cons
                  ].some(function(side) {
                    return side && !isStaticObject(side);
                  }) ? (shouldPrintDebug && logger.info("not extractable ".concat(alt, " ").concat(cons)), attr3) : _to_consumable_array(createTernariesFromObjectProperties2(test, alt) || []).concat(_to_consumable_array(cons && createTernariesFromObjectProperties2(t.unaryExpression("!", test), cons) || [])).map(function(ternary2) {
                    return {
                      type: "ternary",
                      value: ternary2
                    };
                  });
                }
              }
              if (t.isJSXSpreadAttribute(attribute) || !attribute.name || typeof attribute.name.name != "string")
                return shouldPrintDebug && logger.info("  ! inlining, spread attr"), inlined.set("".concat(Math.random()), "spread"), attr3;
              var name2 = attribute.name.name;
              if (excludeProps != null && excludeProps.has(name2))
                return shouldPrintDebug && logger.info([
                  "  excluding prop",
                  name2
                ].join(" ")), null;
              if (inlineProps.has(name2))
                return inlined.set(name2, name2), shouldPrintDebug && logger.info([
                  "  ! inlining, inline prop",
                  name2
                ].join(" ")), attr3;
              if (UNTOUCHED_PROPS[name2])
                return attr3;
              if (INLINE_EXTRACTABLE[name2])
                return inlined.set(name2, INLINE_EXTRACTABLE[name2]), attr3;
              if (name2.startsWith("data-"))
                return attr3;
              if (name2[0] === "$" && t.isJSXExpressionContainer(attribute == null ? void 0 : attribute.value)) {
                var shortname = name2.slice(1);
                if (mediaQueryConfig[shortname]) {
                  if (platform2 === "native" && (shouldDeopt = !0), disableExtractInlineMedia)
                    return attr3;
                  var expression = attribute.value.expression;
                  if (!t.isJSXEmptyExpression(expression)) {
                    var ternaries2 = createTernariesFromObjectProperties2(t.stringLiteral(shortname), expression, {
                      inlineMediaQuery: shortname
                    });
                    if (ternaries2)
                      return ternaries2.map(function(value3) {
                        return {
                          type: "ternary",
                          value: value3
                        };
                      });
                  }
                }
              }
              var _ref2 = _sliced_to_array(function() {
                return t.isJSXExpressionContainer(attribute == null ? void 0 : attribute.value) ? [
                  attribute.value.expression,
                  path.get("value")
                ] : [
                  attribute.value,
                  path.get("value")
                ];
              }(), 2), value2 = _ref2[0], valuePath = _ref2[1], remove = function() {
                Array.isArray(valuePath) ? valuePath.map(function(p) {
                  return p.remove();
                }) : valuePath.remove();
              };
              if (name2 === "ref")
                return shouldPrintDebug && logger.info([
                  "  ! inlining, ref",
                  name2
                ].join(" ")), inlined.set("ref", "ref"), attr3;
              if (name2 === "tag")
                return {
                  type: "attr",
                  value: path.node
                };
              if (disableExtractVariables === !0 && value2 && value2.type === "StringLiteral" && value2.value[0] === "$")
                return shouldPrintDebug && logger.info([
                  "  ! inlining, native disable extract: ".concat(name2, " ="),
                  value2.value
                ].join(" ")), inlined.set(name2, !0), attr3;
              if (name2 === "theme")
                return inlined.set("theme", attr3.value), attr3;
              var styleValue = attemptEvalSafe(value2);
              if (!variants[name2] && !isValidStyleKey(name2, staticConfig)) {
                var keys = [
                  name2
                ], out = null;
                out = propMapper(name2, styleValue, propMapperStyleState), out && (Array.isArray(out) ? (out = Object.fromEntries(out), keys = Object.keys(out)) : (logger.warn("Error expected array but got", out), couldntParse = !0, shouldDeopt = !0)), out && (isTargetingHTML && (out = reactNativeWebInternals.createDOMProps(isTextView ? "span" : "div", out), delete out.className), keys = Object.keys(out));
                var didInline = !1, attributes = keys.map(function(key9) {
                  var val2 = out[key9], isStyle = isValidStyleKey(key9, staticConfig);
                  return isStyle ? {
                    type: "style",
                    value: _define_property({}, key9, styleValue),
                    name: key9,
                    attr: path.node
                  } : validHTMLAttributes[key9] || key9.startsWith("aria-") || key9.startsWith("data-") || // this is debug stuff added by vite / new jsx transform
                  key9 === "__source" || key9 === "__self" ? attr3 : (shouldPrintDebug && logger.info("  ! inlining, non-static " + key9), didInline = !0, inlined.set(key9, val2), val2);
                });
                return didInline ? (shouldPrintDebug && logger.info("  bailing flattening due to attributes ".concat(attributes.map(function(x) {
                  return x.toString();
                }))), attr3) : attributes;
              }
              if (styleValue !== FAILED_EVAL)
                return inlineWhenUnflattened.has(name2) && (inlineWhenUnflattenedOGVals[name2] = {
                  styleValue,
                  attr: attr3
                }), isValidStyleKey(name2, staticConfig) ? (shouldPrintDebug && logger.info("  style: ".concat(name2, " = ").concat(styleValue)), name2 in defaultProps || hasSetOptimized || (res.optimized++, hasSetOptimized = !0), {
                  type: "style",
                  value: _define_property({}, name2, styleValue),
                  name: name2,
                  attr: path.node
                }) : (variants[name2] && variantValues.set(name2, styleValue), inlined.set(name2, !0), attr3);
              if (t.isBinaryExpression(value2)) {
                shouldPrintDebug && logger.info(" binary expression ".concat(name2, " = ").concat(value2));
                var operator = value2.operator, left = value2.left, right = value2.right, lVal = attemptEvalSafe(left), rVal = attemptEvalSafe(right);
                if (shouldPrintDebug && logger.info("  evalBinaryExpression lVal ".concat(String(lVal), ", rVal ").concat(String(rVal))), lVal !== FAILED_EVAL && t.isConditionalExpression(right)) {
                  var ternary = addBinaryConditional(operator, left, right);
                  if (ternary) return ternary;
                }
                if (rVal !== FAILED_EVAL && t.isConditionalExpression(left)) {
                  var ternary1 = addBinaryConditional(operator, right, left);
                  if (ternary1) return ternary1;
                }
                return shouldPrintDebug && logger.info("  evalBinaryExpression cant extract"), inlined.set(name2, !0), attr3;
              }
              var staticConditional = getStaticConditional(value2);
              if (staticConditional)
                return shouldPrintDebug === "verbose" && logger.info(" static conditional ".concat(name2, " ").concat(value2)), {
                  type: "ternary",
                  value: staticConditional
                };
              var staticLogical = getStaticLogical(value2);
              if (staticLogical)
                return shouldPrintDebug === "verbose" && logger.info(" static ternary ".concat(name2, " =  ").concat(value2)), {
                  type: "ternary",
                  value: staticLogical
                };
              if (options.experimentalFlattenDynamicValues && isValidStyleKey(name2, staticConfig))
                return {
                  type: "dynamic-style",
                  value: value2,
                  name: (tamaguiConfig == null ? void 0 : tamaguiConfig.shorthands[name2]) || name2
                };
              return inlined.set(name2, !0), shouldPrintDebug && logger.info(" ! inline no match ".concat(name2, " ").concat(value2)), attr3;
              function addBinaryConditional(operator2, staticExpr, cond) {
                if (getStaticConditional(cond)) {
                  var alt2 = attemptEval(t.binaryExpression(operator2, staticExpr, cond.alternate)), cons2 = attemptEval(t.binaryExpression(operator2, staticExpr, cond.consequent));
                  return shouldPrintDebug && logger.info([
                    "  binaryConditional",
                    cond.test,
                    cons2,
                    alt2
                  ].join(" ")), {
                    type: "ternary",
                    value: {
                      test: cond.test,
                      remove,
                      alternate: _define_property({}, name2, alt2),
                      consequent: _define_property({}, name2, cons2)
                    }
                  };
                }
                return null;
              }
              function getStaticConditional(value3) {
                if (t.isConditionalExpression(value3))
                  try {
                    var aVal = attemptEval(value3.alternate), cVal = attemptEval(value3.consequent);
                    if (shouldPrintDebug) {
                      var type = value3.test.type;
                      logger.info([
                        "      static ternary",
                        type,
                        cVal,
                        aVal
                      ].join(" "));
                    }
                    return {
                      test: value3.test,
                      remove,
                      consequent: _define_property({}, name2, cVal),
                      alternate: _define_property({}, name2, aVal)
                    };
                  } catch (err) {
                    shouldPrintDebug && logger.info([
                      "       cant eval ternary",
                      err.message
                    ].join(" "));
                  }
                return null;
              }
              function getStaticLogical(value3) {
                if (t.isLogicalExpression(value3) && value3.operator === "&&")
                  try {
                    var val2 = attemptEval(value3.right);
                    return shouldPrintDebug && logger.info([
                      "  staticLogical",
                      value3.left,
                      name2,
                      val2
                    ].join(" ")), {
                      test: value3.left,
                      remove,
                      consequent: _define_property({}, name2, val2),
                      alternate: null
                    };
                  } catch (err) {
                    shouldPrintDebug && logger.info([
                      "  cant static eval logical",
                      err
                    ].join(" "));
                  }
                return null;
              }
            }
          ), isStaticObject = (
            // END function evaluateAttribute
            function(obj) {
              return t.isObjectExpression(obj) && obj.properties.every(function(prop) {
                if (!t.isObjectProperty(prop))
                  return logger.info([
                    "not object prop",
                    prop
                  ].join(" ")), !1;
                var propName = prop.key.name;
                return !isValidStyleKey(propName, staticConfig) && propName !== "tag" ? (shouldPrintDebug && logger.info([
                  "  not a valid style prop!",
                  propName
                ].join(" ")), !1) : !0;
              });
            }
          ), mergeToEnd = function(obj, key9, val2) {
            key9 in obj && delete obj[key9], obj[key9] = val2;
          }, normalizeStyleWithoutVariants = (
            // preserves order
            function(style) {
              var res2 = {};
              for (var key9 in style)
                if (staticConfig.variants && key9 in staticConfig.variants)
                  mergeToEnd(res2, key9, style[key9]);
                else {
                  var expanded2 = normalizeStyle(_define_property({}, key9, style[key9]), !0);
                  for (var key12 in expanded2)
                    mergeToEnd(res2, key12, expanded2[key12]);
                }
              return res2;
            }
          ), mergeStyles = function(prev2, next) {
            for (var key9 in next)
              pseudoDescriptors[key9] ? (prev2[key9] = prev2[key9] || {}, Object.assign(prev2[key9], next[key9])) : mergeToEnd(prev2, key9, next[key9]);
          }, staticConfig = component.staticConfig, defaultProps = _object_spread({}, staticConfig.defaultProps || {}), variants = staticConfig.variants || {}, isTextView = staticConfig.isText || !1, _staticConfig_validStyles, validStyles = (_staticConfig_validStyles = staticConfig == null ? void 0 : staticConfig.validStyles) !== null && _staticConfig_validStyles !== void 0 ? _staticConfig_validStyles : {}, _defaultProps_tag, tagName = (_defaultProps_tag = defaultProps.tag) !== null && _defaultProps_tag !== void 0 ? _defaultProps_tag : isTextView ? "span" : "div";
          traversePath.get("openingElement").get("attributes").forEach(function(path) {
            var attr3 = path.node;
            if (!t.isJSXSpreadAttribute(attr3) && attr3.name.name === "tag") {
              var val2 = attr3.value;
              t.isStringLiteral(val2) && (tagName = val2.value);
            }
          }), shouldPrintDebug === "verbose" && console.info(" Start tag ".concat(tagName));
          var flatNode = getFlattenedNode == null ? void 0 : getFlattenedNode({
            isTextView,
            tag: tagName
          }), inlineProps = new Set([
            // adding some always inline props
            "dataSet"
          ].concat(_to_consumable_array(restProps.inlineProps || []), _to_consumable_array(staticConfig.inlineProps || []))), deoptProps = new Set([
            // always de-opt animation these
            "animation",
            "animateOnly",
            "animatePresence",
            "disableOptimization"
          ].concat(
            _to_consumable_array(isTargetingHTML ? [] : [
              "pressStyle",
              "focusStyle",
              "focusVisibleStyle",
              "disabledStyle"
            ]),
            // when using a non-CSS driver, de-opt on enterStyle/exitStyle
            _to_consumable_array(tamaguiConfig != null && tamaguiConfig.animations.isReactNative ? [
              "enterStyle",
              "exitStyle"
            ] : [])
          )), inlineWhenUnflattened = new Set(_to_consumable_array(staticConfig.inlineWhenUnflattened || [])), staticNamespace = getStaticBindingsForScope(traversePath.scope, importsWhitelist, sourcePath, bindingCache, shouldPrintDebug), attemptEval = evaluateVars ? createEvaluator({
            props: propsWithFileInfo,
            staticNamespace,
            sourcePath,
            traversePath,
            shouldPrintDebug
          }) : evaluateAstNode, attemptEvalSafe = createSafeEvaluator(attemptEval);
          if (shouldPrintDebug && logger.info("  staticNamespace ".concat(Object.keys(staticNamespace).join(", "))), couldntParse)
            return;
          tm.mark("jsx-element-flattened", !!shouldPrintDebug);
          var attrs = [], shouldDeopt = !1, inlined = /* @__PURE__ */ new Map(), variantValues = /* @__PURE__ */ new Map(), hasSetOptimized = !1, inlineWhenUnflattenedOGVals = {}, propMapperStyleState = {
            staticConfig,
            usedKeys: {},
            classNames: {},
            style: {},
            theme: defaultTheme,
            viewProps: defaultProps,
            conf: tamaguiConfig,
            curProps: defaultProps,
            props: defaultProps,
            componentState,
            styleProps: _object_spread_props(_object_spread({}, styleProps), {
              resolveValues: "auto"
            }),
            debug: shouldPrintDebug
          };
          if (attrs = traversePath.get("openingElement").get("attributes").flatMap(function(path) {
            try {
              var res2 = evaluateAttribute(path);
              return tm.mark("jsx-element-evaluate-attr", !!shouldPrintDebug), res2 || path.remove(), res2;
            } catch (err) {
              if (shouldPrintDebug && (logger.info([
                "Recoverable error extracting attribute",
                err.message,
                shouldPrintDebug === "verbose" ? err.stack : ""
              ].join(" ")), shouldPrintDebug === "verbose")) {
                var _path_node;
                logger.info("node ".concat((_path_node = path.node) === null || _path_node === void 0 ? void 0 : _path_node.type));
              }
              return inlined.set("".concat(Math.random()), "spread"), {
                type: "attr",
                value: path.node
              };
            }
          }).flat(4).filter(isPresent), shouldPrintDebug && logger.info([
            `  - attrs (before):
`,
            logLines(attrs.map(attrStr).join(", "))
          ].join(" ")), couldntParse || shouldDeopt) {
            shouldPrintDebug && logger.info([
              "  avoid optimizing:",
              {
                couldntParse,
                shouldDeopt
              }
            ].join(" ")), node.attributes = ogAttributes;
            return;
          }
          var parentFn = findTopmostFunction(traversePath);
          parentFn && modifiedComponents.add(parentFn);
          var hasSpread = attrs.some(function(x) {
            return x.type === "attr" && t.isJSXSpreadAttribute(x.value);
          }), hasOnlyStringChildren = !hasSpread && (node.selfClosing || traversePath.node.children && traversePath.node.children.every(function(x) {
            return x.type === "JSXText";
          })), themeVal = inlined.get("theme");
          platform2 !== "native" && inlined.delete("theme");
          var _iteratorNormalCompletion2 = !0, _didIteratorError2 = !1, _iteratorError2 = void 0;
          try {
            for (var _iterator2 = _to_consumable_array(inlined)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = !0) {
              var _step_value = _sliced_to_array(_step2.value, 1), key = _step_value[0], _staticConfig_variants, isStaticObjectVariant = ((_staticConfig_variants = staticConfig.variants) === null || _staticConfig_variants === void 0 ? void 0 : _staticConfig_variants[key]) && variantValues.has(key);
              (INLINE_EXTRACTABLE[key] || isStaticObjectVariant) && inlined.delete(key);
            }
          } catch (err) {
            _didIteratorError2 = !0, _iteratorError2 = err;
          } finally {
            try {
              !_iteratorNormalCompletion2 && _iterator2.return != null && _iterator2.return();
            } finally {
              if (_didIteratorError2)
                throw _iteratorError2;
            }
          }
          var canFlattenProps = inlined.size === 0, shouldFlatten = !!(flatNode && !shouldDeopt && canFlattenProps && !hasSpread && !staticConfig.isStyledHOC && !staticConfig.isHOC && !staticConfig.isReactNative && staticConfig.neverFlatten !== !0 && (staticConfig.neverFlatten !== "jsx" || hasOnlyStringChildren)), usedThemeKeys = /* @__PURE__ */ new Set();
          if (themeAccessListeners.add(function(key9) {
            disableExtractVariables && (usedThemeKeys.add(key9), shouldFlatten = !1, shouldPrintDebug === "verbose" && logger.info([
              " ! accessing theme key, avoid flatten",
              key9
            ].join(" ")));
          }), shouldFlatten) {
            var skipMap = !1, defaultStyleAttrs = Object.keys(defaultProps).flatMap(function(key9) {
              if (skipMap) return [];
              var value2 = defaultProps[key9];
              if (key9 === "theme" && !themeVal)
                return platform2 === "native" && (shouldFlatten = !1, skipMap = !0, inlined.set("theme", {
                  value: t.stringLiteral(value2)
                })), themeVal = {
                  value: t.stringLiteral(value2)
                }, [];
              if (!isValidStyleKey(key9, staticConfig))
                return [];
              var name2 = (tamaguiConfig == null ? void 0 : tamaguiConfig.shorthands[key9]) || key9;
              if (value2 === void 0) {
                logger.warn("\u26A0\uFE0F Error evaluating default style for component, prop ".concat(key9, " ").concat(value2)), shouldDeopt = !0;
                return;
              }
              if (name2[0] === "$" && mediaQueryConfig[name2.slice(1)])
                return defaultProps[key9] = void 0, evaluateAttribute({
                  node: t.jsxAttribute(t.jsxIdentifier(name2), t.jsxExpressionContainer(t.objectExpression(Object.keys(value2).filter(function(k) {
                    return typeof value2[k] < "u";
                  }).map(function(k) {
                    return t.objectProperty(t.identifier(k), literalToAst(value2[k]));
                  }))))
                });
              var attr3 = {
                type: "style",
                name: name2,
                value: _define_property({}, name2, value2)
              };
              return attr3;
            });
            skipMap || defaultStyleAttrs.length && (attrs = _to_consumable_array(defaultStyleAttrs).concat(_to_consumable_array(attrs)));
          }
          var ternaries = [];
          attrs = attrs.reduce(function(out, cur2) {
            var next = attrs[attrs.indexOf(cur2) + 1];
            if (cur2.type === "ternary" && ternaries.push(cur2.value), (!next || next.type !== "ternary") && ternaries.length) {
              var normalized = normalizeTernaries(ternaries).map(function(_param) {
                var alternate = _param.alternate, consequent = _param.consequent, rest = _object_without_properties(_param, [
                  "alternate",
                  "consequent"
                ]);
                return {
                  type: "ternary",
                  value: _object_spread_props(_object_spread({}, rest), {
                    alternate: alternate || null,
                    consequent: consequent || null
                  })
                };
              });
              try {
                return _to_consumable_array(out).concat(_to_consumable_array(normalized));
              } finally {
                shouldPrintDebug && logger.info("    normalizeTernaries (".concat(ternaries.length, " => ").concat(normalized.length, ")")), ternaries = [];
              }
            }
            return cur2.type === "ternary" || out.push(cur2), out;
          }, []).flat();
          var shouldWrapTheme = shouldFlatten && themeVal;
          if (shouldWrapTheme && (programPath ? (shouldPrintDebug && logger.info([
            "  - wrapping theme",
            themeVal
          ].join(" ")), attrs = attrs.filter(function(x) {
            return !(x.type === "attr" && t.isJSXAttribute(x.value) && x.value.name.name === "theme");
          }), hasImportedTheme || (hasImportedTheme = !0, programPath.node.body.push(t.importDeclaration([
            t.importSpecifier(t.identifier("_TamaguiTheme"), t.identifier("Theme"))
          ], t.stringLiteral("@tamagui/web")))), traversePath.replaceWith(t.jsxElement(t.jsxOpeningElement(t.jsxIdentifier("_TamaguiTheme"), [
            t.jsxAttribute(t.jsxIdentifier("name"), themeVal.value)
          ]), t.jsxClosingElement(t.jsxIdentifier("_TamaguiTheme")), [
            traversePath.node
          ]))) : console.warn("No program path found, avoiding importing flattening / importing theme in ".concat(sourcePath))), shouldPrintDebug)
            try {
              logger.info([
                " flatten?",
                shouldFlatten,
                objToStr({
                  hasSpread,
                  shouldDeopt,
                  canFlattenProps,
                  shouldWrapTheme,
                  hasOnlyStringChildren
                }),
                "inlined",
                inlined.size,
                _to_consumable_array(inlined)
              ].join(" "));
            } catch {
            }
          if (shouldDeopt || !shouldFlatten) {
            shouldPrintDebug && logger.info("Deopting ".concat(shouldDeopt, " ").concat(shouldFlatten)), node.attributes = ogAttributes;
            return;
          }
          shouldPrintDebug && logger.info([
            `  - attrs (flattened): 
`,
            logLines(attrs.map(attrStr).join(", "))
          ].join(" "));
          var foundStaticProps = {};
          for (var key1 in attrs) {
            var cur = attrs[key1];
            if (cur.type === "style") {
              var expanded = normalizeStyleWithoutVariants(cur.value);
              for (var key2 in expanded)
                mergeToEnd(foundStaticProps, key2, expanded[key2]);
              continue;
            }
            if (cur.type === "attr") {
              if (t.isJSXSpreadAttribute(cur.value) || !t.isJSXIdentifier(cur.value.name))
                continue;
              var key3 = cur.value.name.name, value = attemptEvalSafe(cur.value.value || t.booleanLiteral(!0));
              value !== FAILED_EVAL && mergeToEnd(foundStaticProps, key3, value);
            }
          }
          var completeProps = {};
          for (var key4 in defaultProps)
            key4 in foundStaticProps || (completeProps[key4] = defaultProps[key4]);
          for (var key5 in foundStaticProps)
            completeProps[key5] = foundStaticProps[key5];
          attrs = attrs.reduce(function(acc, cur2) {
            if (!cur2) return acc;
            if (cur2.type === "attr" && !t.isJSXSpreadAttribute(cur2.value) && shouldFlatten) {
              var name2 = cur2.value.name.name;
              if (typeof name2 == "string") {
                if (name2 === "tag")
                  return acc;
                if (variants[name2] && variantValues.has(name2)) {
                  var styleState = _object_spread_props(_object_spread({}, propMapperStyleState), {
                    props: completeProps,
                    curProps: completeProps
                  }), out = Object.fromEntries(propMapper(name2, variantValues.get(name2), styleState) || []);
                  if (out && isTargetingHTML) {
                    var cn = out.className;
                    out = reactNativeWebInternals.createDOMProps(isTextView ? "span" : "div", out), out.className = cn;
                  }
                  shouldPrintDebug && logger.info([
                    " - expanded variant",
                    name2,
                    out
                  ].join(" "));
                  for (var key9 in out) {
                    var value2 = out[key9];
                    isValidStyleKey(key9, staticConfig) ? acc.push({
                      type: "style",
                      value: _define_property({}, key9, value2),
                      name: key9,
                      attr: cur2.value
                    }) : acc.push({
                      type: "attr",
                      value: t.jsxAttribute(t.jsxIdentifier(key9), t.jsxExpressionContainer(typeof value2 == "string" ? t.stringLiteral(value2) : literalToAst(value2)))
                    });
                  }
                }
              }
            }
            if (cur2.type !== "style")
              return acc.push(cur2), acc;
            var key12 = Object.keys(cur2.value)[0], value12 = cur2.value[key12], fullKey = tamaguiConfig == null ? void 0 : tamaguiConfig.shorthands[key12];
            return fullKey && (cur2.value = _define_property({}, fullKey, value12), key12 = fullKey), disableExtractVariables && value12[0] === "$" && (usedThemeKeys.has(key12) || usedThemeKeys.has(fullKey)) ? (shouldPrintDebug && logger.info([
              "   keeping variable inline: ".concat(key12, " ="),
              value12
            ].join(" ")), acc.push({
              type: "attr",
              value: t.jsxAttribute(t.jsxIdentifier(key12), t.jsxExpressionContainer(t.stringLiteral(value12)))
            }), acc) : (acc.push(cur2), acc);
          }, []), tm.mark("jsx-element-expanded", !!shouldPrintDebug), shouldPrintDebug && logger.info([
            `  - attrs (expanded): 
`,
            logLines(attrs.map(attrStr).join(", "))
          ].join(" "));
          var prev = null, getProps = function(props) {
            var includeProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, debugName = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
            if (!props)
              return shouldPrintDebug && logger.info([
                " getProps() no props"
              ].join(" ")), {};
            if (excludeProps != null && excludeProps.size)
              for (var key9 in props)
                excludeProps.has(key9) && (shouldPrintDebug && logger.info([
                  " delete excluded",
                  key9
                ].join(" ")), delete props[key9]);
            try {
              var out = getSplitStyles(props, staticConfig, defaultTheme, "", componentState, _object_spread_props(_object_spread({}, styleProps), {
                noClassNames: !0,
                fallbackProps: completeProps
              }), void 0, void 0, void 0, debugPropValue || shouldPrintDebug, options.experimentalFlattenThemesOnNative), outProps2 = _object_spread({}, includeProps ? out.viewProps : {}, out.style, out.pseudos);
              for (var key12 in outProps2)
                deoptProps.has(key12) && (shouldFlatten = !1);
              return shouldPrintDebug && (logger.info("(".concat(debugName, ")")), logger.info(`
       getProps (props in): `.concat(logLines(objToStr(props)))), logger.info(`
       getProps (outProps): `.concat(logLines(objToStr(outProps2))))), out.fontFamily && (setPropsToFontFamily(outProps2, out.fontFamily), shouldPrintDebug && logger.info(`
      \u{1F4AC} new font fam: `.concat(out.fontFamily))), outProps2;
            } catch (err) {
              return logger.info([
                "error",
                err.message,
                err.stack
              ].join(" ")), {};
            }
          };
          shouldFlatten && attrs.unshift({
            type: "style",
            value: defaultProps
          }), attrs = attrs.reduce(function(acc, cur2) {
            if (cur2.type === "style") {
              var key9 = Object.keys(cur2.value)[0], value2 = cur2.value[key9], shouldKeepOriginalAttr = (
                // !isStyleAndAttr[key] &&
                !shouldFlatten && // de-opt if non-style
                !validStyles[key9] && !pseudoDescriptors[key9] && !(key9.startsWith("data-") || key9.startsWith("aria-"))
              );
              if (shouldKeepOriginalAttr)
                return shouldPrintDebug && logger.info([
                  "     - keeping as non-style",
                  key9
                ].join(" ")), prev = cur2, acc.push({
                  type: "attr",
                  value: t.jsxAttribute(t.jsxIdentifier(key9), t.jsxExpressionContainer(typeof value2 == "string" ? t.stringLiteral(value2) : literalToAst(value2)))
                }), acc.push(cur2), acc;
              if ((prev == null ? void 0 : prev.type) === "style")
                return mergeStyles(prev.value, cur2.value), acc;
            }
            return cur2.type === "style" && (prev = cur2), acc.push(cur2), acc;
          }, []), shouldPrintDebug && logger.info([
            `  - attrs (combined \u{1F500}): 
`,
            logLines(attrs.map(attrStr).join(", "))
          ].join(" "));
          var getStyleError = null, _iteratorNormalCompletion12 = !0, _didIteratorError12 = !1, _iteratorError12 = void 0;
          try {
            for (var _iterator12 = attrs[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = !0) {
              var attr = _step12.value;
              try {
                switch (shouldPrintDebug && console.info("  Processing ".concat(attr.type, ":")), attr.type) {
                  case "ternary": {
                    var a = getProps(attr.value.alternate, !1, "ternary.alternate"), c = getProps(attr.value.consequent, !1, "ternary.consequent");
                    a && (attr.value.alternate = a), c && (attr.value.consequent = c), shouldPrintDebug && logger.info([
                      "     => tern ",
                      attrStr(attr)
                    ].join(" "));
                    continue;
                  }
                  case "style": {
                    var styles = getProps(attr.value, !1, "style");
                    styles && (attr.value = styles), shouldPrintDebug && logger.info([
                      "  * styles (in)",
                      logLines(objToStr(attr.value))
                    ].join(" ")), shouldPrintDebug && logger.info([
                      "  * styles (out)",
                      logLines(objToStr(styles))
                    ].join(" "));
                    continue;
                  }
                  case "attr":
                    if (shouldFlatten && t.isJSXAttribute(attr.value)) {
                      var key6 = attr.value.name.name;
                      if (key6 === "style" || key6 === "className" || key6 === "tag")
                        continue;
                      var value1 = attemptEvalSafe(attr.value.value || t.booleanLiteral(!0));
                      if (value1 !== FAILED_EVAL) {
                        var outProps = getProps(_define_property({}, key6, value1), !0, "attr.".concat(key6)), outKey = Object.keys(outProps)[0];
                        if (outKey) {
                          var outVal = outProps[outKey];
                          attr.value = t.jsxAttribute(t.jsxIdentifier(outKey), t.jsxExpressionContainer(typeof outVal == "string" ? t.stringLiteral(outVal) : literalToAst(outVal)));
                        }
                      }
                    }
                }
              } catch (err) {
                getStyleError = err;
              }
            }
          } catch (err) {
            _didIteratorError12 = !0, _iteratorError12 = err;
          } finally {
            try {
              !_iteratorNormalCompletion12 && _iterator12.return != null && _iterator12.return();
            } finally {
              if (_didIteratorError12)
                throw _iteratorError12;
            }
          }
          if (shouldPrintDebug && logger.info([
            `  - attrs (ternaries/combined):
`,
            logLines(attrs.map(attrStr).join(", "))
          ].join(" ")), tm.mark("jsx-element-styles", !!shouldPrintDebug), getStyleError)
            return logger.info([
              " \u26A0\uFE0F postprocessing error, deopt",
              getStyleError
            ].join(" ")), node.attributes = ogAttributes, null;
          for (var existingStyleKeys = /* @__PURE__ */ new Set(), i = attrs.length - 1; i >= 0; i--) {
            var attr1 = attrs[i];
            if (shouldFlatten && attr1.type === "attr" && t.isJSXAttribute(attr1.value) && t.isJSXIdentifier(attr1.value.name)) {
              var name = attr1.value.name.name;
              INLINE_EXTRACTABLE[name] && (attr1.value.name.name = INLINE_EXTRACTABLE[name]);
            }
            if (attr1.type === "style")
              for (var key7 in attr1.value)
                existingStyleKeys.has(key7) ? (shouldPrintDebug && logger.info([
                  "  >> delete existing ".concat(key7)
                ].join(" ")), delete attr1.value[key7]) : existingStyleKeys.add(key7);
            attr1.type === "dynamic-style" && (existingStyleKeys.has(attr1.name) ? attrs[i] = void 0 : existingStyleKeys.add(attr1.name));
          }
          if (options.experimentalFlattenThemesOnNative && (attrs = attrs.filter(Boolean)), !shouldFlatten && inlineWhenUnflattened.size) {
            var _iteratorNormalCompletion22 = !0, _didIteratorError22 = !1, _iteratorError22 = void 0;
            try {
              for (var _iterator22 = attrs.entries()[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = !0) {
                var _step_value1 = _sliced_to_array(_step22.value, 2), index = _step_value1[0], attr2 = _step_value1[1];
                if (attr2.type === "style") {
                  for (var key8 in attr2.value)
                    if (inlineWhenUnflattened.has(key8)) {
                      var val = inlineWhenUnflattenedOGVals[key8];
                      val ? (delete attr2.value[key8], attrs.splice(index - 1, 0, val.attr)) : delete attr2.value[key8];
                    }
                }
              }
            } catch (err) {
              _didIteratorError22 = !0, _iteratorError22 = err;
            } finally {
              try {
                !_iteratorNormalCompletion22 && _iterator22.return != null && _iterator22.return();
              } finally {
                if (_didIteratorError22)
                  throw _iteratorError22;
              }
            }
          }
          attrs = attrs.filter(function(x) {
            return !((x.type === "style" || x.type === "dynamic-style") && Object.keys(x.value).length === 0);
          }), shouldFlatten && (shouldPrintDebug && logger.info([
            "  [\u2705] flattening",
            originalNodeName,
            flatNode
          ].join(" ")), node.name.name = flatNode, res.flattened++, closingElement && (closingElement.name.name = flatNode));
          var isNativeNotFlat = !shouldFlatten && platform2 === "native";
          if (isNativeNotFlat)
            return shouldPrintDebug && logger.info("Disabled flattening except for simple cases on native for now: ".concat(JSON.stringify({
              flatNode,
              shouldDeopt,
              canFlattenProps,
              hasSpread,
              "staticConfig.isStyledHOC": staticConfig.isStyledHOC,
              "!staticConfig.isHOC": !staticConfig.isHOC,
              "staticConfig.isReactNative": staticConfig.isReactNative,
              "staticConfig.neverFlatten": staticConfig.neverFlatten
            }, null, 2))), node.attributes = ogAttributes, null;
          shouldPrintDebug && (logger.info([
            " - inlined props (".concat(inlined.size, "):"),
            shouldDeopt ? " deopted" : "",
            hasSpread ? " has spread" : "",
            staticConfig.neverFlatten ? "neverFlatten" : ""
          ].join(" ")), logger.info("  - shouldFlatten/isFlattened: ".concat(shouldFlatten)), logger.info(`  - attrs (end):
 `.concat(logLines(attrs.map(attrStr).join(", "))))), onExtractTag({
            parserProps: propsWithFileInfo,
            attrs,
            node,
            lineNumbers,
            filePath,
            config: tamaguiConfig,
            attemptEval,
            jsxPath: traversePath,
            originalNodeName,
            isFlattened: shouldFlatten,
            programPath,
            completeProps,
            staticConfig
          });
        } catch (err) {
          node.attributes = ogAttributes, console.error("@tamagui/static error, reverting optimization. In ".concat(filePath, " ").concat(lineNumbers, " on ").concat(originalNodeName, ": ").concat(err.message, ". For stack trace set environment TAMAGUI_DEBUG=1")), process.env.TAMAGUI_DEBUG === "1" && console.error(err.stack);
        } finally {
          debugPropValue && (shouldPrintDebug = ogDebug);
        }
      }
    }), tm.mark("jsx-done", !!shouldPrintDebug), modifiedComponents.size) {
      var all = Array.from(modifiedComponents);
      shouldPrintDebug && logger.info("  [\u{1FA9D}] hook check ".concat(all.length));
      var _iteratorNormalCompletion1 = !0, _didIteratorError1 = !1, _iteratorError1 = void 0;
      try {
        for (var _iterator1 = all[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = !0) {
          var comp = _step1.value;
          removeUnusedHooks(comp, shouldPrintDebug);
        }
      } catch (err) {
        _didIteratorError1 = !0, _iteratorError1 = err;
      } finally {
        try {
          !_iteratorNormalCompletion1 && _iterator1.return != null && _iterator1.return();
        } finally {
          if (_didIteratorError1)
            throw _iteratorError1;
        }
      }
    }
    return tm.done(shouldPrintDebug === "verbose"), res;
  }
}
export {
  createExtractor
};
//# sourceMappingURL=createExtractor.js.map
