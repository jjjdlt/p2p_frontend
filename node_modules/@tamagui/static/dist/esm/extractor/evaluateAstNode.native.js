import * as t from "@babel/types";
function evaluateAstNode(exprNode, evalFn, shouldPrintDebug) {
  if (exprNode !== void 0) {
    if (exprNode === null)
      return !0;
    if (t.isJSXExpressionContainer(exprNode))
      return evaluateAstNode(exprNode.expression);
    if (t.isObjectExpression(exprNode)) {
      for (var ret = {}, idx = -1, len = exprNode.properties.length; ++idx < len; ) {
        var value = exprNode.properties[idx];
        if (!t.isObjectProperty(value))
          throw new Error("evaluateAstNode can only evaluate object properties");
        var key = void 0;
        if (value.computed) {
          if (typeof evalFn != "function")
            throw new Error("evaluateAstNode does not support computed keys unless an eval function is provided");
          key = evaluateAstNode(value.key, evalFn);
        } else if (t.isIdentifier(value.key))
          key = value.key.name;
        else if (t.isStringLiteral(value.key) || t.isNumericLiteral(value.key))
          key = value.key.value;
        else
          throw new Error("Unsupported key type: " + value.key.type);
        if (typeof key != "string" && typeof key != "number")
          throw new Error("key must be either a string or a number");
        ret[key] = evaluateAstNode(value.value, evalFn);
      }
      return ret;
    }
    if (t.isArrayExpression(exprNode))
      return exprNode.elements.map(function(x) {
        return evaluateAstNode(x, evalFn);
      });
    if (t.isUnaryExpression(exprNode) && exprNode.operator === "-") {
      var ret1 = evaluateAstNode(exprNode.argument, evalFn);
      return ret1 == null ? null : -ret1;
    }
    if (t.isTemplateLiteral(exprNode)) {
      if (typeof evalFn != "function")
        throw new Error("evaluateAstNode does not support template literals unless an eval function is provided");
      for (var ret2 = "", idx1 = -1, len1 = exprNode.quasis.length; ++idx1 < len1; ) {
        var quasi = exprNode.quasis[idx1], expr = exprNode.expressions[idx1];
        ret2 += quasi.value.raw, expr && (ret2 += evaluateAstNode(expr, evalFn));
      }
      return ret2;
    }
    if (t.isNullLiteral(exprNode))
      return null;
    if (t.isNumericLiteral(exprNode) || t.isStringLiteral(exprNode) || t.isBooleanLiteral(exprNode))
      return exprNode.value;
    if (t.isBinaryExpression(exprNode)) {
      if (exprNode.operator === "+")
        return evaluateAstNode(exprNode.left, evalFn) + evaluateAstNode(exprNode.right, evalFn);
      if (exprNode.operator === "-")
        return evaluateAstNode(exprNode.left, evalFn) - evaluateAstNode(exprNode.right, evalFn);
      if (exprNode.operator === "*")
        return evaluateAstNode(exprNode.left, evalFn) * evaluateAstNode(exprNode.right, evalFn);
      if (exprNode.operator === "/")
        return evaluateAstNode(exprNode.left, evalFn) / evaluateAstNode(exprNode.right, evalFn);
    }
    if (typeof evalFn != "function")
      throw new Error("evaluateAstNode does not support non-literal values unless an eval function is provided");
    return evalFn(exprNode);
  }
}
export {
  evaluateAstNode
};
//# sourceMappingURL=evaluateAstNode.js.map
