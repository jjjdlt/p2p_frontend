import { basename } from "node:path";
import generate from "@babel/generator";
import * as t from "@babel/types";
import findRoot from "find-root";
import { memoize } from "../helpers/memoize";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
function isPresent(input) {
  return input != null;
}
function isSimpleSpread(node) {
  return t.isIdentifier(node.argument) || t.isMemberExpression(node.argument);
}
var attrStr = function(attr) {
  return attr ? attr.type === "attr" ? getNameAttr(attr.value) : attr.type === "ternary" ? "...".concat(ternaryStr(attr.value)) : "".concat(attr.type, "(").concat(objToStr(attr.value), ")") : "";
}, objToStr = function(obj) {
  var spacer = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ", ";
  return obj ? "{".concat(Object.entries(obj).map(function(param) {
    var _param = _sliced_to_array(param, 2), k = _param[0], v = _param[1];
    return "".concat(k, ":").concat(Array.isArray(v) ? "[...]" : v && typeof v == "object" ? "".concat(objToStr(v, ",")) : JSON.stringify(v));
  }).join(spacer), "}") : "".concat(obj);
}, getNameAttr = function(attr) {
  return t.isJSXSpreadAttribute(attr) ? "...".concat(attr.argument.name) : "name" in attr ? attr.name.name : "unknown-".concat(attr.type);
}, ternaryStr = function(x) {
  var conditional = t.isIdentifier(x.test) ? x.test.name : t.isMemberExpression(x.test) ? [
    x.test.object.name,
    x.test.property.name
  ] : (
    // @ts-ignore
    generate(x.test).code
  );
  return [
    "ternary(",
    conditional,
    isFilledObj(x.consequent) ? " ? ".concat(objToStr(x.consequent)) : " ? \u{1F6AB}",
    isFilledObj(x.alternate) ? " : ".concat(objToStr(x.alternate)) : " : \u{1F6AB}",
    ")"
  ].flat().join("");
}, isFilledObj = function(obj) {
  return obj && Object.keys(obj).length;
};
function findComponentName(scope) {
  for (var componentName = "", cur = scope.path; cur.parentPath && !t.isProgram(cur.parentPath.parent); )
    cur = cur.parentPath;
  var node = cur.parent;
  if (t.isExportNamedDeclaration(node) && (node = node.declaration), t.isVariableDeclaration(node)) {
    var _node_declarations = _sliced_to_array(node.declarations, 1), dec = _node_declarations[0];
    if (t.isVariableDeclarator(dec) && t.isIdentifier(dec.id))
      return dec.id.name;
  }
  if (t.isFunctionDeclaration(node)) {
    var _node_id;
    return (_node_id = node.id) === null || _node_id === void 0 ? void 0 : _node_id.name;
  }
  return componentName;
}
function isValidThemeHook(props, jsxPath, n, sourcePath) {
  var _binding_scope_getBinding;
  if (!t.isIdentifier(n.object) || !t.isIdentifier(n.property)) return !1;
  var bindings = jsxPath.scope.getAllBindings(), binding = bindings[n.object.name];
  if (!(binding != null && binding.path) || !binding.path.isVariableDeclarator()) return !1;
  var init = binding.path.node.init;
  if (!init || !t.isCallExpression(init) || !t.isIdentifier(init.callee) || init.callee.name !== "useTheme") return !1;
  var importNode = (_binding_scope_getBinding = binding.scope.getBinding("useTheme")) === null || _binding_scope_getBinding === void 0 ? void 0 : _binding_scope_getBinding.path.parent;
  return !(!t.isImportDeclaration(importNode) || sourcePath && !isValidImport(props, sourcePath));
}
var isInsideComponentPackage = function(props, moduleName) {
  return getValidComponentsPaths(props).some(function(path) {
    return moduleName.startsWith(path);
  });
}, isComponentPackage = function(props, srcName) {
  return getValidComponentsPaths(props).some(function(path) {
    return srcName.startsWith(path);
  });
};
function getValidComponent(props, moduleName, componentName) {
  if (componentName[0].toUpperCase() !== componentName[0])
    return !1;
  var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
  try {
    for (var _iterator = props.allLoadedComponents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
      var loaded = _step.value;
      if (loaded) {
        var isInModule = moduleName === "*" || moduleName.startsWith(loaded.moduleName), foundComponent = loaded.nameToInfo[componentName];
        if (isInModule && foundComponent)
          return foundComponent;
      }
    }
  } catch (err) {
    _didIteratorError = !0, _iteratorError = err;
  } finally {
    try {
      !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
    } finally {
      if (_didIteratorError)
        throw _iteratorError;
    }
  }
  return null;
}
var isValidModule = function(props, moduleName) {
  if (typeof moduleName != "string")
    throw new Error("No module name");
  var isLocal = moduleName.startsWith(".");
  return {
    isLocal,
    isValid: isLocal ? isInsideComponentPackage(props, moduleName) : isComponentPackage(props, moduleName)
  };
}, getValidImport = function(props, moduleName, componentName) {
  var _isValidModule = isValidModule(props, moduleName), isValid = _isValidModule.isValid, isLocal = _isValidModule.isLocal;
  return !isValid || !componentName ? null : getValidComponent(props, isLocal ? "*" : moduleName, componentName) || null;
}, isValidImport = function(props, moduleName, componentName) {
  return componentName ? !!getValidImport(props, moduleName, componentName) : isValidModule(props, moduleName).isValid;
}, getValidComponentPackages = memoize(function(props) {
  return _to_consumable_array(new Set([
    "@tamagui/core",
    "tamagui"
  ].concat(_to_consumable_array(props.components || []))));
}), getValidComponentsPaths = memoize(function(props) {
  return getValidComponentPackages(props).flatMap(function(pkg) {
    var root = findRoot(pkg), based = basename(root);
    return [
      based,
      pkg
    ].filter(Boolean);
  });
});
export {
  attrStr,
  findComponentName,
  getValidComponent,
  getValidComponentsPaths,
  getValidImport,
  isComponentPackage,
  isInsideComponentPackage,
  isPresent,
  isSimpleSpread,
  isValidImport,
  isValidModule,
  isValidThemeHook,
  objToStr,
  ternaryStr
};
//# sourceMappingURL=extractHelpers.js.map
