import { readFileSync, writeFileSync } from "node:fs";
import { basename, dirname, extname, join, relative, resolve } from "node:path";
import { Color, colorLog } from "@tamagui/cli-color";
import esbuild from "esbuild";
import * as fsExtra from "fs-extra";
import { readFile } from "node:fs/promises";
import { SHOULD_DEBUG } from "../constants.mjs";
import { requireTamaguiCore } from "../helpers/requireTamaguiCore.mjs";
import { minifyCSS } from "../minifyCSS.mjs";
import { getNameToPaths, registerRequire } from "../registerRequire.mjs";
import { getBundledConfig, hasBundledConfigChanged, loadComponents } from "./bundleConfig.mjs";
import { generateTamaguiStudioConfig, generateTamaguiStudioConfigSync, generateTamaguiThemes } from "./generateTamaguiStudioConfig.mjs";
import { getTamaguiConfigPathFromOptionsConfig } from "./getTamaguiConfigPathFromOptionsConfig.mjs";
const getFilledOptions = propsIn => ({
  // defaults
  platform: "web",
  config: "tamagui.config.ts",
  components: ["tamagui"],
  ...propsIn
});
async function loadTamagui(propsIn) {
  const props = getFilledOptions(propsIn),
    bundleInfo = await getBundledConfig(props);
  if (!bundleInfo) return console.warn("No bundled config generated, maybe an error in bundling. Set DEBUG=tamagui and re-run to get logs."), null;
  if (await generateThemesAndLog(props, !0), !hasBundledConfigChanged()) return bundleInfo;
  if (bundleInfo) {
    const {
        createTamagui
      } = requireTamaguiCore(props.platform || "web"),
      config = createTamagui(bundleInfo.tamaguiConfig),
      {
        outputCSS
      } = props;
    if (outputCSS && props.platform === "web") {
      const flush = async () => {
          colorLog(Color.FgYellow, `    \u27A1 [tamagui] output css: ${outputCSS}
`), await fsExtra.writeFile(outputCSS, css);
        },
        cssOut = config.getCSS(),
        css = props.disableMinifyCSS === !1 ? minifyCSS(cssOut).code : cssOut;
      try {
        (await readFile(outputCSS, "utf8")) === css || (await flush());
      } catch {
        await flush();
      }
    }
  }
  return process.env.NODE_ENV === "development" && (await generateTamaguiStudioConfig(props, bundleInfo)), bundleInfo;
}
let waiting = !1,
  hasLoggedOnce = !1;
const generateThemesAndLog = async (options, force = !1) => {
    if (!waiting && options.themeBuilder) try {
      waiting = !0, await new Promise(res => setTimeout(res, 30));
      const didGenerate = await generateTamaguiThemes(options, force);
      !hasLoggedOnce && didGenerate && (hasLoggedOnce = !0, colorLog(Color.FgYellow, `
    \u27A1 [tamagui] generated themes: ${relative(process.cwd(), options.themeBuilder.output)}`));
    } finally {
      waiting = !1;
    }
  },
  last = {},
  lastVersion = {};
function loadTamaguiBuildConfigSync(tamaguiOptions) {
  const buildFilePath = tamaguiOptions?.buildFile ?? "tamagui.build.ts";
  if (fsExtra.existsSync(buildFilePath)) {
    const registered = registerRequire("web");
    try {
      const out = require(buildFilePath).default;
      if (!out) throw new Error(`No default export found in ${buildFilePath}: ${out}`);
      tamaguiOptions = {
        ...tamaguiOptions,
        ...out
      };
    } finally {
      registered.unregister();
    }
  }
  if (!tamaguiOptions) throw new Error("No tamagui build options found either via input props or at tamagui.build.ts");
  return {
    config: "tamagui.config.ts",
    components: ["@tamagui/core"],
    ...tamaguiOptions
  };
}
function loadTamaguiSync({
  forceExports,
  cacheKey,
  ...propsIn
}) {
  const key = JSON.stringify(propsIn);
  if (last[key] && !hasBundledConfigChanged() && (!lastVersion[key] || lastVersion[key] === cacheKey)) return last[key];
  lastVersion[key] = cacheKey || "";
  const props = getFilledOptions(propsIn);
  process.env.IS_STATIC = "is_static", process.env.TAMAGUI_IS_SERVER = "true";
  const {
    unregister
  } = registerRequire(props.platform || "web", {
    proxyWormImports: !!forceExports
  });
  try {
    const devValueOG = globalThis.__DEV__;
    globalThis.__DEV__ = process.env.NODE_ENV === "development";
    try {
      let tamaguiConfig = null;
      if (propsIn.config) {
        const configPath = getTamaguiConfigPathFromOptionsConfig(propsIn.config),
          exp = require(configPath);
        if (tamaguiConfig = exp.default || exp.config || exp, !tamaguiConfig || !tamaguiConfig.parsed) {
          const confPath = require.resolve(configPath);
          throw new Error(`Can't find valid config in ${confPath}:
          
  Be sure you "export default" or "export const config" the config.`);
        }
        if (tamaguiConfig) {
          const {
            createTamagui
          } = requireTamaguiCore(props.platform || "web");
          createTamagui(tamaguiConfig);
        }
      }
      const components = loadComponents(props, forceExports);
      if (!components) throw new Error("No components loaded");
      process.env.DEBUG === "tamagui" && console.info("components", components), process.env.IS_STATIC = void 0, globalThis.__DEV__ = devValueOG;
      const info = {
        components,
        tamaguiConfig,
        nameToPaths: getNameToPaths()
      };
      if (tamaguiConfig) {
        const {
          outputCSS
        } = props;
        if (outputCSS) {
          const flush = () => {
              colorLog(Color.FgYellow, `    \u27A1 [tamagui] output css: ${outputCSS}
`), writeFileSync(outputCSS, css);
            },
            css = props.disableMinifyCSS === !1 ? minifyCSS(tamaguiConfig.getCSS()).code : tamaguiConfig.getCSS();
          try {
            readFileSync(outputCSS, "utf-8") === css || flush();
          } catch {
            flush();
          }
        }
        generateTamaguiStudioConfigSync(props, info);
      }
      return last[key] = {
        ...info,
        cached: !0
      }, info;
    } catch (err) {
      err instanceof Error ? !SHOULD_DEBUG && !forceExports ? (console.warn("Error loading tamagui.config.ts (set DEBUG=tamagui to see full stack), running tamagui without custom config"), console.info(`

    ${err.message}

`)) : SHOULD_DEBUG && console.error(err) : console.error("Error loading tamagui.config.ts", err);
      const {
          createTamagui
        } = requireTamaguiCore(props.platform || "web"),
        {
          getDefaultTamaguiConfig
        } = require("@tamagui/config-default");
      return {
        components: [],
        tamaguiConfig: createTamagui(getDefaultTamaguiConfig()),
        nameToPaths: {}
      };
    }
  } finally {
    unregister();
  }
}
async function getOptions({
  root = process.cwd(),
  tsconfigPath = "tsconfig.json",
  tamaguiOptions,
  host,
  debug
} = {}) {
  const dotDir = join(root, ".tamagui");
  let pkgJson = {};
  try {
    pkgJson = await fsExtra.readJSON(join(root, "package.json"));
  } catch {}
  return {
    mode: process.env.NODE_ENV === "production" ? "production" : "development",
    root,
    host: host || "127.0.0.1",
    pkgJson,
    debug,
    tsconfigPath,
    tamaguiOptions: {
      platform: "web",
      components: ["tamagui"],
      ...tamaguiOptions,
      config: await getDefaultTamaguiConfigPath(root, tamaguiOptions?.config)
    },
    paths: {
      root,
      dotDir,
      conf: join(dotDir, "tamagui.config.json"),
      types: join(dotDir, "types.json")
    }
  };
}
function resolveWebOrNativeSpecificEntry(entry) {
  const workspaceRoot = resolve(),
    resolved = require.resolve(entry, {
      paths: [workspaceRoot]
    }),
    ext = extname(resolved),
    fileName = basename(resolved).replace(ext, ""),
    specificFile = join(dirname(resolved), fileName + "." + "web" + ext);
  return fsExtra.existsSync(specificFile) ? specificFile : entry;
}
const defaultPaths = ["tamagui.config.ts", join("src", "tamagui.config.ts")];
let hasWarnedOnce = !1;
async function getDefaultTamaguiConfigPath(root, configPath) {
  const searchPaths = [...new Set([configPath, ...defaultPaths].filter(Boolean).map(p => join(root, p)))];
  for (const path of searchPaths) if (await fsExtra.pathExists(path)) return path;
  hasWarnedOnce || (hasWarnedOnce = !0, console.warn(`Warning: couldn't find tamagui.config.ts in the following paths given configuration "${configPath}":
    ${searchPaths.join(`
  `)}
  `));
}
async function esbuildWatchFiles(entry, onChanged) {
  let hasRunOnce = !1;
  const context = await esbuild.context({
    bundle: !0,
    entryPoints: [entry],
    resolveExtensions: [".ts", ".tsx", ".js", ".jsx", ".mjs"],
    logLevel: "silent",
    write: !1,
    plugins: [{
      name: "on-rebuild",
      setup({
        onEnd
      }) {
        onEnd(() => {
          hasRunOnce ? onChanged() : hasRunOnce = !0;
        });
      }
    }]
  });
  return context.watch(), () => {
    context.dispose();
  };
}
export { esbuildWatchFiles, generateThemesAndLog, getOptions, loadTamagui, loadTamaguiBuildConfigSync, loadTamaguiSync, resolveWebOrNativeSpecificEntry };