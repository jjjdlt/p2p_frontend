import * as t from "@babel/types";
var buildClassName = function(objectsIn) {
  var extras = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", objects = buildClassNameLogic(objectsIn);
  return objects ? (t.isStringLiteral(objects) ? objects.value = "".concat(extras, " ").concat(objects.value) : objects = t.binaryExpression("+", t.stringLiteral(extras), objects), objects) : null;
}, buildClassNameLogic = function(objects) {
  return objects.reduce(function(acc, val) {
    if (acc == null)
      return (
        // pass conditional expressions through
        t.isConditionalExpression(val) || // pass non-null literals through
        t.isStringLiteral(val) || t.isNumericLiteral(val) ? val : t.logicalExpression("||", val, t.stringLiteral(""))
      );
    var inner;
    if (t.isStringLiteral(val)) {
      if (t.isStringLiteral(acc))
        return t.stringLiteral("".concat(acc.value, " ").concat(val.value));
      inner = t.stringLiteral(" ".concat(val.value));
    } else if (t.isLiteral(val))
      inner = t.binaryExpression("+", t.stringLiteral(" "), val);
    else if (t.isConditionalExpression(val) || t.isBinaryExpression(val)) {
      if (t.isStringLiteral(acc))
        return t.binaryExpression("+", t.stringLiteral("".concat(acc.value, " ")), val);
      inner = t.binaryExpression("+", t.stringLiteral(" "), val);
    } else if (t.isIdentifier(val) || t.isMemberExpression(val))
      inner = t.conditionalExpression(val, t.binaryExpression("+", t.stringLiteral(" "), val), t.stringLiteral(""));
    else {
      if (t.isStringLiteral(acc))
        return t.binaryExpression("+", t.stringLiteral("".concat(acc.value, " ")), t.logicalExpression("||", val, t.stringLiteral("")));
      inner = t.binaryExpression("+", t.stringLiteral(" "), t.logicalExpression("||", val, t.stringLiteral("")));
    }
    return t.binaryExpression("+", acc, inner);
  }, null);
};
export {
  buildClassName,
  buildClassNameLogic
};
//# sourceMappingURL=buildClassName.js.map
