"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
)), __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);
var Slider_exports = {};
__export(Slider_exports, {
  Range: () => Range,
  Slider: () => Slider,
  SliderThumb: () => SliderThumb,
  SliderThumbFrame: () => SliderThumbFrame,
  SliderTrack: () => SliderTrack,
  SliderTrackActive: () => SliderTrackActive,
  SliderTrackActiveFrame: () => SliderTrackActiveFrame,
  SliderTrackFrame: () => SliderTrackFrame,
  Thumb: () => Thumb,
  Track: () => Track
});
module.exports = __toCommonJS(Slider_exports);
var import_jsx_runtime = require("react/jsx-runtime"), import_compose_refs = require("@tamagui/compose-refs"), import_constants = require("@tamagui/constants"), import_core = require("@tamagui/core"), import_get_token = require("@tamagui/get-token"), import_helpers = require("@tamagui/helpers"), import_helpers2 = require("@tamagui/helpers"), import_stacks = require("@tamagui/stacks"), import_use_controllable_state = require("@tamagui/use-controllable-state"), import_use_direction = require("@tamagui/use-direction"), React = __toESM(require("react")), import_constants2 = require("./constants"), import_helpers3 = require("./helpers"), import_SliderImpl = require("./SliderImpl");
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _object_without_properties(source, excluded) {
  if (source == null) return {};
  var target = _object_without_properties_loose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var SliderHorizontal = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var getValueFromPointer = function(pointerPosition) {
    var input = [
      0,
      state.size
    ], output = isDirectionLTR ? [
      min,
      max
    ] : [
      max,
      min
    ], value = (0, import_helpers3.linearScale)(input, output);
    return value(pointerPosition);
  }, min = props.min, max = props.max, dir = props.dir, onSlideStart = props.onSlideStart, onSlideMove = props.onSlideMove, onStepKeyDown = props.onStepKeyDown, onSlideEnd = props.onSlideEnd, sliderProps = _object_without_properties(props, [
    "min",
    "max",
    "dir",
    "onSlideStart",
    "onSlideMove",
    "onStepKeyDown",
    "onSlideEnd"
  ]), direction = (0, import_use_direction.useDirection)(dir), isDirectionLTR = direction === "ltr", sliderRef = React.useRef(null), _React_useState = _sliced_to_array(React.useState(function() {
    return {
      size: 0,
      offset: 0
    };
  }), 2), state = _React_useState[0], setState_ = _React_useState[1], setState = (0, import_core.createShallowSetState)(setState_), measure = function() {
    var _sliderRef_current;
    (_sliderRef_current = sliderRef.current) === null || _sliderRef_current === void 0 || _sliderRef_current.measure(function(_x, _y, width, _height, pageX, _pageY) {
      setState({
        size: width,
        offset: pageX
      });
    });
  };
  return import_constants.isClient && useOnDebouncedWindowResize(measure), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_constants2.SliderOrientationProvider, {
    scope: props.__scopeSlider,
    startEdge: isDirectionLTR ? "left" : "right",
    endEdge: isDirectionLTR ? "right" : "left",
    direction: isDirectionLTR ? 1 : -1,
    sizeProp: "width",
    size: state.size,
    children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_SliderImpl.SliderImpl, _object_spread_props(_object_spread({
      ref: (0, import_compose_refs.composeRefs)(forwardedRef, sliderRef),
      dir: direction
    }, sliderProps), {
      orientation: "horizontal",
      onLayout: measure,
      onSlideStart: function(event, target) {
        var value = getValueFromPointer(event.nativeEvent.locationX);
        value && (onSlideStart == null || onSlideStart(value, target, event));
      },
      onSlideMove: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
        value && (onSlideMove == null || onSlideMove(value, event));
      },
      onSlideEnd: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageX - state.offset);
        value && (onSlideEnd == null || onSlideEnd(event, value));
      },
      onStepKeyDown: function(event) {
        var isBackKey = import_constants2.BACK_KEYS[direction].includes(event.key);
        onStepKeyDown == null || onStepKeyDown({
          event,
          direction: isBackKey ? -1 : 1
        });
      }
    }))
  });
});
function useOnDebouncedWindowResize(callback) {
  var amt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  React.useEffect(function() {
    var last, onResize = function() {
      clearTimeout(last), last = setTimeout(callback, amt);
    };
    return window.addEventListener("resize", onResize), function() {
      clearTimeout(last), window.removeEventListener("resize", onResize);
    };
  }, []);
}
var SliderVertical = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var getValueFromPointer = function(pointerPosition) {
    var input = [
      0,
      state.size
    ], output = [
      max,
      min
    ], value = (0, import_helpers3.linearScale)(input, output);
    return value(pointerPosition);
  }, min = props.min, max = props.max, onSlideStart = props.onSlideStart, onSlideMove = props.onSlideMove, onStepKeyDown = props.onStepKeyDown, onSlideEnd = props.onSlideEnd, sliderProps = _object_without_properties(props, [
    "min",
    "max",
    "onSlideStart",
    "onSlideMove",
    "onStepKeyDown",
    "onSlideEnd"
  ]), _React_useState = _sliced_to_array(React.useState(function() {
    return {
      size: 0,
      offset: 0
    };
  }), 2), state = _React_useState[0], setState_ = _React_useState[1], setState = (0, import_core.createShallowSetState)(setState_), sliderRef = React.useRef(null), measure = function() {
    var _sliderRef_current;
    (_sliderRef_current = sliderRef.current) === null || _sliderRef_current === void 0 || _sliderRef_current.measure(function(_x, _y, _width, height, _pageX, pageY) {
      setState({
        size: height,
        offset: pageY
      });
    });
  };
  return import_constants.isClient && useOnDebouncedWindowResize(measure), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_constants2.SliderOrientationProvider, {
    scope: props.__scopeSlider,
    startEdge: "bottom",
    endEdge: "top",
    sizeProp: "height",
    size: state.size,
    direction: 1,
    children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_SliderImpl.SliderImpl, _object_spread_props(_object_spread({
      ref: (0, import_compose_refs.composeRefs)(forwardedRef, sliderRef)
    }, sliderProps), {
      orientation: "vertical",
      onLayout: measure,
      onSlideStart: function(event, target) {
        var value = getValueFromPointer(event.nativeEvent.locationY);
        value && (onSlideStart == null || onSlideStart(value, target, event));
      },
      onSlideMove: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
        value && (onSlideMove == null || onSlideMove(value, event));
      },
      onSlideEnd: function(event) {
        var value = getValueFromPointer(event.nativeEvent.pageY - state.offset);
        onSlideEnd == null || onSlideEnd(event, value);
      },
      onStepKeyDown: function(event) {
        var isBackKey = import_constants2.BACK_KEYS.ltr.includes(event.key);
        onStepKeyDown == null || onStepKeyDown({
          event,
          direction: isBackKey ? -1 : 1
        });
      }
    }))
  });
}), TRACK_NAME = "SliderTrack", SliderTrackFrame = (0, import_core.styled)(import_SliderImpl.SliderFrame, {
  name: "SliderTrack",
  variants: {
    unstyled: {
      false: {
        height: "100%",
        width: "100%",
        backgroundColor: "$background",
        position: "relative",
        borderRadius: 1e5,
        overflow: "hidden"
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), SliderTrack = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var __scopeSlider = props.__scopeSlider, trackProps = _object_without_properties(props, [
    "__scopeSlider"
  ]), context = (0, import_constants2.useSliderContext)(TRACK_NAME, __scopeSlider);
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SliderTrackFrame, _object_spread_props(_object_spread({
    "data-disabled": context.disabled ? "" : void 0,
    "data-orientation": context.orientation,
    orientation: context.orientation,
    size: context.size
  }, trackProps), {
    ref: forwardedRef
  }));
});
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderTrackActive", SliderTrackActiveFrame = (0, import_core.styled)(import_SliderImpl.SliderFrame, {
  name: "SliderTrackActive",
  backgroundColor: "$background",
  position: "absolute"
}), SliderTrackActive = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var _Math, _Math1, __scopeSlider = props.__scopeSlider, rangeProps = _object_without_properties(props, [
    "__scopeSlider"
  ]), context = (0, import_constants2.useSliderContext)(RANGE_NAME, __scopeSlider), orientation = (0, import_constants2.useSliderOrientationContext)(RANGE_NAME, __scopeSlider), ref = React.useRef(null), composedRefs = (0, import_compose_refs.useComposedRefs)(forwardedRef, ref), valuesCount = context.values.length, percentages = context.values.map(function(value) {
    return (0, import_helpers3.convertValueToPercentage)(value, context.min, context.max);
  }), offsetStart = valuesCount > 1 ? (_Math = Math).min.apply(_Math, _to_consumable_array(percentages)) : 0, offsetEnd = 100 - (_Math1 = Math).max.apply(_Math1, _to_consumable_array(percentages)), _obj;
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SliderTrackActiveFrame, _object_spread(_object_spread_props(_object_spread({
    orientation: context.orientation,
    "data-orientation": context.orientation,
    "data-disabled": context.disabled ? "" : void 0,
    size: context.size,
    animateOnly: [
      "left",
      "top",
      "right",
      "bottom"
    ]
  }, rangeProps), (_obj = {
    ref: composedRefs
  }, _define_property(_obj, orientation.startEdge, "".concat(offsetStart, "%")), _define_property(_obj, orientation.endEdge, "".concat(offsetEnd, "%")), _obj)), orientation.sizeProp === "width" ? {
    height: "100%"
  } : {
    left: 0,
    right: 0
  }));
});
SliderTrackActive.displayName = RANGE_NAME;
var THUMB_NAME = "SliderThumb", getThumbSize = function(val) {
  var tokens = (0, import_core.getTokens)(), size = typeof val == "number" ? val : (0, import_get_token.getSize)(tokens.size[val], {
    shift: -1
  });
  return {
    width: size,
    height: size,
    minWidth: size,
    minHeight: size
  };
}, SliderThumbFrame = (0, import_core.styled)(import_stacks.ThemeableStack, {
  name: "SliderThumb",
  variants: {
    size: {
      "...size": getThumbSize
    },
    unstyled: {
      false: {
        position: "absolute",
        bordered: 2,
        borderWidth: 2,
        backgrounded: !0,
        pressTheme: import_constants.isWeb,
        focusTheme: import_constants.isWeb,
        hoverTheme: import_constants.isWeb
      }
    }
  },
  defaultVariants: {
    unstyled: process.env.TAMAGUI_HEADLESS === "1"
  }
}), SliderThumb = /* @__PURE__ */ React.memo(SliderThumbFrame.styleable(function(props, forwardedRef) {
  var __scopeSlider = props.__scopeSlider, index = props.index, sizeProp = props.size, thumbProps = _object_without_properties(props, [
    "__scopeSlider",
    "index",
    "size"
  ]), context = (0, import_constants2.useSliderContext)(THUMB_NAME, __scopeSlider), orientation = (0, import_constants2.useSliderOrientationContext)(THUMB_NAME, __scopeSlider), _React_useState = _sliced_to_array(React.useState(null), 2), thumb = _React_useState[0], setThumb = _React_useState[1], composedRefs = (0, import_compose_refs.useComposedRefs)(forwardedRef, function(node) {
    return setThumb(node);
  }), value = context.values[index], percent = value === void 0 ? 0 : (0, import_helpers3.convertValueToPercentage)(value, context.min, context.max), label = (0, import_helpers3.getLabel)(index, context.values.length), _ref, sizeIn = (_ref = sizeProp ?? context.size) !== null && _ref !== void 0 ? _ref : "$true", _React_useState1 = _sliced_to_array(React.useState(function() {
    var estimatedSize = (0, import_core.getVariableValue)(getThumbSize(sizeIn).width);
    return estimatedSize;
  }), 2), size = _React_useState1[0], setSize = _React_useState1[1], thumbInBoundsOffset = size ? (0, import_helpers3.getThumbInBoundsOffset)(size, percent, orientation.direction) : 0;
  React.useEffect(function() {
    if (thumb)
      return context.thumbs.set(thumb, index), function() {
        context.thumbs.delete(thumb);
      };
  }, [
    thumb,
    context.thumbs,
    index
  ]);
  var positionalStyles = context.orientation === "horizontal" ? _object_spread({
    x: thumbInBoundsOffset - size / 2,
    y: -size / 2,
    top: "50%"
  }, size === 0 && {
    top: "auto",
    bottom: "auto"
  }) : _object_spread({
    x: -size / 2,
    y: size / 2,
    left: "50%"
  }, size === 0 && {
    left: "auto",
    right: "auto"
  }), _obj;
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SliderThumbFrame, _object_spread_props(_object_spread(_object_spread_props(_object_spread({
    ref: composedRefs,
    role: "slider",
    "aria-label": props["aria-label"] || label,
    "aria-valuemin": context.min,
    "aria-valuenow": value,
    "aria-valuemax": context.max,
    "aria-orientation": context.orientation,
    "data-orientation": context.orientation,
    "data-disabled": context.disabled ? "" : void 0,
    tabIndex: context.disabled ? void 0 : 0,
    animateOnly: [
      "transform",
      "left",
      "top",
      "right",
      "bottom"
    ]
  }, positionalStyles), (_obj = {}, _define_property(_obj, orientation.startEdge, "".concat(percent, "%")), _define_property(_obj, "size", sizeIn), _obj)), thumbProps), {
    onLayout: function(e) {
      setSize(e.nativeEvent.layout[orientation.sizeProp]);
    },
    /**
     * There will be no value on initial render while we work out the index so we hide thumbs
     * without a value, otherwise SSR will render them in the wrong position before they
     * snap into the correct position during hydration which would be visually jarring for
     * slower connections.
     */
    // style={value === undefined ? { display: 'none' } : props.style}
    onFocus: (0, import_helpers2.composeEventHandlers)(props.onFocus, function() {
      context.valueIndexToChangeRef.current = index;
    })
  }));
})), SliderComponent = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var updateThumbFocus = function(focusIndex) {
    if (import_constants.isWeb) {
      var _iteratorNormalCompletion = !0, _didIteratorError = !1, _iteratorError = void 0;
      try {
        for (var _iterator = thumbRefs.current.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = !0) {
          var _step_value = _sliced_to_array(_step.value, 2), node = _step_value[0], index = _step_value[1];
          if (index === focusIndex) {
            node.focus();
            return;
          }
        }
      } catch (err) {
        _didIteratorError = !0, _iteratorError = err;
      } finally {
        try {
          !_iteratorNormalCompletion && _iterator.return != null && _iterator.return();
        } finally {
          if (_didIteratorError)
            throw _iteratorError;
        }
      }
    }
  }, handleSlideMove = function(value2, event) {
    updateValues(value2, valueIndexToChangeRef.current), onSlideMove == null || onSlideMove(event, value2);
  }, updateValues = function(value2, atIndex) {
    var decimalCount = (0, import_helpers3.getDecimalCount)(step), snapToStep = (0, import_helpers3.roundValue)(Math.round((value2 - min) / step) * step + min, decimalCount), nextValue = (0, import_helpers2.clamp)(snapToStep, [
      min,
      max
    ]);
    setValues(function() {
      var prevValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], nextValues = (0, import_helpers3.getNextSortedValues)(prevValues, nextValue, atIndex);
      return (0, import_helpers3.hasMinStepsBetweenValues)(nextValues, minStepsBetweenThumbs * step) ? (valueIndexToChangeRef.current = nextValues.indexOf(nextValue), String(nextValues) === String(prevValues) ? prevValues : nextValues) : prevValues;
    });
  }, name = props.name, _props_min = props.min, min = _props_min === void 0 ? 0 : _props_min, _props_max = props.max, max = _props_max === void 0 ? 100 : _props_max, _props_step = props.step, step = _props_step === void 0 ? 1 : _props_step, _props_orientation = props.orientation, orientation = _props_orientation === void 0 ? "horizontal" : _props_orientation, _props_disabled = props.disabled, disabled = _props_disabled === void 0 ? !1 : _props_disabled, _props_minStepsBetweenThumbs = props.minStepsBetweenThumbs, minStepsBetweenThumbs = _props_minStepsBetweenThumbs === void 0 ? 0 : _props_minStepsBetweenThumbs, _props_defaultValue = props.defaultValue, defaultValue = _props_defaultValue === void 0 ? [
    min
  ] : _props_defaultValue, value = props.value, _props_onValueChange = props.onValueChange, onValueChange = _props_onValueChange === void 0 ? function() {
  } : _props_onValueChange, sizeProp = props.size, onSlideEnd = props.onSlideEnd, onSlideMove = props.onSlideMove, onSlideStart = props.onSlideStart, sliderProps = _object_without_properties(props, [
    "name",
    "min",
    "max",
    "step",
    "orientation",
    "disabled",
    "minStepsBetweenThumbs",
    "defaultValue",
    "value",
    "onValueChange",
    "size",
    "onSlideEnd",
    "onSlideMove",
    "onSlideStart"
  ]), sliderRef = React.useRef(null), composedRefs = (0, import_compose_refs.useComposedRefs)(sliderRef, forwardedRef), thumbRefs = React.useRef(/* @__PURE__ */ new Map()), valueIndexToChangeRef = React.useRef(0), isHorizontal = orientation === "horizontal", _useControllableState = _sliced_to_array((0, import_use_controllable_state.useControllableState)({
    prop: value,
    defaultProp: defaultValue,
    transition: !0,
    onChange: function(value2) {
      updateThumbFocus(valueIndexToChangeRef.current), onValueChange(value2);
    }
  }), 2), tmp = _useControllableState[0], values = tmp === void 0 ? [] : tmp, setValues = _useControllableState[1];
  import_constants.isWeb && React.useEffect(function() {
    var node = sliderRef.current;
    if (node) {
      var preventDefault = function(e) {
        e.preventDefault();
      };
      return node.addEventListener("touchstart", preventDefault), function() {
        node.removeEventListener("touchstart", preventDefault);
      };
    }
  }, []);
  var SliderOriented = isHorizontal ? SliderHorizontal : SliderVertical;
  return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_constants2.SliderProvider, {
    scope: props.__scopeSlider,
    disabled,
    min,
    max,
    valueIndexToChangeRef,
    thumbs: thumbRefs.current,
    values,
    orientation,
    size: sizeProp,
    children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(SliderOriented, _object_spread_props(_object_spread({
      "aria-disabled": disabled,
      "data-disabled": disabled ? "" : void 0
    }, sliderProps), {
      ref: composedRefs,
      min,
      max,
      onSlideEnd,
      onSlideStart: disabled ? void 0 : function(value2, target, event) {
        if (target !== "thumb") {
          var closestIndex = (0, import_helpers3.getClosestValueIndex)(values, value2);
          updateValues(value2, closestIndex);
        }
        onSlideStart == null || onSlideStart(event, value2, target);
      },
      onSlideMove: disabled ? void 0 : handleSlideMove,
      onHomeKeyDown: function() {
        return !disabled && updateValues(min, 0);
      },
      onEndKeyDown: function() {
        return !disabled && updateValues(max, values.length - 1);
      },
      onStepKeyDown: function(param) {
        var event = param.event, stepDirection = param.direction;
        if (!disabled) {
          var isPageKey = import_constants2.PAGE_KEYS.includes(event.key), isSkipKey = isPageKey || event.shiftKey && import_constants2.ARROW_KEYS.includes(event.key), multiplier = isSkipKey ? 10 : 1, atIndex = valueIndexToChangeRef.current, value2 = values[atIndex], stepInDirection = step * multiplier * stepDirection;
          updateValues(value2 + stepInDirection, atIndex);
        }
      }
    }))
  });
}), Slider = (0, import_helpers.withStaticProperties)(SliderComponent, {
  Track: SliderTrack,
  TrackActive: SliderTrackActive,
  Thumb: SliderThumb
});
Slider.displayName = import_constants2.SLIDER_NAME;
var Track = SliderTrack, Range = SliderTrackActive, Thumb = SliderThumb;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Range,
  Slider,
  SliderThumb,
  SliderThumbFrame,
  SliderTrack,
  SliderTrackActive,
  SliderTrackActiveFrame,
  SliderTrackFrame,
  Thumb,
  Track
});
//# sourceMappingURL=Slider.js.map
