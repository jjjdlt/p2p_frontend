"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = FullySpecified;

var _fs = require("fs");

var _path = require("path");

var _types = require("@babel/types");

const makeDeclaration = ({
  declaration,
  makeNodes,
  ensureFileExists = false,
  handlePackageModules = true,
  esExtensionDefault = '.js',
  // List of all extensions which we try to find
  tryExtensions = ['.js', '.mjs', '.cjs'],
  // List of extensions that can run in Node.js or in the Browser
  esExtensions = ['.js', '.mjs', '.cjs'],
  // List of packages that also should be transformed with this plugin
  includePackages = []
}) => {
  return (path, {
    file: {
      opts: {
        filename
      }
    }
  }) => {
    const {
      source
    } = path.node;

    if (!source) {
      return; // stop here
    }

    const {
      exportKind,
      importKind
    } = path.node;
    const isTypeOnly = exportKind === 'type' || importKind === 'type';

    if (isTypeOnly) {
      return; // stop here
    }

    const {
      value
    } = source;
    const module = value;
    let packageData;

    if (!isLocalFile(module)) {
      if (!handlePackageModules) {
        return; // stop here
      }

      if (includePackages.some(name => module.startsWith(name))) {
        packageData = getPackageData(module);
      }

      if (!(packageData && packageData.hasPath)) {
        return; // stop here
      }
    }

    const filenameExtension = (0, _path.extname)(filename);
    const filenameDirectory = (0, _path.dirname)(filename);
    const isDirectory = isLocalDirectory((0, _path.resolve)(filenameDirectory, module));
    const currentModuleExtension = (0, _path.extname)(module);
    const targetModule = evaluateTargetModule({
      module,
      filenameDirectory,
      filenameExtension,
      packageData,
      currentModuleExtension,
      isDirectory,
      tryExtensions,
      esExtensions,
      esExtensionDefault,
      ensureFileExists
    });

    if (targetModule === false || currentModuleExtension === targetModule.extension) {
      return; // stop here
    }

    const nodes = makeNodes(path);
    path.replaceWith(declaration.apply(null, [...nodes, (0, _types.stringLiteral)(targetModule.module)]));
  };
};

function FullySpecified(api, options) {
  api.assertVersion(7);
  return {
    name: 'babel-plugin-fully-specified',
    visitor: {
      ImportDeclaration: makeDeclaration({ ...options,
        declaration: _types.importDeclaration,
        makeNodes: ({
          node: {
            specifiers
          }
        }) => [specifiers]
      }),
      ExportNamedDeclaration: makeDeclaration({ ...options,
        declaration: _types.exportNamedDeclaration,
        makeNodes: ({
          node: {
            declaration,
            specifiers
          }
        }) => [declaration, specifiers]
      }),
      ExportAllDeclaration: makeDeclaration({ ...options,
        declaration: _types.exportAllDeclaration,
        makeNodes: () => []
      })
    }
  };
}

function getPackageData(module) {
  try {
    const packagePath = require.resolve(module);

    const parts = packagePath.split('/');
    let packageDir;

    for (let i = parts.length; i >= 0; i--) {
      const dir = (0, _path.dirname)(parts.slice(0, i).join('/'));

      if ((0, _fs.existsSync)(`${dir}/package.json`)) {
        packageDir = dir;
        break;
      }
    }

    const packageJson = JSON.parse((0, _fs.readFileSync)(`${packageDir}/package.json`).toString());
    const hasPath = !module.endsWith(packageJson.name);
    return {
      hasPath,
      packagePath
    };
  } catch (e) {}

  return null;
}

function isLocalFile(module) {
  return module.startsWith('.') || module.startsWith('/');
}

function isLocalDirectory(absoluteDirectory) {
  return (0, _fs.existsSync)(absoluteDirectory) && (0, _fs.lstatSync)(absoluteDirectory).isDirectory();
}

function evaluateTargetModule({
  module,
  currentModuleExtension,
  packageData,
  isDirectory,
  filenameDirectory,
  filenameExtension,
  tryExtensions,
  esExtensions,
  esExtensionDefault,
  ensureFileExists
}) {
  if (packageData) {
    if (packageData.packagePath.endsWith('index.js') && !module.endsWith('index.js')) {
      module = `${module}/index`;
    }

    return {
      module: module + esExtensionDefault,
      extension: esExtensionDefault
    };
  }

  if (currentModuleExtension && !esExtensions.includes(currentModuleExtension)) {
    return false;
  }

  if (isDirectory && !(0, _fs.existsSync)((0, _path.resolve)(filenameDirectory, currentModuleExtension ? module : module + esExtensionDefault))) {
    module = `${module}/index`;
  }

  const targetFile = (0, _path.resolve)(filenameDirectory, module);

  if (ensureFileExists) {
    // 1. try first with same extension
    if (esExtensions.includes(filenameExtension) && (0, _fs.existsSync)(targetFile + filenameExtension)) {
      return {
        module: module + filenameExtension,
        extension: filenameExtension
      };
    } // 2. then try with all others


    for (const extension of tryExtensions) {
      if ((0, _fs.existsSync)(targetFile + extension)) {
        return {
          module: module + extension,
          extension
        };
      }
    }
  } else if (esExtensions.includes(filenameExtension)) {
    return {
      module: module + filenameExtension,
      extension: filenameExtension
    };
  } else {
    return {
      module: module + esExtensionDefault,
      extension: esExtensionDefault
    };
  }

  return false;
}