import { simpleHash } from "@tamagui/simple-hash";
import createReactDOMStyle from "./createReactDOMStyle";
import hyphenateStyleName from "./hyphenateStyleName";
import normalizeValueWithProperty from "./normalizeValueWithProperty";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_with_holes(arr) {
  if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _define_property(obj, key, value) {
  return key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol < "u" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i != null) {
    var _arr = [], _n = !0, _d = !1, _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0)
        ;
    } catch (err) {
      _d = !0, _e = err;
    } finally {
      try {
        !_n && _i.return != null && _i.return();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {}, ownKeys2 = Object.keys(source);
    typeof Object.getOwnPropertySymbols == "function" && (ownKeys2 = ownKeys2.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
      return Object.getOwnPropertyDescriptor(source, sym).enumerable;
    }))), ownKeys2.forEach(function(key) {
      _define_property(target, key, source[key]);
    });
  }
  return target;
}
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _object_spread_props(target, source) {
  return source = source ?? {}, Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
  }), target;
}
function _object_without_properties(source, excluded) {
  if (source == null) return {};
  var target = _object_without_properties_loose(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
function _object_without_properties_loose(source, excluded) {
  if (source == null) return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var cache = /* @__PURE__ */ new Map(), emptyObject = {}, classicGroup = 1, atomicGroup = 2.2, customGroup = {
  borderColor: 2,
  borderRadius: 2,
  borderStyle: 2,
  borderWidth: 2,
  display: 2,
  flex: 2,
  margin: 2,
  overflow: 2,
  overscrollBehavior: 2,
  padding: 2,
  marginHorizontal: 2.1,
  marginVertical: 2.1,
  paddingHorizontal: 2.1,
  paddingVertical: 2.1
}, borderTopLeftRadius = "borderTopLeftRadius", borderTopRightRadius = "borderTopRightRadius", borderBottomLeftRadius = "borderBottomLeftRadius", borderBottomRightRadius = "borderBottomRightRadius", borderLeftColor = "borderLeftColor", borderLeftStyle = "borderLeftStyle", borderLeftWidth = "borderLeftWidth", borderRightColor = "borderRightColor", borderRightStyle = "borderRightStyle", borderRightWidth = "borderRightWidth", right = "right", marginLeft = "marginLeft", marginRight = "marginRight", paddingLeft = "paddingLeft", paddingRight = "paddingRight", left = "left", _obj, PROPERTIES_FLIP = (_obj = {}, _define_property(_obj, borderTopLeftRadius, borderTopRightRadius), _define_property(_obj, borderTopRightRadius, borderTopLeftRadius), _define_property(_obj, borderBottomLeftRadius, borderBottomRightRadius), _define_property(_obj, borderBottomRightRadius, borderBottomLeftRadius), _define_property(_obj, borderLeftColor, borderRightColor), _define_property(_obj, borderLeftStyle, borderRightStyle), _define_property(_obj, borderLeftWidth, borderRightWidth), _define_property(_obj, borderRightColor, borderLeftColor), _define_property(_obj, borderRightStyle, borderLeftStyle), _define_property(_obj, borderRightWidth, borderLeftWidth), _define_property(_obj, left, right), _define_property(_obj, marginLeft, marginRight), _define_property(_obj, marginRight, marginLeft), _define_property(_obj, paddingLeft, paddingRight), _define_property(_obj, paddingRight, paddingLeft), _define_property(_obj, right, left), _obj), PROPERTIES_I18N = {
  borderTopStartRadius: borderTopLeftRadius,
  borderTopEndRadius: borderTopRightRadius,
  borderBottomStartRadius: borderBottomLeftRadius,
  borderBottomEndRadius: borderBottomRightRadius,
  borderStartColor: borderLeftColor,
  borderStartStyle: borderLeftStyle,
  borderStartWidth: borderLeftWidth,
  borderEndColor: borderRightColor,
  borderEndStyle: borderRightStyle,
  borderEndWidth: borderRightWidth,
  end: right,
  marginStart: marginLeft,
  marginEnd: marginRight,
  paddingStart: paddingLeft,
  paddingEnd: paddingRight,
  start: left
}, PROPERTIES_VALUE = [
  "clear",
  "float",
  "textAlign"
];
function atomic(style) {
  var compiledStyle = {
    $$css: !0
  }, compiledRules = [];
  function atomicCompile(prop, value) {
    var valueString = stringifyValueWithProperty(value, prop), cacheKey = prop + valueString, cachedResult = cache.get(cacheKey), identifier;
    if (cachedResult != null)
      identifier = cachedResult[0], compiledRules.push(cachedResult[1]);
    else {
      identifier = createIdentifier("r", prop, value);
      var order = customGroup[prop] || atomicGroup, rules = createAtomicRules(identifier, prop, value), orderedRules = [
        rules,
        order
      ];
      compiledRules.push(orderedRules), cache.set(cacheKey, [
        identifier,
        orderedRules
      ]);
    }
    return identifier;
  }
  return Object.keys(style).sort().forEach(function(prop) {
    var value = style[prop];
    if (value != null) {
      var localizeableValue;
      if (PROPERTIES_VALUE.indexOf(prop) > -1) {
        var left2 = atomicCompile(prop, "left"), right2 = atomicCompile(prop, "right");
        value === "start" ? localizeableValue = [
          left2,
          right2
        ] : value === "end" && (localizeableValue = [
          right2,
          left2
        ]);
      }
      var propPolyfill = PROPERTIES_I18N[prop];
      if (propPolyfill != null) {
        var ltr = atomicCompile(propPolyfill, value), rtl = atomicCompile(PROPERTIES_FLIP[propPolyfill], value);
        localizeableValue = [
          ltr,
          rtl
        ];
      }
      if (prop === "transitionProperty") {
        for (var values = Array.isArray(value) ? value : [
          value
        ], polyfillIndices = [], i = 0; i < values.length; i++) {
          var val = values[i];
          typeof val == "string" && PROPERTIES_I18N[val] != null && polyfillIndices.push(i);
        }
        if (polyfillIndices.length > 0) {
          var ltrPolyfillValues = _to_consumable_array(values), rtlPolyfillValues = _to_consumable_array(values);
          polyfillIndices.forEach(function(i2) {
            var ltrVal = ltrPolyfillValues[i2];
            if (typeof ltrVal == "string") {
              var ltrPolyfill = PROPERTIES_I18N[ltrVal], rtlPolyfill = PROPERTIES_FLIP[ltrPolyfill];
              ltrPolyfillValues[i2] = ltrPolyfill, rtlPolyfillValues[i2] = rtlPolyfill;
              var ltr2 = atomicCompile(prop, ltrPolyfillValues), rtl2 = atomicCompile(prop, rtlPolyfillValues);
              localizeableValue = [
                ltr2,
                rtl2
              ];
            }
          });
        }
      }
      localizeableValue == null ? localizeableValue = atomicCompile(prop, value) : compiledStyle.$$css$localize = !0, compiledStyle[prop] = localizeableValue;
    }
  }), [
    compiledStyle,
    compiledRules
  ];
}
function classic(style, name) {
  var compiledStyle = {
    $$css: !0
  }, compiledRules = [], animationKeyframes = style.animationKeyframes, rest = _object_without_properties(style, [
    "animationKeyframes"
  ]), identifier = createIdentifier("css", name, style), selector = ".".concat(identifier), animationName;
  if (animationKeyframes != null) {
    var _compiledRules, _processKeyframesValue = _sliced_to_array(processKeyframesValue(animationKeyframes), 2), animationNames = _processKeyframesValue[0], keyframesRules = _processKeyframesValue[1];
    animationName = animationNames.join(","), (_compiledRules = compiledRules).push.apply(_compiledRules, _to_consumable_array(keyframesRules));
  }
  var block = createDeclarationBlock(_object_spread_props(_object_spread({}, rest), {
    animationName
  }));
  return compiledRules.push("".concat(selector).concat(block)), compiledStyle[identifier] = identifier, [
    compiledStyle,
    [
      [
        compiledRules,
        classicGroup
      ]
    ]
  ];
}
function inline(originalStyle, isRTL) {
  var _loop = function(originalProp2) {
    var originalValue = style[originalProp2], prop = originalProp2, value = originalValue;
    if (!Object.prototype.hasOwnProperty.call(style, originalProp2) || originalValue == null)
      return "continue";
    PROPERTIES_VALUE.indexOf(originalProp2) > -1 && (originalValue === "start" ? value = isRTL ? "right" : "left" : originalValue === "end" && (value = isRTL ? "left" : "right"));
    var propPolyfill = PROPERTIES_I18N[originalProp2];
    if (propPolyfill != null && (prop = isRTL ? PROPERTIES_FLIP[propPolyfill] : propPolyfill), originalProp2 === "transitionProperty") {
      var originalValues = Array.isArray(originalValue) ? originalValue : [
        originalValue
      ];
      originalValues.forEach(function(val, i) {
        if (typeof val == "string") {
          var valuePolyfill = PROPERTIES_I18N[val];
          valuePolyfill != null && (originalValues[i] = isRTL ? PROPERTIES_FLIP[valuePolyfill] : valuePolyfill);
        }
      });
    }
    frozenProps[prop] || (nextStyle[prop] = value), PROPERTIES_I18N.hasOwnProperty(originalProp2) && (frozenProps[prop] = !0);
  }, style = originalStyle || emptyObject, frozenProps = {}, nextStyle = {};
  for (var originalProp in style) _loop(originalProp);
  return createReactDOMStyle(nextStyle, !0);
}
function stringifyValueWithProperty(value, property) {
  var normalizedValue = normalizeValueWithProperty(value, property);
  return typeof normalizedValue != "string" ? JSON.stringify(normalizedValue || "") : normalizedValue;
}
function createAtomicRules(identifier, property, value) {
  var rules = [], selector = ".".concat(identifier);
  switch (property) {
    case "animationKeyframes": {
      var _rules, _processKeyframesValue = _sliced_to_array(processKeyframesValue(value), 2), animationNames = _processKeyframesValue[0], keyframesRules = _processKeyframesValue[1], block = createDeclarationBlock({
        animationName: animationNames.join(",")
      });
      (_rules = rules).push.apply(_rules, [
        "".concat(selector).concat(block)
      ].concat(_to_consumable_array(keyframesRules)));
      break;
    }
    case "placeholderTextColor": {
      var block1 = createDeclarationBlock({
        color: value,
        opacity: 1
      });
      rules.push("".concat(selector, "::-webkit-input-placeholder").concat(block1), "".concat(selector, "::-moz-placeholder").concat(block1), "".concat(selector, ":-ms-input-placeholder").concat(block1), "".concat(selector, "::placeholder").concat(block1));
      break;
    }
    case "pointerEvents": {
      var finalValue = value;
      if (value === "auto" || value === "box-only") {
        if (finalValue = "auto!important", value === "box-only") {
          var block2 = createDeclarationBlock({
            pointerEvents: "none"
          });
          rules.push("".concat(selector, ">*").concat(block2));
        }
      } else if ((value === "none" || value === "box-none") && (finalValue = "none!important", value === "box-none")) {
        var block3 = createDeclarationBlock({
          pointerEvents: "auto"
        });
        rules.push("".concat(selector, ">*").concat(block3));
      }
      var block4 = createDeclarationBlock({
        pointerEvents: finalValue
      });
      rules.push("".concat(selector).concat(block4));
      break;
    }
    case "scrollbarWidth": {
      value === "none" && rules.push("".concat(selector, "::-webkit-scrollbar{display:none}"));
      var block5 = createDeclarationBlock({
        scrollbarWidth: value
      });
      rules.push("".concat(selector).concat(block5));
      break;
    }
    default: {
      var block6 = createDeclarationBlock(_define_property({}, property, value));
      rules.push("".concat(selector).concat(block6));
      break;
    }
  }
  return rules;
}
function createDeclarationBlock(style) {
  var domStyle = createReactDOMStyle(style), declarationsString = Object.keys(domStyle).map(function(property) {
    var value = domStyle[property], prop = hyphenateStyleName(property);
    return Array.isArray(value) ? value.map(function(v) {
      return "".concat(prop, ":").concat(v);
    }).join(";") : "".concat(prop, ":").concat(value);
  }).sort().join(";");
  return "{".concat(declarationsString, ";}");
}
function createIdentifier(prefix, name, value) {
  var hashedString = simpleHash(name + stringifyValueWithProperty(value, name));
  return process.env.NODE_ENV !== "production" ? "".concat(prefix, "-").concat(name, "-").concat(hashedString) : "".concat(prefix, "-").concat(hashedString);
}
function createKeyframes(keyframes) {
  var prefixes = [
    "-webkit-",
    ""
  ], identifier = createIdentifier("r", "animation", keyframes), steps = "{" + Object.keys(keyframes).map(function(stepName) {
    var rule = keyframes[stepName], block = createDeclarationBlock(rule);
    return "".concat(stepName).concat(block);
  }).join("") + "}", rules = prefixes.map(function(prefix) {
    return "@".concat(prefix, "keyframes ").concat(identifier).concat(steps);
  });
  return [
    identifier,
    rules
  ];
}
function processKeyframesValue(keyframesValue) {
  if (typeof keyframesValue == "number")
    throw new Error("Invalid CSS keyframes type: ".concat(typeof keyframesValue > "u" ? "undefined" : _type_of(keyframesValue)));
  var animationNames = [], rules = [], value = Array.isArray(keyframesValue) ? keyframesValue : [
    keyframesValue
  ];
  return value.forEach(function(keyframes) {
    if (typeof keyframes == "string")
      animationNames.push(keyframes);
    else {
      var _rules, _createKeyframes = _sliced_to_array(createKeyframes(keyframes), 2), identifier = _createKeyframes[0], keyframesRules = _createKeyframes[1];
      animationNames.push(identifier), (_rules = rules).push.apply(_rules, _to_consumable_array(keyframesRules));
    }
  }), [
    animationNames,
    rules
  ];
}
export {
  atomic,
  classic,
  inline,
  stringifyValueWithProperty
};
//# sourceMappingURL=index.js.map
