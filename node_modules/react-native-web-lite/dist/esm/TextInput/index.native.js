import * as React from "react";
import { StyleSheet } from "react-native-web-internals";
import { TextInputState, forwardedProps, getLocaleDirection, pick, useElementLayout, useLocaleContext, useMergeRefs, usePlatformMethods, useResponderEvents } from "react-native-web-internals";
import createElement from "../createElement/index";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var isSelectionStale = function(node, selection) {
  var selectionEnd = node.selectionEnd, selectionStart = node.selectionStart, start = selection.start, end = selection.end;
  return start !== selectionStart || end !== selectionEnd;
}, setSelection = function(node, selection) {
  if (isSelectionStale(node, selection)) {
    var start = selection.start, end = selection.end;
    try {
      node.setSelectionRange(start, end || start);
    } catch {
    }
  }
}, forwardPropsList = Object.assign({}, forwardedProps.defaultProps, forwardedProps.accessibilityProps, forwardedProps.clickProps, forwardedProps.focusProps, forwardedProps.keyboardProps, forwardedProps.mouseProps, forwardedProps.touchProps, forwardedProps.styleProps, {
  autoCapitalize: !0,
  autoComplete: !0,
  autoCorrect: !0,
  autoFocus: !0,
  defaultValue: !0,
  disabled: !0,
  lang: !0,
  maxLength: !0,
  onChange: !0,
  onScroll: !0,
  placeholder: !0,
  pointerEvents: !0,
  readOnly: !0,
  rows: !0,
  spellCheck: !0,
  value: !0,
  type: !0
}), pickProps = function(props) {
  return pick(props, forwardPropsList);
}, useIsomorphicLayoutEffect = typeof window > "u" ? React.useEffect : React.useLayoutEffect;
function isEventComposing(nativeEvent) {
  return nativeEvent.isComposing || nativeEvent.keyCode === 229;
}
var focusTimeout = null, TextInput = /* @__PURE__ */ React.forwardRef(function(props, forwardedRef) {
  var handleBlur = function(e) {
    TextInputState._currentlyFocusedNode = null, onBlur && (e.nativeEvent.text = e.target.value, onBlur(e));
  }, handleChange = function(e) {
    var hostNode = e.target, text = hostNode.value;
    e.nativeEvent.text = text, handleContentSizeChange(hostNode), onChange && onChange(e), onChangeText && onChangeText(text);
  }, handleFocus = function(e) {
    var hostNode = e.target;
    onFocus && (e.nativeEvent.text = hostNode.value, onFocus(e)), hostNode != null && (TextInputState._currentlyFocusedNode = hostNode, clearTextOnFocus && (hostNode.value = ""), selectTextOnFocus && (focusTimeout != null && clearTimeout(focusTimeout), focusTimeout = setTimeout(function() {
      hostNode != null && hostNode.select();
    }, 0)));
  }, handleKeyDown = function(e) {
    var hostNode = e.target;
    e.stopPropagation();
    var blurOnSubmitDefault = !multiline, shouldBlurOnSubmit = blurOnSubmit ?? blurOnSubmitDefault, nativeEvent = e.nativeEvent, isComposing = isEventComposing(nativeEvent);
    onKeyPress && onKeyPress(e), e.key === "Enter" && !e.shiftKey && // Do not call submit if composition is occuring.
    !isComposing && !e.isDefaultPrevented() && ((blurOnSubmit || !multiline) && onSubmitEditing && (e.preventDefault(), nativeEvent.text = e.target.value, onSubmitEditing(e)), shouldBlurOnSubmit && hostNode != null && setTimeout(function() {
      return hostNode.blur();
    }, 0));
  }, handleSelectionChange = function(e) {
    if (onSelectionChange)
      try {
        var node = e.target, selectionStart = node.selectionStart, selectionEnd = node.selectionEnd;
        e.nativeEvent.selection = {
          start: selectionStart,
          end: selectionEnd
        }, e.nativeEvent.text = e.target.value, onSelectionChange(e);
      } catch {
      }
  }, _props_autoCapitalize = props.autoCapitalize, autoCapitalize = _props_autoCapitalize === void 0 ? "sentences" : _props_autoCapitalize, autoComplete = props.autoComplete, autoCompleteType = props.autoCompleteType, _props_autoCorrect = props.autoCorrect, autoCorrect = _props_autoCorrect === void 0 ? !0 : _props_autoCorrect, blurOnSubmit = props.blurOnSubmit, clearTextOnFocus = props.clearTextOnFocus, dir = props.dir, editable = props.editable, enterKeyHint = props.enterKeyHint, _props_inputMode = props.inputMode, inputMode = _props_inputMode === void 0 ? "text" : _props_inputMode, keyboardType = props.keyboardType, _props_multiline = props.multiline, multiline = _props_multiline === void 0 ? !1 : _props_multiline, numberOfLines = props.numberOfLines, onBlur = props.onBlur, onChange = props.onChange, onChangeText = props.onChangeText, onContentSizeChange = props.onContentSizeChange, onFocus = props.onFocus, onKeyPress = props.onKeyPress, onLayout = props.onLayout, onMoveShouldSetResponder = props.onMoveShouldSetResponder, onMoveShouldSetResponderCapture = props.onMoveShouldSetResponderCapture, onResponderEnd = props.onResponderEnd, onResponderGrant = props.onResponderGrant, onResponderMove = props.onResponderMove, onResponderReject = props.onResponderReject, onResponderRelease = props.onResponderRelease, onResponderStart = props.onResponderStart, onResponderTerminate = props.onResponderTerminate, onResponderTerminationRequest = props.onResponderTerminationRequest, onScrollShouldSetResponder = props.onScrollShouldSetResponder, onScrollShouldSetResponderCapture = props.onScrollShouldSetResponderCapture, onSelectionChange = props.onSelectionChange, onSelectionChangeShouldSetResponder = props.onSelectionChangeShouldSetResponder, onSelectionChangeShouldSetResponderCapture = props.onSelectionChangeShouldSetResponderCapture, onStartShouldSetResponder = props.onStartShouldSetResponder, onStartShouldSetResponderCapture = props.onStartShouldSetResponderCapture, onSubmitEditing = props.onSubmitEditing, placeholderTextColor = props.placeholderTextColor, _props_readOnly = props.readOnly, readOnly = _props_readOnly === void 0 ? !1 : _props_readOnly, returnKeyType = props.returnKeyType, _props_rows = props.rows, rows = _props_rows === void 0 ? 1 : _props_rows, _props_secureTextEntry = props.secureTextEntry, secureTextEntry = _props_secureTextEntry === void 0 ? !1 : _props_secureTextEntry, selection = props.selection, selectTextOnFocus = props.selectTextOnFocus, spellCheck = props.spellCheck, type, _inputMode;
  if (inputMode != null)
    _inputMode = inputMode, inputMode === "email" ? type = "email" : inputMode === "tel" ? type = "tel" : inputMode === "search" ? type = "search" : inputMode === "url" ? type = "url" : type = "text";
  else if (keyboardType != null)
    switch (warn("keyboardType", "keyboardType is deprecated. Use inputMode."), keyboardType) {
      case "email-address":
        type = "email";
        break;
      case "number-pad":
      case "numeric":
        _inputMode = "numeric";
        break;
      case "decimal-pad":
        _inputMode = "decimal";
        break;
      case "phone-pad":
        type = "tel";
        break;
      case "search":
      case "web-search":
        type = "search";
        break;
      case "url":
        type = "url";
        break;
      default:
        type = "text";
    }
  secureTextEntry && (type = "password");
  var dimensions = React.useRef({
    height: null,
    width: null
  }), hostRef = React.useRef(null), handleContentSizeChange = React.useCallback(function(hostNode) {
    if (multiline && onContentSizeChange && hostNode != null) {
      var newHeight = hostNode.scrollHeight, newWidth = hostNode.scrollWidth;
      (newHeight !== dimensions.current.height || newWidth !== dimensions.current.width) && (dimensions.current.height = newHeight, dimensions.current.width = newWidth, onContentSizeChange({
        nativeEvent: {
          contentSize: {
            height: dimensions.current.height,
            width: dimensions.current.width
          }
        }
      }));
    }
  }, [
    multiline,
    onContentSizeChange
  ]), imperativeRef = React.useMemo(function() {
    return function(hostNode) {
      hostNode != null && (hostNode.clear = function() {
        hostNode != null && (hostNode.value = "");
      }, hostNode.isFocused = function() {
        return hostNode != null && TextInputState.currentlyFocusedField() === hostNode;
      }, handleContentSizeChange(hostNode));
    };
  }, [
    handleContentSizeChange
  ]);
  useIsomorphicLayoutEffect(function() {
    var node = hostRef.current;
    node != null && selection != null && setSelection(node, selection), document.activeElement === node && (TextInputState._currentlyFocusedNode = node);
  }, [
    hostRef,
    selection
  ]);
  var component = multiline ? "textarea" : "input";
  useElementLayout(hostRef, onLayout), useResponderEvents(hostRef, {
    onMoveShouldSetResponder,
    onMoveShouldSetResponderCapture,
    onResponderEnd,
    onResponderGrant,
    onResponderMove,
    onResponderReject,
    onResponderRelease,
    onResponderStart,
    onResponderTerminate,
    onResponderTerminationRequest,
    onScrollShouldSetResponder,
    onScrollShouldSetResponderCapture,
    onSelectionChangeShouldSetResponder,
    onSelectionChangeShouldSetResponderCapture,
    onStartShouldSetResponder,
    onStartShouldSetResponderCapture
  });
  var _useLocaleContext = useLocaleContext(), contextDirection = _useLocaleContext.direction, supportedProps = pickProps(props);
  supportedProps.autoCapitalize = autoCapitalize, supportedProps.autoComplete = autoComplete || autoCompleteType || "on", supportedProps.autoCorrect = autoCorrect ? "on" : "off", supportedProps.dir = dir !== void 0 ? dir : "auto", returnKeyType != null && warn("returnKeyType", "returnKeyType is deprecated. Use enterKeyHint."), supportedProps.enterKeyHint = enterKeyHint || returnKeyType, supportedProps.inputMode = _inputMode, supportedProps.onBlur = handleBlur, supportedProps.onChange = handleChange, supportedProps.onFocus = handleFocus, supportedProps.onKeyDown = handleKeyDown, supportedProps.onSelect = handleSelectionChange, editable != null && warn("editable", "editable is deprecated. Use readOnly."), supportedProps.readOnly = readOnly === !0 || editable === !1, numberOfLines != null && warn("numberOfLines", "TextInput numberOfLines is deprecated. Use rows."), supportedProps.rows = multiline ? rows ?? numberOfLines : 1, supportedProps.spellCheck = spellCheck ?? autoCorrect, supportedProps.style = [
    {
      "--placeholderTextColor": placeholderTextColor
    },
    styles.textinput$raw,
    styles.placeholder,
    props.style
  ], supportedProps.type = multiline ? void 0 : type;
  var platformMethodsRef = usePlatformMethods(supportedProps), setRef = useMergeRefs(hostRef, platformMethodsRef, imperativeRef, forwardedRef);
  supportedProps.ref = setRef;
  var langDirection = props.lang != null ? getLocaleDirection(props.lang) : null, componentDirection = props.dir || langDirection, writingDirection = componentDirection || contextDirection, element = createElement(component, supportedProps, {
    writingDirection
  });
  return element;
});
function warn() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  if (process.env.NODE_ENV !== "production") {
    var _console;
    (_console = console).warn.apply(_console, _to_consumable_array(args));
  }
}
TextInput.displayName = "TextInput";
TextInput.State = TextInputState;
var styles = StyleSheet.create({
  textinput$raw: {
    MozAppearance: "textfield",
    WebkitAppearance: "none",
    backgroundColor: "transparent",
    border: "0 solid black",
    borderRadius: 0,
    boxSizing: "border-box",
    font: "14px System",
    margin: 0,
    padding: 0,
    resize: "none"
  },
  placeholder: {
    placeholderTextColor: "var(--placeholderTextColor)"
  }
}), TextInput_default = TextInput;
export {
  TextInput_default as default
};
//# sourceMappingURL=index.js.map
