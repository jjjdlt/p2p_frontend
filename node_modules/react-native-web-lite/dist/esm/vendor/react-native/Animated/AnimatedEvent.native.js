import { invariant } from "react-native-web-internals";
import NativeAnimatedHelper from "./NativeAnimatedHelper";
import { shouldUseNativeDriver } from "./NativeAnimatedHelper";
import AnimatedValue from "./nodes/AnimatedValue";
function _array_like_to_array(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _array_without_holes(arr) {
  if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _class_call_check(instance, Constructor) {
  if (!(instance instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _create_class(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;
}
function _instanceof(left, right) {
  return right != null && typeof Symbol < "u" && right[Symbol.hasInstance] ? !!right[Symbol.hasInstance](left) : left instanceof right;
}
function _iterable_to_array(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol < "u" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
  if (o) {
    if (typeof o == "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor && (n = o.constructor.name), n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
  }
}
var __DEV__ = process.env.NODE_ENV !== "production";
function attachNativeEvent(viewRef, eventName, argMapping) {
  var eventMappings = [], traverse = function(value, path) {
    if (_instanceof(value, AnimatedValue))
      value.__makeNative(), eventMappings.push({
        nativeEventPath: path,
        animatedValueTag: value.__getNativeTag()
      });
    else if (typeof value == "object")
      for (var _key in value)
        traverse(value[_key], path.concat(_key));
  };
  return invariant(argMapping[0] && argMapping[0].nativeEvent, "Native driven events only support animated values contained inside `nativeEvent`."), traverse(argMapping[0].nativeEvent, []), viewRef != null && eventMappings.forEach(function(mapping) {
    NativeAnimatedHelper.API.addAnimatedEventToView(viewRef, eventName, mapping);
  }), {
    detach: function() {
      viewRef != null && eventMappings.forEach(function(mapping) {
        NativeAnimatedHelper.API.removeAnimatedEventFromView(
          viewRef,
          eventName,
          // $FlowFixMe[incompatible-call]
          mapping.animatedValueTag
        );
      });
    }
  };
}
function validateMapping(argMapping, args) {
  var validate = function(recMapping, recEvt, key) {
    if (_instanceof(recMapping, AnimatedValue)) {
      invariant(typeof recEvt == "number", "Bad mapping of event key " + key + ", should be number but got " + (typeof recEvt > "u" ? "undefined" : _type_of(recEvt)));
      return;
    }
    if (typeof recEvt == "number") {
      invariant(_instanceof(recMapping, AnimatedValue), "Bad mapping of type " + (typeof recMapping > "u" ? "undefined" : _type_of(recMapping)) + " for key " + key + ", event value must map to AnimatedValue");
      return;
    }
    invariant(typeof recMapping == "object", "Bad mapping of type " + (typeof recMapping > "u" ? "undefined" : _type_of(recMapping)) + " for key " + key), invariant(typeof recEvt == "object", "Bad event of type " + (typeof recEvt > "u" ? "undefined" : _type_of(recEvt)) + " for key " + key);
    for (var mappingKey in recMapping)
      validate(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
  };
  invariant(args.length >= argMapping.length, "Event has less arguments than mapping"), argMapping.forEach(function(mapping, idx) {
    validate(mapping, args[idx], "arg" + idx);
  });
}
var AnimatedEvent = /* @__PURE__ */ function() {
  function AnimatedEvent2(argMapping, config) {
    _class_call_check(this, AnimatedEvent2), this._listeners = [], this._argMapping = argMapping, config == null && (console.warn("Animated.event now requires a second argument for options"), config = {
      useNativeDriver: !1
    }), config.listener && this.__addListener(config.listener), this._callListeners = this._callListeners.bind(this), this._attachedEvent = null, this.__isNative = shouldUseNativeDriver(config);
  }
  return _create_class(AnimatedEvent2, [
    {
      key: "__addListener",
      value: function(callback) {
        this._listeners.push(callback);
      }
    },
    {
      key: "__removeListener",
      value: function(callback) {
        this._listeners = this._listeners.filter(function(listener) {
          return listener !== callback;
        });
      }
    },
    {
      key: "__attach",
      value: function(viewRef, eventName) {
        invariant(this.__isNative, "Only native driven events need to be attached."), this._attachedEvent = attachNativeEvent(viewRef, eventName, this._argMapping);
      }
    },
    {
      key: "__detach",
      value: function(viewTag, eventName) {
        invariant(this.__isNative, "Only native driven events need to be detached."), this._attachedEvent && this._attachedEvent.detach();
      }
    },
    {
      key: "__getHandler",
      value: function() {
        var _this = this;
        if (this.__isNative)
          if (__DEV__) {
            var _validatedMapping = !1;
            return function() {
              for (var _this1, _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++)
                args[_key2] = arguments[_key2];
              _validatedMapping || (validateMapping(_this._argMapping, args), _validatedMapping = !0), (_this1 = _this)._callListeners.apply(_this1, _to_consumable_array(args));
            };
          } else
            return this._callListeners;
        var validatedMapping = !1;
        return function() {
          for (var _this1, _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++)
            args[_key3] = arguments[_key3];
          __DEV__ && !validatedMapping && (validateMapping(_this._argMapping, args), validatedMapping = !0);
          var traverse = function(recMapping, recEvt, key) {
            if (_instanceof(recMapping, AnimatedValue))
              typeof recEvt == "number" && recMapping.setValue(recEvt);
            else if (typeof recMapping == "object")
              for (var mappingKey in recMapping)
                traverse(recMapping[mappingKey], recEvt[mappingKey], mappingKey);
          };
          _this._argMapping.forEach(function(mapping, idx) {
            traverse(mapping, args[idx], "arg" + idx);
          }), (_this1 = _this)._callListeners.apply(_this1, _to_consumable_array(args));
        };
      }
    },
    {
      key: "_callListeners",
      value: function() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++)
          args[_key4] = arguments[_key4];
        this._listeners.forEach(function(listener) {
          return listener.apply(void 0, _to_consumable_array(args));
        });
      }
    }
  ]), AnimatedEvent2;
}();
export {
  AnimatedEvent,
  attachNativeEvent
};
//# sourceMappingURL=AnimatedEvent.js.map
