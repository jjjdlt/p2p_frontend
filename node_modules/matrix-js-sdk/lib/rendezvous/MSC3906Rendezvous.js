import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/*
Copyright 2022 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import { UnstableValue } from "matrix-events-sdk";
import { LegacyRendezvousFailureReason as RendezvousFailureReason, RendezvousIntent } from ".";
import { GET_LOGIN_TOKEN_CAPABILITY } from "../client";
import { buildFeatureSupportMap, Feature, ServerSupport } from "../feature";
import { logger } from "../logger";
import { sleep } from "../utils";
import { CrossSigningKey } from "../crypto-api";
var PayloadType = /*#__PURE__*/function (PayloadType) {
  PayloadType["Start"] = "m.login.start";
  PayloadType["Finish"] = "m.login.finish";
  PayloadType["Progress"] = "m.login.progress";
  return PayloadType;
}(PayloadType || {});
var Outcome = /*#__PURE__*/function (Outcome) {
  Outcome["Success"] = "success";
  Outcome["Failure"] = "failure";
  Outcome["Verified"] = "verified";
  Outcome["Declined"] = "declined";
  Outcome["Unsupported"] = "unsupported";
  return Outcome;
}(Outcome || {});
var LOGIN_TOKEN_PROTOCOL = new UnstableValue("login_token", "org.matrix.msc3906.login_token");

/**
 * Implements MSC3906 to allow a user to sign in on a new device using QR code.
 * This implementation only supports generating a QR code on a device that is already signed in.
 * Note that this is UNSTABLE and may have breaking changes without notice.
 * MSC3886/MSC3903/MSC3906 are now closed and so this functionality will be removed in future.
 * However, we want to keep this implementation around for some time.
 * TODO: define an end-of-life date for this implementation.
 */
export class MSC3906Rendezvous {
  /**
   * @param channel - The secure channel used for communication
   * @param client - The Matrix client in used on the device already logged in
   * @param onFailure - Callback for when the rendezvous fails
   */
  constructor(channel, client, onFailure) {
    _defineProperty(this, "ourIntent", RendezvousIntent.RECIPROCATE_LOGIN_ON_EXISTING_DEVICE);
    this.channel = channel;
    this.client = client;
    this.onFailure = onFailure;
  }

  /**
   * Returns the code representing the rendezvous suitable for rendering in a QR code or undefined if not generated yet.
   */
  get code() {
    return this._code;
  }

  /**
   * Generate the code including doing partial set up of the channel where required.
   */
  generateCode() {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (_this._code) {
        return;
      }
      _this._code = JSON.stringify(yield _this.channel.generateCode(_this.ourIntent));
    })();
  }
  startAfterShowingCode() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      var checksum = yield _this2.channel.connect();
      logger.info("Connected to secure channel with checksum: ".concat(checksum, " our intent is ").concat(_this2.ourIntent));

      // in stable and unstable r1 the availability is exposed as a capability
      var capabilities = yield _this2.client.getCapabilities();
      // in r0 of MSC3882 the availability is exposed as a feature flag
      var features = yield buildFeatureSupportMap(yield _this2.client.getVersions());
      var capability = GET_LOGIN_TOKEN_CAPABILITY.findIn(capabilities);

      // determine available protocols
      if (!(capability !== null && capability !== void 0 && capability.enabled) && features.get(Feature.LoginTokenRequest) === ServerSupport.Unsupported) {
        logger.info("Server doesn't support get_login_token");
        yield _this2.send({
          type: PayloadType.Finish,
          outcome: Outcome.Unsupported
        });
        yield _this2.cancel(RendezvousFailureReason.HomeserverLacksSupport);
        return undefined;
      }
      yield _this2.send({
        type: PayloadType.Progress,
        protocols: [LOGIN_TOKEN_PROTOCOL.name]
      });
      logger.info("Waiting for other device to choose protocol");
      var {
        type,
        protocol,
        outcome
      } = yield _this2.receive();
      if (type === PayloadType.Finish) {
        // new device decided not to complete
        switch (outcome !== null && outcome !== void 0 ? outcome : "") {
          case "unsupported":
            yield _this2.cancel(RendezvousFailureReason.UnsupportedAlgorithm);
            break;
          default:
            yield _this2.cancel(RendezvousFailureReason.Unknown);
        }
        return undefined;
      }
      if (type !== PayloadType.Progress) {
        yield _this2.cancel(RendezvousFailureReason.Unknown);
        return undefined;
      }
      if (!protocol || !LOGIN_TOKEN_PROTOCOL.matches(protocol)) {
        yield _this2.cancel(RendezvousFailureReason.UnsupportedAlgorithm);
        return undefined;
      }
      return checksum;
    })();
  }
  receive() {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      return yield _this3.channel.receive();
    })();
  }
  send(payload) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      yield _this4.channel.send(payload);
    })();
  }
  declineLoginOnExistingDevice() {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      logger.info("User declined sign in");
      yield _this5.send({
        type: PayloadType.Finish,
        outcome: Outcome.Declined
      });
    })();
  }
  approveLoginOnExistingDevice(loginToken) {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      // eslint-disable-next-line camelcase
      yield _this6.send({
        type: PayloadType.Progress,
        login_token: loginToken,
        homeserver: _this6.client.baseUrl
      });
      logger.info("Waiting for outcome");
      var res = yield _this6.receive();
      if (!res) {
        return undefined;
      }
      var {
        outcome,
        device_id: deviceId,
        device_key: deviceKey
      } = res;
      if (outcome !== "success") {
        throw new Error("Linking failed");
      }
      _this6.newDeviceId = deviceId;
      _this6.newDeviceKey = deviceKey;
      return deviceId;
    })();
  }
  verifyAndCrossSignDevice(deviceInfo) {
    var _this7 = this;
    return _asyncToGenerator(function* () {
      var _yield$crypto$getCros;
      var crypto = _this7.client.getCrypto();
      if (!_this7.newDeviceId) {
        throw new Error("No new device ID set");
      }

      // check that keys received from the server for the new device match those received from the device itself
      if (deviceInfo.getFingerprint() !== _this7.newDeviceKey) {
        throw new Error("New device has different keys than expected: ".concat(_this7.newDeviceKey, " vs ").concat(deviceInfo.getFingerprint()));
      }
      var userId = _this7.client.getSafeUserId();

      // mark the device as verified locally + cross sign
      logger.info("Marking device ".concat(_this7.newDeviceId, " as verified"));
      yield crypto.setDeviceVerified(userId, _this7.newDeviceId, true);
      yield crypto.crossSignDevice(_this7.newDeviceId);
      var masterPublicKey = (_yield$crypto$getCros = yield crypto.getCrossSigningKeyId(CrossSigningKey.Master)) !== null && _yield$crypto$getCros !== void 0 ? _yield$crypto$getCros : undefined;
      var ourDeviceId = _this7.client.getDeviceId();
      var ourDeviceKey = (yield crypto.getOwnDeviceKeys()).ed25519;
      yield _this7.send({
        type: PayloadType.Finish,
        outcome: Outcome.Verified,
        verifying_device_id: ourDeviceId,
        verifying_device_key: ourDeviceKey,
        master_key: masterPublicKey
      });
    })();
  }

  /**
   * Verify the device and cross-sign it.
   * @param timeout - time in milliseconds to wait for device to come online
   */
  verifyNewDeviceOnExistingDevice() {
    var _arguments = arguments,
      _this8 = this;
    return _asyncToGenerator(function* () {
      var timeout = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : 10 * 1000;
      if (!_this8.newDeviceId) {
        throw new Error("No new device to sign");
      }
      if (!_this8.newDeviceKey) {
        logger.info("No new device key to sign");
        return undefined;
      }
      var crypto = _this8.client.getCrypto();
      if (!crypto) {
        throw new Error("Crypto not available on client");
      }
      var deviceInfo = yield _this8.getOwnDevice(_this8.newDeviceId);
      if (!deviceInfo) {
        logger.info("Going to wait for new device to be online");
        yield sleep(timeout);
        deviceInfo = yield _this8.getOwnDevice(_this8.newDeviceId);
      }
      if (deviceInfo) {
        yield _this8.verifyAndCrossSignDevice(deviceInfo);
        return;
      }
      throw new Error("Device not online within timeout");
    })();
  }
  getOwnDevice(deviceId) {
    var _this9 = this;
    return _asyncToGenerator(function* () {
      var _ownDeviceInfo$get;
      var userId = _this9.client.getSafeUserId();
      var ownDeviceInfo = yield _this9.client.getCrypto().getUserDeviceInfo([userId]);
      return (_ownDeviceInfo$get = ownDeviceInfo.get(userId)) === null || _ownDeviceInfo$get === void 0 ? void 0 : _ownDeviceInfo$get.get(deviceId);
    })();
  }
  cancel(reason) {
    var _this10 = this;
    return _asyncToGenerator(function* () {
      var _this10$onFailure;
      (_this10$onFailure = _this10.onFailure) === null || _this10$onFailure === void 0 || _this10$onFailure.call(_this10, reason);
      yield _this10.channel.cancel(reason);
    })();
  }
  close() {
    var _this11 = this;
    return _asyncToGenerator(function* () {
      yield _this11.channel.close();
    })();
  }
}
//# sourceMappingURL=MSC3906Rendezvous.js.map