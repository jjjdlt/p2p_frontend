import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
/*
Copyright 2023 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import { RendezvousError, LegacyRendezvousFailureReason as RendezvousFailureReason } from "..";
import { encodeUnpaddedBase64, decodeBase64 } from "../../base64";
import { crypto, subtleCrypto, TextEncoder } from "../../crypto/crypto";
import { generateDecimalSas } from "../../crypto/verification/SASDecimal";
import { UnstableValue } from "../../NamespacedValue";
var ECDH_V2 = new UnstableValue("m.rendezvous.v2.curve25519-aes-sha256", "org.matrix.msc3903.rendezvous.v2.curve25519-aes-sha256");
function importKey(_x) {
  return _importKey.apply(this, arguments);
}
/**
 * Implementation of the unstable [MSC3903](https://github.com/matrix-org/matrix-spec-proposals/pull/3903)
 * X25519/ECDH key agreement based secure rendezvous channel.
 * Note that this is UNSTABLE and may have breaking changes without notice.
 * MSC3886/MSC3903/MSC3906 are now closed and so this functionality will be removed in future.
 * However, we want to keep this implementation around for some time.
 * TODO: define an end-of-life date for this implementation.
 */
function _importKey() {
  _importKey = _asyncToGenerator(function* (key) {
    if (!subtleCrypto) {
      throw new Error("Web Crypto is not available");
    }
    var imported = subtleCrypto.importKey("raw", key, {
      name: "AES-GCM"
    }, false, ["encrypt", "decrypt"]);
    return imported;
  });
  return _importKey.apply(this, arguments);
}
export class MSC3903ECDHv2RendezvousChannel {
  constructor(transport, theirPublicKey, onFailure) {
    _defineProperty(this, "connected", false);
    this.transport = transport;
    this.theirPublicKey = theirPublicKey;
    this.onFailure = onFailure;
    this.olmSAS = new global.Olm.SAS();
    this.ourPublicKey = decodeBase64(this.olmSAS.get_pubkey());
  }
  generateCode(intent) {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (_this.transport.ready) {
        throw new Error("Code already generated");
      }
      yield _this.transport.send({
        algorithm: ECDH_V2.name
      });
      var rendezvous = {
        rendezvous: {
          algorithm: ECDH_V2.name,
          key: encodeUnpaddedBase64(_this.ourPublicKey),
          transport: yield _this.transport.details()
        },
        intent
      };
      return rendezvous;
    })();
  }
  connect() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      if (_this2.connected) {
        throw new Error("Channel already connected");
      }
      if (!_this2.olmSAS) {
        throw new Error("Channel closed");
      }
      var isInitiator = !_this2.theirPublicKey;
      if (isInitiator) {
        // wait for the other side to send us their public key
        var rawRes = yield _this2.transport.receive();
        if (!rawRes) {
          throw new Error("No response from other device");
        }
        var res = rawRes;
        var {
          key,
          algorithm
        } = res;
        if (!algorithm || !ECDH_V2.matches(algorithm) || !key) {
          throw new RendezvousError("Unsupported algorithm: " + algorithm, RendezvousFailureReason.UnsupportedAlgorithm);
        }
        _this2.theirPublicKey = decodeBase64(key);
      } else {
        // send our public key unencrypted
        yield _this2.transport.send({
          algorithm: ECDH_V2.name,
          key: encodeUnpaddedBase64(_this2.ourPublicKey)
        });
      }
      _this2.connected = true;
      _this2.olmSAS.set_their_key(encodeUnpaddedBase64(_this2.theirPublicKey));
      var initiatorKey = isInitiator ? _this2.ourPublicKey : _this2.theirPublicKey;
      var recipientKey = isInitiator ? _this2.theirPublicKey : _this2.ourPublicKey;
      var aesInfo = ECDH_V2.name;
      aesInfo += "|".concat(encodeUnpaddedBase64(initiatorKey));
      aesInfo += "|".concat(encodeUnpaddedBase64(recipientKey));
      var aesKeyBytes = _this2.olmSAS.generate_bytes(aesInfo, 32);
      _this2.aesKey = yield importKey(aesKeyBytes);

      // blank the bytes out to make sure not kept in memory
      aesKeyBytes.fill(0);
      var rawChecksum = _this2.olmSAS.generate_bytes(aesInfo, 5);
      return generateDecimalSas(Array.from(rawChecksum)).join("-");
    })();
  }
  encrypt(data) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      if (!subtleCrypto) {
        throw new Error("Web Crypto is not available");
      }
      var iv = new Uint8Array(32);
      crypto.getRandomValues(iv);
      var encodedData = new TextEncoder().encode(JSON.stringify(data));
      var ciphertext = yield subtleCrypto.encrypt({
        name: "AES-GCM",
        iv,
        tagLength: 128
      }, _this3.aesKey, encodedData);
      return {
        iv: encodeUnpaddedBase64(iv),
        ciphertext: encodeUnpaddedBase64(ciphertext)
      };
    })();
  }
  send(payload) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      if (!_this4.olmSAS) {
        throw new Error("Channel closed");
      }
      if (!_this4.aesKey) {
        throw new Error("Shared secret not set up");
      }
      return _this4.transport.send(yield _this4.encrypt(payload));
    })();
  }
  decrypt(_ref) {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      var {
        iv,
        ciphertext
      } = _ref;
      if (!ciphertext || !iv) {
        throw new Error("Missing ciphertext and/or iv");
      }
      var ciphertextBytes = decodeBase64(ciphertext);
      if (!subtleCrypto) {
        throw new Error("Web Crypto is not available");
      }
      var plaintext = yield subtleCrypto.decrypt({
        name: "AES-GCM",
        iv: decodeBase64(iv),
        tagLength: 128
      }, _this5.aesKey, ciphertextBytes);
      return JSON.parse(new TextDecoder().decode(new Uint8Array(plaintext)));
    })();
  }
  receive() {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      if (!_this6.olmSAS) {
        throw new Error("Channel closed");
      }
      if (!_this6.aesKey) {
        throw new Error("Shared secret not set up");
      }
      var rawData = yield _this6.transport.receive();
      if (!rawData) {
        return undefined;
      }
      var data = rawData;
      if (data.ciphertext && data.iv) {
        return _this6.decrypt(data);
      }
      throw new Error("Data received but no ciphertext");
    })();
  }
  close() {
    var _this7 = this;
    return _asyncToGenerator(function* () {
      if (_this7.olmSAS) {
        _this7.olmSAS.free();
        _this7.olmSAS = undefined;
      }
    })();
  }
  cancel(reason) {
    var _this8 = this;
    return _asyncToGenerator(function* () {
      try {
        yield _this8.transport.cancel(reason);
      } finally {
        yield _this8.close();
      }
    })();
  }
}
//# sourceMappingURL=MSC3903ECDHv2RendezvousChannel.js.map