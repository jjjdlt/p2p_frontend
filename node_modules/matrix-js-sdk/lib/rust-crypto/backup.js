import _asyncToGenerator from "@babel/runtime/helpers/asyncToGenerator";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
/*
Copyright 2023 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

import * as RustSdkCryptoJs from "@matrix-org/matrix-sdk-crypto-wasm";
import { logger } from "../logger";
import { ClientPrefix, MatrixError, Method } from "../http-api";
import { CryptoEvent } from "../crypto";
import { TypedEventEmitter } from "../models/typed-event-emitter";
import { encodeUri, logDuration } from "../utils";
import { sleep } from "../utils";

/** Authentification of the backup info, depends on algorithm */

/**
 * Holds information of a created keybackup.
 * Useful to get the generated private key material and save it securely somewhere.
 */

/**
 * @internal
 */
export class RustBackupManager extends TypedEventEmitter {
  constructor(olmMachine, http, outgoingRequestProcessor) {
    super();
    /** Have we checked if there is a backup on the server which we can use */
    _defineProperty(this, "checkedForBackup", false);
    /**
     * The latest backup version on the server, when we last checked.
     *
     * If there was no backup on the server, `null`. If our attempt to check resulted in an error, `undefined`.
     *
     * Note that the backup was not necessarily verified.
     */
    _defineProperty(this, "serverBackupInfo", undefined);
    _defineProperty(this, "activeBackupVersion", null);
    _defineProperty(this, "stopped", false);
    /** whether {@link backupKeysLoop} is currently running */
    _defineProperty(this, "backupKeysLoopRunning", false);
    _defineProperty(this, "keyBackupCheckInProgress", null);
    this.olmMachine = olmMachine;
    this.http = http;
    this.outgoingRequestProcessor = outgoingRequestProcessor;
  }

  /**
   * Tells the RustBackupManager to stop.
   * The RustBackupManager is scheduling background uploads of keys to the backup, this
   * call allows to cancel the process when the client is stoppped.
   */
  stop() {
    this.stopped = true;
  }

  /**
   * Get the backup version we are currently backing up to, if any
   */
  getActiveBackupVersion() {
    var _this = this;
    return _asyncToGenerator(function* () {
      if (!(yield _this.olmMachine.isBackupEnabled())) return null;
      return _this.activeBackupVersion;
    })();
  }

  /**
   * Return the details of the latest backup on the server, when we last checked.
   *
   * This normally returns a cached value, but if we haven't yet made a request to the server, it will fire one off.
   * It will always return the details of the active backup if key backup is enabled.
   *
   * If there was no backup on the server, `null`. If our attempt to check resulted in an error, `undefined`.
   */
  getServerBackupInfo() {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      // Do a validity check if we haven't already done one. The check is likely to fail if we don't yet have the
      // backup keys -- but as a side-effect, it will populate `serverBackupInfo`.
      yield _this2.checkKeyBackupAndEnable(false);
      return _this2.serverBackupInfo;
    })();
  }

  /**
   * Determine if a key backup can be trusted.
   *
   * @param info - key backup info dict from {@link MatrixClient#getKeyBackupVersion}.
   */
  isKeyBackupTrusted(info) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      var signatureVerification = yield _this3.olmMachine.verifyBackup(info);
      var backupKeys = yield _this3.olmMachine.getBackupKeys();
      var decryptionKey = backupKeys === null || backupKeys === void 0 ? void 0 : backupKeys.decryptionKey;
      var backupMatchesSavedPrivateKey = !!decryptionKey && backupInfoMatchesBackupDecryptionKey(info, decryptionKey);
      return {
        matchesDecryptionKey: backupMatchesSavedPrivateKey,
        trusted: signatureVerification.trusted()
      };
    })();
  }

  /**
   * Re-check the key backup and enable/disable it as appropriate.
   *
   * @param force - whether we should force a re-check even if one has already happened.
   */
  checkKeyBackupAndEnable(force) {
    if (!force && this.checkedForBackup) {
      return Promise.resolve(null);
    }

    // make sure there is only one check going on at a time
    if (!this.keyBackupCheckInProgress) {
      this.keyBackupCheckInProgress = this.doCheckKeyBackup().finally(() => {
        this.keyBackupCheckInProgress = null;
      });
    }
    return this.keyBackupCheckInProgress;
  }

  /**
   * Handles a backup secret received event and store it if it matches the current backup version.
   *
   * @param secret - The secret as received from a `m.secret.send` event for secret `m.megolm_backup.v1`.
   * @returns true if the secret is valid and has been stored, false otherwise.
   */
  handleBackupSecretReceived(secret) {
    var _this4 = this;
    return _asyncToGenerator(function* () {
      var _backupCheck$backupIn;
      // Currently we only receive the decryption key without any key backup version. It is important to
      // check that the secret is valid for the current version before storing it.
      // We force a check to ensure to have the latest version. We also want to check that the backup is trusted
      // as we don't want to store the secret if the backup is not trusted, and eventually import megolm keys later from an untrusted backup.
      var backupCheck = yield _this4.checkKeyBackupAndEnable(true);
      if (!(backupCheck !== null && backupCheck !== void 0 && (_backupCheck$backupIn = backupCheck.backupInfo) !== null && _backupCheck$backupIn !== void 0 && _backupCheck$backupIn.version) || !backupCheck.trustInfo.trusted) {
        // There is no server-side key backup, or the backup is not signed by a trusted cross-signing key or trusted own device.
        // This decryption key is useless to us.
        logger.warn("handleBackupSecretReceived: Received a backup decryption key, but there is no trusted server-side key backup");
        return false;
      }
      try {
        var backupDecryptionKey = RustSdkCryptoJs.BackupDecryptionKey.fromBase64(secret);
        var privateKeyMatches = backupInfoMatchesBackupDecryptionKey(backupCheck.backupInfo, backupDecryptionKey);
        if (!privateKeyMatches) {
          logger.warn("handleBackupSecretReceived: Private decryption key does not match the public key of the current remote backup.");
          // just ignore the secret
          return false;
        }
        logger.info("handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache.");
        yield _this4.saveBackupDecryptionKey(backupDecryptionKey, backupCheck.backupInfo.version);
        return true;
      } catch (e) {
        logger.warn("handleBackupSecretReceived: Invalid backup decryption key", e);
      }
      return false;
    })();
  }
  saveBackupDecryptionKey(backupDecryptionKey, version) {
    var _this5 = this;
    return _asyncToGenerator(function* () {
      yield _this5.olmMachine.saveBackupDecryptionKey(backupDecryptionKey, version);
      // Emit an event that we have a new backup decryption key, so that the sdk can start
      // importing keys from backup if needed.
      _this5.emit(CryptoEvent.KeyBackupDecryptionKeyCached, version);
    })();
  }

  /**
   * Import a list of room keys previously exported by exportRoomKeys
   *
   * @param keys - a list of session export objects
   * @param opts - options object
   * @returns a promise which resolves once the keys have been imported
   */
  importRoomKeys(keys, opts) {
    var _this6 = this;
    return _asyncToGenerator(function* () {
      yield _this6.importRoomKeysAsJson(JSON.stringify(keys), opts);
    })();
  }

  /**
   * Import a list of room keys previously exported by exportRoomKeysAsJson
   *
   * @param keys - a JSON string encoding a list of session export objects,
   *    each of which is an IMegolmSessionData
   * @param opts - options object
   * @returns a promise which resolves once the keys have been imported
   */
  importRoomKeysAsJson(jsonKeys, opts) {
    var _this7 = this;
    return _asyncToGenerator(function* () {
      yield _this7.olmMachine.importExportedRoomKeys(jsonKeys, (progress, total) => {
        var _opts$progressCallbac;
        var importOpt = {
          total: Number(total),
          successes: Number(progress),
          stage: "load_keys",
          failures: 0
        };
        opts === null || opts === void 0 || (_opts$progressCallbac = opts.progressCallback) === null || _opts$progressCallbac === void 0 || _opts$progressCallbac.call(opts, importOpt);
      });
    })();
  }

  /**
   * Implementation of {@link CryptoBackend#importBackedUpRoomKeys}.
   */
  importBackedUpRoomKeys(keys, backupVersion, opts) {
    var _this8 = this;
    return _asyncToGenerator(function* () {
      var keysByRoom = new Map();
      for (var key of keys) {
        var roomId = new RustSdkCryptoJs.RoomId(key.room_id);
        if (!keysByRoom.has(roomId)) {
          keysByRoom.set(roomId, new Map());
        }
        keysByRoom.get(roomId).set(key.session_id, key);
      }
      yield _this8.olmMachine.importBackedUpRoomKeys(keysByRoom, (progress, total, failures) => {
        var _opts$progressCallbac2;
        var importOpt = {
          total: Number(total),
          successes: Number(progress),
          stage: "load_keys",
          failures: Number(failures)
        };
        opts === null || opts === void 0 || (_opts$progressCallbac2 = opts.progressCallback) === null || _opts$progressCallbac2 === void 0 || _opts$progressCallbac2.call(opts, importOpt);
      }, backupVersion);
    })();
  }
  /** Helper for `checkKeyBackup` */
  doCheckKeyBackup() {
    var _this9 = this;
    return _asyncToGenerator(function* () {
      logger.log("Checking key backup status...");
      var backupInfo;
      try {
        backupInfo = yield _this9.requestKeyBackupVersion();
      } catch (e) {
        logger.warn("Error checking for active key backup", e);
        _this9.serverBackupInfo = undefined;
        return null;
      }
      _this9.checkedForBackup = true;
      if (backupInfo && !backupInfo.version) {
        logger.warn("active backup lacks a useful 'version'; ignoring it");
        backupInfo = undefined;
      }
      _this9.serverBackupInfo = backupInfo;
      var activeVersion = yield _this9.getActiveBackupVersion();
      if (!backupInfo) {
        if (activeVersion !== null) {
          logger.log("No key backup present on server: disabling key backup");
          yield _this9.disableKeyBackup();
        } else {
          logger.log("No key backup present on server: not enabling key backup");
        }
        return null;
      }
      var trustInfo = yield _this9.isKeyBackupTrusted(backupInfo);
      if (!trustInfo.trusted) {
        if (activeVersion !== null) {
          logger.log("Key backup present on server but not trusted: disabling key backup");
          yield _this9.disableKeyBackup();
        } else {
          logger.log("Key backup present on server but not trusted: not enabling key backup");
        }
      } else {
        if (activeVersion === null) {
          logger.log("Found usable key backup v".concat(backupInfo.version, ": enabling key backups"));
          yield _this9.enableKeyBackup(backupInfo);
        } else if (activeVersion !== backupInfo.version) {
          logger.log("On backup version ".concat(activeVersion, " but found version ").concat(backupInfo.version, ": switching."));
          // This will remove any pending backup request, remove the backup key and reset the backup state of each room key we have.
          yield _this9.disableKeyBackup();
          // Enabling will now trigger re-upload of all the keys
          yield _this9.enableKeyBackup(backupInfo);
        } else {
          logger.log("Backup version ".concat(backupInfo.version, " still current"));
        }
      }
      return {
        backupInfo,
        trustInfo
      };
    })();
  }
  enableKeyBackup(backupInfo) {
    var _this10 = this;
    return _asyncToGenerator(function* () {
      // we know for certain it must be a Curve25519 key, because we have verified it and only Curve25519
      // keys can be verified.
      //
      // we also checked it has a valid `version`.
      yield _this10.olmMachine.enableBackupV1(backupInfo.auth_data.public_key, backupInfo.version);
      _this10.activeBackupVersion = backupInfo.version;
      _this10.emit(CryptoEvent.KeyBackupStatus, true);
      _this10.backupKeysLoop();
    })();
  }

  /**
   * Restart the backup key loop if there is an active trusted backup.
   * Doesn't try to check the backup server side. To be called when a new
   * megolm key is known locally.
   */
  maybeUploadKey() {
    var _this11 = this;
    return _asyncToGenerator(function* () {
      if (_this11.activeBackupVersion != null) {
        _this11.backupKeysLoop();
      }
    })();
  }
  disableKeyBackup() {
    var _this12 = this;
    return _asyncToGenerator(function* () {
      yield _this12.olmMachine.disableBackup();
      _this12.activeBackupVersion = null;
      _this12.emit(CryptoEvent.KeyBackupStatus, false);
    })();
  }
  backupKeysLoop() {
    var _arguments = arguments,
      _this13 = this;
    return _asyncToGenerator(function* () {
      var maxDelay = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : 10000;
      if (_this13.backupKeysLoopRunning) {
        logger.log("Backup loop already running");
        return;
      }
      _this13.backupKeysLoopRunning = true;
      logger.log("Backup: Starting keys upload loop for backup version:".concat(_this13.activeBackupVersion, "."));

      // wait between 0 and `maxDelay` seconds, to avoid backup
      // requests from different clients hitting the server all at
      // the same time when a new key is sent
      var delay = Math.random() * maxDelay;
      yield sleep(delay);
      try {
        // number of consecutive network failures for exponential backoff
        var numFailures = 0;
        // The number of keys left to back up. (Populated lazily: see more comments below.)
        var remainingToUploadCount = null;
        // To avoid computing the key when only a few keys were added (after a sync for example),
        // we compute the count only when at least two iterations are needed.
        var isFirstIteration = true;
        while (!_this13.stopped) {
          // Get a batch of room keys to upload
          var request = null;
          try {
            request = yield logDuration(logger, "BackupRoomKeys: Get keys to backup from rust crypto-sdk", /*#__PURE__*/_asyncToGenerator(function* () {
              return yield _this13.olmMachine.backupRoomKeys();
            }));
          } catch (err) {
            logger.error("Backup: Failed to get keys to backup from rust crypto-sdk", err);
          }
          if (!request || _this13.stopped || !_this13.activeBackupVersion) {
            logger.log("Backup: Ending loop for version ".concat(_this13.activeBackupVersion, "."));
            if (!request) {
              // nothing more to upload
              _this13.emit(CryptoEvent.KeyBackupSessionsRemaining, 0);
            }
            return;
          }
          try {
            yield _this13.outgoingRequestProcessor.makeOutgoingRequest(request);
            numFailures = 0;
            if (_this13.stopped) break;

            // Key count performance (`olmMachine.roomKeyCounts()`) can be pretty bad on some configurations.
            // In particular, we detected on some M1 macs that when the object store reaches a threshold, the count
            // performance stops growing in O(n) and suddenly becomes very slow (40s, 60s or more).
            // For reference, the performance drop occurs around 300-400k keys on the platforms where this issue is observed.
            // Even on other configurations, the count can take several seconds.
            // This will block other operations on the database, like sending messages.
            //
            // This is a workaround to avoid calling `olmMachine.roomKeyCounts()` too often, and only when necessary.
            // We don't call it on the first loop because there could be only a few keys to upload, and we don't want to wait for the count.
            if (!isFirstIteration && remainingToUploadCount === null) {
              try {
                var keyCount = yield _this13.olmMachine.roomKeyCounts();
                remainingToUploadCount = keyCount.total - keyCount.backedUp;
              } catch (err) {
                logger.error("Backup: Failed to get key counts from rust crypto-sdk", err);
              }
            }
            if (remainingToUploadCount !== null) {
              _this13.emit(CryptoEvent.KeyBackupSessionsRemaining, remainingToUploadCount);
              var keysCountInBatch = _this13.keysCountInBatch(request);
              // `OlmMachine.roomKeyCounts` is called only once for the current backupKeysLoop. But new
              // keys could be added during the current loop (after a sync for example).
              // So the count can get out of sync with the real number of remaining keys to upload.
              // Depending on the number of new keys imported and the time to complete the loop,
              // this could result in multiple events being emitted with a remaining key count of 0.
              remainingToUploadCount = Math.max(remainingToUploadCount - keysCountInBatch, 0);
            }
          } catch (err) {
            numFailures++;
            logger.error("Backup: Error processing backup request for rust crypto-sdk", err);
            if (err instanceof MatrixError) {
              var errCode = err.data.errcode;
              if (errCode == "M_NOT_FOUND" || errCode == "M_WRONG_ROOM_KEYS_VERSION") {
                logger.log("Backup: Failed to upload keys to current vesion: ".concat(errCode, "."));
                try {
                  yield _this13.disableKeyBackup();
                } catch (error) {
                  logger.error("Backup: An error occurred while disabling key backup:", error);
                }
                _this13.emit(CryptoEvent.KeyBackupFailed, err.data.errcode);
                // There was an active backup and we are out of sync with the server
                // force a check server side
                _this13.backupKeysLoopRunning = false;
                _this13.checkKeyBackupAndEnable(true);
                return;
              } else if (errCode == "M_LIMIT_EXCEEDED") {
                // wait for that and then continue?
                var waitTime = err.data.retry_after_ms;
                if (waitTime > 0) {
                  yield sleep(waitTime);
                  continue;
                } // else go to the normal backoff
              }
            }

            // Some other errors (mx, network, or CORS or invalid urls?) anyhow backoff
            // exponential backoff if we have failures
            yield sleep(1000 * Math.pow(2, Math.min(numFailures - 1, 4)));
          }
          isFirstIteration = false;
        }
      } finally {
        _this13.backupKeysLoopRunning = false;
      }
    })();
  }

  /**
   * Utility method to count the number of keys in a backup request, in order to update the remaining keys count.
   * This should be the chunk size of the backup request for all requests but the last, but we don't have access to it
   * (it's static in the Rust SDK).
   * @param batch - The backup request to count the keys from.
   *
   * @returns The number of keys in the backup request.
   */
  keysCountInBatch(batch) {
    var parsedBody = JSON.parse(batch.body);
    var count = 0;
    for (var {
      sessions
    } of Object.values(parsedBody.rooms)) {
      count += Object.keys(sessions).length;
    }
    return count;
  }

  /**
   * Get information about the current key backup from the server
   *
   * @returns Information object from API or null if there is no active backup.
   */
  requestKeyBackupVersion() {
    var _this14 = this;
    return _asyncToGenerator(function* () {
      return yield requestKeyBackupVersion(_this14.http);
    })();
  }

  /**
   * Creates a new key backup by generating a new random private key.
   *
   * If there is an existing backup server side it will be deleted and replaced
   * by the new one.
   *
   * @param signObject - Method that should sign the backup with existing device and
   * existing identity.
   * @returns a KeyBackupCreationInfo - All information related to the backup.
   */
  setupKeyBackup(signObject) {
    var _this15 = this;
    return _asyncToGenerator(function* () {
      // Clean up any existing backup
      yield _this15.deleteAllKeyBackupVersions();
      var randomKey = RustSdkCryptoJs.BackupDecryptionKey.createRandomKey();
      var pubKey = randomKey.megolmV1PublicKey;
      var authData = {
        public_key: pubKey.publicKeyBase64
      };
      yield signObject(authData);
      var res = yield _this15.http.authedRequest(Method.Post, "/room_keys/version", undefined, {
        algorithm: pubKey.algorithm,
        auth_data: authData
      }, {
        prefix: ClientPrefix.V3
      });
      yield _this15.saveBackupDecryptionKey(randomKey, res.version);
      return {
        version: res.version,
        algorithm: pubKey.algorithm,
        authData: authData,
        decryptionKey: randomKey
      };
    })();
  }

  /**
   * Deletes all key backups.
   *
   * Will call the API to delete active backup until there is no more present.
   */
  deleteAllKeyBackupVersions() {
    var _this16 = this;
    return _asyncToGenerator(function* () {
      var _yield$_this16$reques, _yield$_this16$reques2;
      // there could be several backup versions. Delete all to be safe.
      var current = (_yield$_this16$reques = (_yield$_this16$reques2 = yield _this16.requestKeyBackupVersion()) === null || _yield$_this16$reques2 === void 0 ? void 0 : _yield$_this16$reques2.version) !== null && _yield$_this16$reques !== void 0 ? _yield$_this16$reques : null;
      while (current != null) {
        var _yield$_this16$reques3, _yield$_this16$reques4;
        yield _this16.deleteKeyBackupVersion(current);
        current = (_yield$_this16$reques3 = (_yield$_this16$reques4 = yield _this16.requestKeyBackupVersion()) === null || _yield$_this16$reques4 === void 0 ? void 0 : _yield$_this16$reques4.version) !== null && _yield$_this16$reques3 !== void 0 ? _yield$_this16$reques3 : null;
      }

      // XXX: Should this also update Secret Storage and delete any existing keys?
    })();
  }

  /**
   * Deletes the given key backup.
   *
   * @param version - The backup version to delete.
   */
  deleteKeyBackupVersion(version) {
    var _this17 = this;
    return _asyncToGenerator(function* () {
      logger.debug("deleteKeyBackupVersion v:".concat(version));
      var path = encodeUri("/room_keys/version/$version", {
        $version: version
      });
      yield _this17.http.authedRequest(Method.Delete, path, undefined, undefined, {
        prefix: ClientPrefix.V3
      });
    })();
  }

  /**
   * Creates a new backup decryptor for the given private key.
   * @param decryptionKey - The private key to use for decryption.
   */
  createBackupDecryptor(decryptionKey) {
    return new RustBackupDecryptor(decryptionKey);
  }
}

/**
 * Checks if the provided backup info matches the given private key.
 *
 * @param info - The backup info to check.
 * @param backupDecryptionKey - The `BackupDecryptionKey` private key to check against.
 * @returns `true` if the private key can decrypt the backup, `false` otherwise.
 */
function backupInfoMatchesBackupDecryptionKey(info, backupDecryptionKey) {
  var _info$auth_data;
  if (info.algorithm !== "m.megolm_backup.v1.curve25519-aes-sha2") {
    logger.warn("backupMatchesPrivateKey: Unsupported backup algorithm", info.algorithm);
    return false;
  }
  return ((_info$auth_data = info.auth_data) === null || _info$auth_data === void 0 ? void 0 : _info$auth_data.public_key) === backupDecryptionKey.megolmV1PublicKey.publicKeyBase64;
}

/**
 * Implementation of {@link BackupDecryptor} for the rust crypto backend.
 */
export class RustBackupDecryptor {
  constructor(decryptionKey) {
    this.decryptionKey = decryptionKey;
    this.sourceTrusted = false;
  }

  /**
   * Implements {@link BackupDecryptor#decryptSessions}
   */
  decryptSessions(ciphertexts) {
    var _this18 = this;
    return _asyncToGenerator(function* () {
      var keys = [];
      for (var [sessionId, sessionData] of Object.entries(ciphertexts)) {
        try {
          var decrypted = JSON.parse(_this18.decryptionKey.decryptV1(sessionData.session_data.ephemeral, sessionData.session_data.mac, sessionData.session_data.ciphertext));
          decrypted.session_id = sessionId;
          keys.push(decrypted);
        } catch (e) {
          logger.log("Failed to decrypt megolm session from backup", e, sessionData);
        }
      }
      return keys;
    })();
  }

  /**
   * Implements {@link BackupDecryptor#free}
   */
  free() {
    this.decryptionKey.free();
  }
}
export function requestKeyBackupVersion(_x) {
  return _requestKeyBackupVersion.apply(this, arguments);
}
function _requestKeyBackupVersion() {
  _requestKeyBackupVersion = _asyncToGenerator(function* (http) {
    try {
      return yield http.authedRequest(Method.Get, "/room_keys/version", undefined, undefined, {
        prefix: ClientPrefix.V3
      });
    } catch (e) {
      if (e.errcode === "M_NOT_FOUND") {
        return null;
      } else {
        throw e;
      }
    }
  });
  return _requestKeyBackupVersion.apply(this, arguments);
}
//# sourceMappingURL=backup.js.map